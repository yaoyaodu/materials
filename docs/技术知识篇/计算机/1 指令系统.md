# 第5章 指令系统

（1）指令的格式、寻址方式和功能分类。
（2）RISC与CISC指令以及**适于多媒体应用的MMX指令**。
（3）典型计算机的指令系统。

存储程序是计算机最基本的结构特征之一，程序员**用各种语言编写的程序**最后要**翻译（解释或编译）**成**以指令形式表示的机器语言**以后，才能在计算机上运行。

计算机的指令有**微指令、机器指令和宏指令**之分。

- **微指令**是**微程序级的命令**，属于**硬件**。
- **宏指令**是由**若干机器指令组成的**，属于**软件**。
- **机器指令**介于二者之间，因而是**硬件和软件的界面**。

一台计算机**能执行的机器指令的集合**统称为该机的**指令系统**。它是**软件编程的出发点和硬件设计的依据**，它**能衡量机器硬件的功能**，**反映硬件对软件支持的程度**。

## 5.1 指令格式与指令长度

### 5.1.1 指令格式

**机器指令必须规定硬件要完成的操作**，并**指出操作数或操作数地址**。指令的一般格式如下：

按指令**所包含的地址的个数**可将指令分为如下4种：

1．三地址指令

最初的机器指令包含三个地址，分别存放第一个操作数的单元地址、第二个操作数的单元地址和操作结果的单元地址，格式如下：

它表示地址为D1的单元内容和地址为D2的单元内容执行OP操作，结果存入地址为D3所指的单元。

三地址指令中**地址多，指令字长长，占用存储器空间大，运行效率低**，现已不常用。

2．二地址指令

操作结果可放回某一个操作数单元，这个操作数称为**目标操作数**，另一个操作数称为**源操作数**，这样就产生了二地址指令：

3．单地址指令

如果用CPU中一个**专用寄存器A（称累加器）**作为**目标操作数，又可以省去一个地址**，这样就产生了单地址指令：

单地址指令短，由于一个操作数已经在CPU内，所以执行速度快。

4．零地址指令

零地址指令**无操作数，所以无地址码**。例如，空操作、停机等不需要地址的指令，或者操作数隐含在堆栈中，其地址可由栈指针给出。

### 5.1.2 指令长度

1．指令长度应为**存储器基本字长的整数倍**

如果指令长度任意，就会产生**指令跨存储字边界**存放的情况，即有时一条指令存放在几个存储字中，而有的一个存储字中又存放若干指令。这将**给取指令带来很大不便，影响指令的执行速度**。因此，指令长度应为存储器基本字长的整数倍。

另外，指令长度有**固定长指令**和**可变长指令**两类。例如，DJS-130小型机，指令固定长为16位；又如PDP-1小型机，基本指令长度是16位。IBM 360/370机指令长度有16位、32位和48位。Pentium机指令长度也可变。**由于可变长指令比较灵活，所以采用较多。**

2．**指令字长应尽量短**

**指令字长短，有利于提高程序的效率，即减小所需存储量和加快执行速度。**指令短有利于减少所需存储量是显而易见的，指令短为什么能加快指令执行速度呢？因为**指令短，从存储器中取出指令的时间一般就会少一些，分析指令的时间一般也会短一些。**目前，为了使指令长度缩短，采取了一系列措施。例如，用**指令指针PC（IP）**指出下一条指令的地址，用**累加器A隐含一个操作数**，**地址隐含在某个寄存器**中，以及采用RISC技术等。

当然，不能为了使指令短而影响指令系统的完备性和规整性。指令系统的完备性差，机器的功能将受影响；规整性差，分析指令的时间必然加长。

## 5.2 寻址方式

**指令不仅要规定所执行的操作，还要给出操作数或操作数的地址**。**指令如何指定操作数或操作数地址**称为**寻址方式**。寻址方式也是指令系统的一个重要内容。确定一台计算机指令系统的寻址方式时，有以下4点必须考虑：

① 希望指令内所含地址尽可能短；

② 希望能访问尽可能大的存储空间；

③ 寻址方法尽可能简单；

④ 在不改变指令的情况下，仅改变地址的实际值，从而能方便地访问数组、串、表格等较复杂的数据。

常用的寻址方式有以下10类：

1．立即寻址

**指令直接给出操作数本身**，这种寻址方式又称**立即数**。一般格式：

在按字节编址的机器中，8位和16位立即数指令的格式如图5.1所示。

图 5.1 按字节编址机器中的立即寻址指令

2．直接寻址

**指令直接给出操作数地址**。一般格式：

在按字节编址并采用16位地址的机器中，直接寻址指令的格式如图5.2所示。

3．间接寻址

**指令给出存放操作数地址的存储单元地址**。一般格式：

其中，**@是间接寻址标志**。**单级间接寻址**过程如图5.3所示。计算机中还可以有**多重间址**。指令在存储器中的存放形式与直接寻址类似。

图5.2 按字节编址机器中的直接寻址指令

==图5.3 单级间接寻址过程==

4. **寄存器（直接）寻址**

**操作数在指令指定的CPU的某个寄存器中**。一般格式：

上面给出的两种格式中，前一种是单操作数指令，或者两个操作数中有一个是隐含给出的（如累加器）；后一种为两个操作数均在寄存器中。

寄存器寻址有以下优点：

① **CPU寄存器数量远小于内存单元，所以寄存器号比内存地址短**，因而**寄存器寻址方式指令短**。

② **操作数已在CPU中，不用访存**，因而**指令执行速度快**。

5．寄存器间接寻址

**操作数地址**在**指令指定的CPU的某个寄存器中**。如8086指令“MOV AX，[BX]”将以寄存器BX内容为地址，**读出该内存单元内容**送入AX寄存器。寄存器间接寻址指令也短，因为只要给出一个寄存器号而不必给出操作数地址。指令长度和寄存器寻址指令差不多，但由于**要访问内存**，寄存器间接寻址指令执行的时间比寄存器寻址指令长。

6．寄存器**变址寻址**

指令指定一个**CPU寄存器（称为变址寄存器）**和一个**形式地址**，**操作数地址是两者之和**。一般格式：

例如，8086指令“MOV AL，[SI+1000H]”。其中**SI为变址寄存器**，**1000H为形式地址**（或称**位移量**）。

变址寄存器的内容可以自动“+1”或“-1”，以适合于选取数组数据，如图5.4所示。形式地址指向数组的始址，变址寄存器SI自动“+1”，可以选取数组中所有元素。

另外，某些计算机还**允许变址与间址同时使用**。如果先变址、后间址，称为**前变址**；而先执行间址，后再变址，则称为**后变址**。

图5.4 寄存器变址寻址选择数组数据

7．相对寻址

相对寻址是把程序计数器PC的内容，加上由指令给出的形式地址而形成操作数地址。**相对寻址实际上是规定了操作数和指令的相对位置**，因而得名。采用相对寻址便于编制可浮动程序，这种程序随便放在内存的什么位置，都能正常运行。和变址寻址计算地址的方法相比较可以看出，相对寻址是以程序计数器PC作为变址寄存器的特殊变址寻址的情况。

8．基址寻址

基址寻址由指令中给出的地址（或称位移量）与CPU中的某个基址寄存器相加而得到实际的操作数地址。

这种寻址方式看起来与变址寻址相同，两者都是把某个寄存器内容和指令给出的地址之和作为地址，但实际用法却不同。

变址寻址主要解决程序内部的循环问题，例如“循环取数组中一个元素”等问题。而基址寻址则要求基址寄存器的内容能提供整个主存范围的寻址能力，指令给出的位移地址实际上指出了相对于基址的位移量。基址寻址为逻辑空间到物理空间的地址变换提供了支持，以便实现程序的动态再定位。例如，在多道程序运行环境下，每一个用户程序给定一个基地址，只要改变基址内容，就可以方便地实现程序的再定位。

9．隐含寻址方式

指令没有明显地给出操作数地址，而在操作码中隐含着操作数地址。例如，单地址指令中只给出一个操作数地址，另一个操作数规定为累加器，它的地址就是隐含的。另外，如堆栈指令，其操作数在堆栈内，指令中无需指出具体地址。

10．其他寻址方式

有的计算机指令系统还有更复杂的寻址方式，如**基址变址寻址、位寻址、块寻址、串寻址**等，这里不再赘述。

从以上介绍可以看出，一台计算机的指令系统的寻址方式多种多样，这给程序员编程带来了方便，但是也给计算机控制器的实现带来了一定的复杂性。在具体实现时，有些机器的指令中，专门有寻址方式字节，这样寻址方式一般不受操作码的限制。而有的机器或同一机器的其他指令将寻址方式隐含在操作码中，这样就不是每条指令都能采用该机器指令系统中提供的所有寻址方式。

例如，在Pentium机的指令系统中，传送指令（MOV）的寻址方式比较多，有立即寻址、直接寻址、寄存器间接寻址等，具体寻址方式由寻址方式字节指定；而有的指令（如输入、输出指令）所能用的寻址方式只有直接端口寻址和寄存器间接寻址两种，寻址方式隐含在操作码中。因此，在使用这类机器时，不仅要了解该机总体上有哪些寻址方式，还应了解各指令具体有哪些寻址方式。当然，这对编程来讲是不方便的，但由于机器指令字长和硬件成本的限制，这方面的不足是难免的。

## 5.3 指令类型

指令系统的设计是一台计算机系统结构设计的关键之一。因此，在设计一台计算机的指令系统的功能时，必须考虑以下4个原则。

（1）完备性或完整性。即指令系统的功能应尽量完备，这会给用户的使用带来方便。但是，如果指令系统太复杂，也会给指令的硬件实现增加困难。因此，较复杂的功能可以通过程序实现。

（2）兼容性。特别是在系列机的设计实现时，往往高档机的指令系统要兼容以前的低档机的指令系统，这会给软件资源重复利用带来方便。例如，Pentium机的指令系统，与以前80x86指令系统就具有很好的兼容性。

（3）均匀性。数据处理指令能对多种类型的数据进行处理，包括三种整数（字节、字、双字）和两种浮点数（单精度和双精度浮点数）。

（4）可扩充性。操作码字段要保留一定的空间，以便需要时进行功能扩充。

1．指令按功能分类

（1）算术和逻辑运算指令

==算术和逻辑运算指令有：==

为了方便多字长数据的运算，大多数机器还设置了带进位的加（ADC）和带借位的减（SBB）指令等。在算术运算指令中，有的计算机还专门设置了十进制数的运算指令。

（2）移位指令和循环指令

移位指令和循环指令有算术移位、逻辑移位、环移、半字交换等。

① 算术移位。

算术左移：如图5.5（a）所示。操作数的各位依次向左移一位，最低位补零。大多数机器的算术左移操作还将原操作数的最高位移入C标志位（进位标志）。

算术右移：操作数的各位依次向右移一位，最高位（符号位）不变。原操作数的最低位移入C标志位，如图5.5（b）所示。

② 逻辑移位。

逻辑左移：操作同算术左移，大多数机器一般不再专门设置此指令。

逻辑右移：操作数的各位依次向右移一位，最高位补零。原操作数的最低位移入C标志位，如图5.6所示。

图5．5 算术移位

③ 环移。

（a）小环移。小循环左移，操作如图5．7（a）所示。最高位移入C标志，同时移入最低位。小循环右移，操作如图5．7（b）所示。最低位移入C标志，同时移入最高位。


图5．6 逻辑右移

图5．7 小环移

（b）大环移。大循环左移，操作如图5．8（a）所示，最高位移入C标志，而C标志移入最低位。大循环右移，操作如图5．8（b）所示。最低位移入C标志，而C标志移入最高位。

④ 半字交换。操作如图5．9所示。

图5．8 大环移

图5．9 半字交换

（3）传送类指令

传送类指令有：

● 传送（MOV）（源操作数→目标操作数）
● 取数（LDA）（数由内存→CPU寄存器）
● 存数（STA）（数由CPU寄存器→内存）
● 交换（XCHG）（源操作数和目标操作数交换）

（4）串指令

串指令是指对字符串进行操作的指令。如串传送、比较、检索、传送转换等指令。

（5）顺序控制指令

顺序控制指令用来控制程序执行的顺序。有条件转移、无条件转移（JMP）、跳步（SKIP）、转子（CALL）、返主（RET）等指令。

转移指令的操作是将转移地址送到PC中，转移地址可用直接寻址方式给出（又称绝对转移），或由相对寻址方式给出（又称相对转移）。有的机器还可以用寄存器寻址方式或寄存器间接寻址方式给出转移地址。

无条件转移指令无论上条指令执行的结果是什么都要执行转移操作，而条件转移指令仅仅在特定条件满足时才执行转移操作。转移条件一般是某个标志位置位或复位，或者由两个或两个以上的标志位组合而成。如进位标志C=1转，或C=0转，或C=1且Z（零标志位）=1转等。跳步是转移的一种特例，它使PC再增加一个定值，这个定值一般是指令字所占用的存储字个数。应该注意的是，取指令时PC已增量过了，因此跳步指令实际上就是跳过下条指令。

转子指令和转移指令的根本区别在于，执行转子指令时必须记住下条指令的地址（称为断点或返回地址）。这类指令用于子程序的调用，当子程序执行完毕时，仍返回到主程序的断点处继续执行。而转移指令则不保存断点。返主指令（又叫返回指令）的操作是在子程序执行完毕时，将事先保存的主程序的断点（由转子指令保存）送到PC中，这样程序将回到转子指令的下条指令继续执行。

为了便于实现保存断点和返回操作，特别是当子程序又调用子程序，即所谓子程序嵌套调用时，能保证顺利返回，需要一种按“后进先出”方式存取的数据结构，下一节讲的堆栈数据结构就是适合此类操作的数据结构。

（6）CPU控制指令

CPU控制指令有停机、开中断、关中断以及改变执行特权、进入特殊处理程序等指令。大多数机器将这类指令划为“特权”指令，只能用于操作系统等系统软件，用户程序一般不能使用。这样才能防止因用户使用不当而对系统的运行造成危害。

（7）输入、输出指令

输入、输出指令用于完成CPU与外部设备交换数据或传送控制命令及状态信息。大多数机器都设置了这类指令，但是它们的寻址方式一般较少，常见的只有直接寻址和寄存器间接寻址等。有的机器不设置这类指令，用访内指令完成其操作（当然，这样一来需要给各外设安排特殊的存储器地址）。

2．指令按操作数个数分类

（1）双操作数指令。如ADD，SUB，AND等。
（2）单操作数指令。如NEG，NOT，INC，DEC等。
（3）无操作数指令。如空操作（NOP）、停机、开中断、关中断等。

3．指令按操作数寻址方式分类

（1）RR型。两个操作数都在CPU的寄存器中。
（2）RS型。两个操作数中一个在CPU寄存器中，另一个在内存中。
（3）SS型。两个操作数都在内存中。

### 5.4 堆栈和堆栈存取方式

堆栈是一种特定的数据结构，其特点是后进先出（LIFO）或先进后出（FILO）。

堆栈的存取方式决定了它一端存取的特点，往堆栈里存数叫入（进）栈或压栈，从堆栈里取数叫出栈或弹出。

1．用移位寄存器实现堆栈

用移位寄存器实现堆栈是一种硬件实现方法，它由若干移位寄存器构成，又叫栈顶固定方式堆栈，如图5.10所示。

2．内存中开辟堆栈区

可在内存中开辟堆栈区，这种堆栈，存储器单元固定，而栈顶位置动态变化。在CPU中专门设置了堆栈指针SP，指示栈顶位置，存取只能在栈顶进行。

（1）自底向上生成堆栈。这种堆栈建栈时，堆栈指针SP指向栈底下面一个单元（栈底是堆栈中地址最大的单元），每次入栈时，SP先减1，再把入栈数据存入SP指向的单元。出栈时，先读出SP所指单元的地址，然后SP加1。

图5.10 栈顶固定方式堆栈及其存取

入栈操作（PUSH）步骤：① SP-1→SP；② 存入数据→(SP)。
出栈操作（POP）步骤：① (SP)内容读出；② SP+1→SP。

因为这种堆栈在存入数据后，指针向减小的方向变化，所以称为自底向上生成堆栈，它的建栈、入栈和出栈操作如图5.11所示。注意存取数据操作和堆栈指针改变操作的次序。



图5.11 自底向上生成堆栈

（2）自顶向下生成堆栈。这种堆栈建栈时，堆栈指针SP指向栈底上面一个单元（栈底是堆栈中地址最小的单元），每次入栈时，SP先加1，再把入栈数据存入SP指向的单元。出栈时，先读出SP所指单元的内容，然后SP减1。

入栈操作（PUSH）步骤：① SP+1→SP；② 存入数据→(SP)。

出栈操作（POP）步骤：① (SP)内容读出；② SP-1→SP。

这种堆栈在存入数据后，指针向增大的方向变化，所以叫做自顶向下生成堆栈。它的建栈、入栈和出栈操作与自底向上生成堆栈类似，仅指针变化方向不同。



