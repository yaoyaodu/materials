# C++

## C++ 环境设置

### 本地环境设置

如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，**文本编辑器**和 **C++ 编译器**。

### 文本编辑器

这将用于输入您的程序。文本编辑器包括 **Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi**。

文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。

**通过编辑器创建的文件通常称为源文件，源文件包含程序源代码**。C++ 程序的源文件通常使用**扩展名 .cpp、.cp 或 .c**。

在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。

### C++ 编译器

写在源文件中的源代码是人类可读的源。**它需要"编译"，转为机器语言，这样 CPU 可以按给定指令执行程序**。

**C++ 编译器**用于把**源代码**编译成最终的**可执行程序**。

大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。

最常用的**免费可用的编译器是 GNU 的 C/C++ 编译器**，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。

以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 **GNU 的 gcc 编译器适合于 C 和 C++ 编程语言**。



## C++ 基本语法

C++ 程序可以定义为**对象的集合**，这些**对象**通过**调用彼此的方法**进行**交互**。现在让我们简要地看一下什么是**类、对象、方法、即时变量**。

* **类 -** 类可以定义为描述对象行为/状态的**模板/蓝图**。

- **对象 -** **对象具有状态和行为**。**对象是类的实例**。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。
  - **方法 -** 从基本上说，**一个方法表示一种行为。一个类可以包含多个方法。**可以在方法中写入逻辑、操作数据以及执行所有的动作。
  - **即时变量 -** 每个对象都有其独特的即时变量。**对象的状态**是由这些**即时变量的值**创建的。

### C++ 程序结构

让我们看一段简单的代码，可以输出单词 *Hello World*。

#### 实例

```
#include <iostream> 
using namespace std;  

// main() 是程序开始执行的地方  

int main() 
{   
	cout << "Hello World"; // 输出 Hello World   
	return 0; 
}
```

- C++ 语言定义了一些**头文件**，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 **<iostream>**。
- 下一行 **using namespace std;** 告诉编译器**使用 std 命名空间**。命名空间是 C++ 中一个相对新的概念。
- 下一行 **// main() 是程序开始执行的地方** 是一个单行注释。单行注释以 // 开头，在行末结束。
- 下一行 **int main()** 是**主函数**，程序从这里开始执行。
- 下一行 **cout << "Hello World";** 会在屏幕上显示消息 "Hello World"。
- 下一行 **return 0;** 终止 main( )函数，并向调用进程返回值 0。

### 编译 & 执行 C++ 程序

接下来让我们看看如何**把源代码保存在一个文件中**，以及如何**编译并运行它**。下面是简单的步骤：

1. 打开一个文本编辑器，添加上述代码。
2. 保存文件为 hello.cpp。
3. 打开命令提示符，进入到保存文件所在的目录。
4. **键入 'g++ hello.cpp '，输入回车，编译代码**。如果代码中没有错误，命令提示符会跳到下一行，并**生成 a.out 可执行文件**。
5. **键入 ' a.out' 来运行程序**。
6. 屏幕上显示 ' Hello World '。

```
$ g++ hello.cpp
$ ./a.out
Hello World
```

请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。

您也可以使用 **makefile** 来编译 C/C++ 程序。

### C++ 中的分号 & 语句块

在 C++ 中，**分号是语句结束符**。也就是说，**每个语句必须以分号结束。它表明一个逻辑实体的结束。**

例如，下面是三个不同的**语句**：

x = y; 

y = y+1; 

add(x, y);

**语句块**是一组**使用大括号括起来的按逻辑连接的语句**。例如：

{   

​		cout << "Hello World"; // 输出 Hello World   

​		return 0; 

}

C++ 不以行末作为结束符的标识，因此，您**可以在一行上放置多个语句**。例如：

x = y; 

y = y+1; 

add(x, y);

等同于

x = y; y = y+1; add(x, y);

### C++ 标识符

C++ 标识符是用来标识**变量、函数、类、模块**，或任何其他**用户自定义项目的名称**。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C++ 标识符内**不允许出现标点字符，比如 @、& 和 %**。C++ 是区分大小写的编程语言。因此，在 C++ 中，**Manpower** 和 **manpower** 是两个不同的标识符。

下面列出几个有效的标识符：

```
mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
```

### C++ 关键字

下表列出了 C++ 中的**保留字**。这些保留字不能作为常量名、变量名或其他标识符名称。

| asm          | else          | new              | this     |
| ------------ | ------------- | ---------------- | -------- |
| auto         | enum          | operator         | throw    |
| bool         | explicit      | private          | true     |
| break        | export        | protected        | try      |
| case         | extern        | public           | typedef  |
| catch        | false         | register         | typeid   |
| char         | float         | reinterpret_cast | typename |
| class        | for           | return           | union    |
| const        | friend        | short            | unsigned |
| const_cast   | goto          | signed           | using    |
| continue     | if            | sizeof           | virtual  |
| default      | inline        | static           | void     |
| delete       | int           | static_cast      | volatile |
| do           | long          | struct           | wchar_t  |
| double       | mutable       | switch           | while    |
| dynamic_cast | **namespace** | template         |          |

### 三字符组

三字符组就是**用于表示另一个字符的三个字符序列**，又称为三字符序列。三字符序列总是**以两个问号开头**。

三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。

**三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。**

下面列出了最常用的三字符序列：

| 三字符组 | 替换 |
| :------- | :--- |
| ??=      | #    |
| ??/      | \    |
| ??'      | ^    |
| ??(      | [    |
| ??)      | ]    |
| ??!      | \|   |
| ??<      | {    |
| ??>      | }    |
| ??-      | ~    |

如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接："...?""?..."或者转义序列："...?\?..."。

从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs

g++仍默认支持三字符组，但会给出编译警告。

### C++ 中的空格

只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。

在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：

```
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

```
fruit = apples + oranges;   // 获取水果的总数
```

fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。



## C++ 注释

程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。

C++ 支持**单行注释和多行注释**。注释中的所有字符会被 C++ 编译器忽略。

C++ 注释一般有两种：

- ``//``  一般用于单行注释。注释以 **//** 开始，直到行末为止。也可以放在语句后面。
- ``/*... */ `` 一般用于多行注释。C++ 注释以 **/\*** 开始，以 ***/** 终止。

在 **/\*** 和 ***/** 注释内部，**//** 字符没有特殊的含义。在 **//** 注释内，**/\*** 和 ***/** 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。



## C++ 数据类型

使用编程语言进行编程时，需要**用到各种变量来存储各种信息**。**变量保留的是它所存储的值的内存位置**。这意味着，**当您创建一个变量时，就会在内存中保留一些空间**。

您可能需要存储各种**数据类型**（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的**信息，**操作系统会根据**变量的数据类型**，来**分配内存**和**决定在保留内存中存储什么**。

### 基本的内置类型

C++ 为程序员提供了种类丰富的**内置数据类型**和**用户自定义的数据类型**。下表列出了**七种基本的 C++ 数据类型**：

| 类型     | 关键字  |
| :------- | :------ |
| 布尔型   | bool    |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |



一些基本类型可以使用一个或多个**类型修饰符**进行修饰：

- signed
- unsigned
- short
- long

下表显示了**各种变量类型在内存中存储值时需要占用的内存**，以及该类型的变量**所能存储的最大值和最小值**。

**注意：**不同系统会有所差异，一字节为 8 位。

**注意：**默认情况下，int、short、long都是带符号的，即 signed。

**注意：**long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。



| 类型               | 位            | 范围                                                         |
| :----------------- | :------------ | :----------------------------------------------------------- |
| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |
| unsigned char      | 1 个字节      | 0 到 255                                                     |
| signed char        | 1 个字节      | -128 到 127                                                  |
| int                | 4 个字节      | -2147483648 到 2147483647                                    |
| unsigned int       | 4 个字节      | 0 到 4294967295                                              |
| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |
| short int          | 2 个字节      | -32768 到 32767                                              |
| unsigned short int | 2 个字节      | 0 到 65,535                                                  |
| signed short int   | 2 个字节      | -32768 到 32767                                              |
| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |
| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |
| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |
| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |
| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |



### typedef 声明

您可以使用 **typedef** 为一个已有的类型**取一个新的名字**。下面是使用 typedef **定义一个新类型**的语法：

```
typedef type newname; 
```

例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：

```
typedef int feet;
```

现在，下面的声明是完全合法的，**它创建了一个整型变量 distance：**

```
feet distance;
```

### 枚举类型（派生数据类型）

枚举类型(enumeration)是C++中的一种**派生数据类型**，它是**由用户定义的若干枚举常量的集合**。

如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。

所谓"枚举"是指**将变量的值一一列举出来，变量的值只能在列举出来的值的范围内**。

创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：

```
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
    
```

如果枚举没有初始化, 即省掉"=整型常数"时, 则从第一个标识符开始。

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。

```
enum color { red, green, blue } c;
c = blue;
```

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，**green** 的值为 5。

```
enum color { red, green=5, blue };
```

在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。

## C++ 变量类型

变量其实只不过是**程序可操作的存储区**的名称。C++ 中**每个变量都有指定的类型，类型决定了变量存储的大小和布局**，该范围内的值都可以存储在内存中，运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。

基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解：

| 类型    | 描述                                                         |
| :------ | :----------------------------------------------------------- |
| bool    | 存储值 true 或 false。                                       |
| char    | 通常是一个字符（八位）。这是一个整数类型。                   |
| int     | 对机器而言，整数的最自然的大小。                             |
| float   | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| double  | 双精度浮点值。双精度是1位符号，11位指数，52位小数。![img](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png) |
| void    | 表示类型的缺失。                                             |
| wchar_t | 宽字符类型。                                                 |

C++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等。

下面我们将讲解如何**定义、声明和使用**各种类型的变量。

### C++ 中的变量定义

变量定义就是**告诉编译器在何处创建变量的存储**，以及**如何创建变量的存储**。

![img](https://www.runoob.com/wp-content/uploads/2015/01/cpp-variable-types-2020-12-14.png)

变量定义**指定一个数据类型**，并包含了该类型的**一个或多个变量的列表**，如下所示：

```
type variable_list;
```

在这里，**type** 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，**variable_list** 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明：

int    i, j, k; char   c, ch; float  f, salary; double d;

行 **int i, j, k;** 声明并定义了变量 i、j 和 k，这指示编译器**创建类型为 int 的名为 i、j、k 的变量**。



变量可以**在声明的时候被初始化（指定一个初始值）**。**初始化器由一个等号，后跟一个常量表达式组成**，如下所示：

type variable_name = value;

下面列举几个实例：

extern int d = 3, f = 5;    // d 和 f 的声明  

int d = 3, f = 5;           // 定义并初始化 d 和 f 

byte z = 22;                // 定义并初始化 z 

char x = 'x';               // 变量 x 的值为 'x'

不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。

### C++ 中的变量声明（extern）

变量声明**向编译器保证变量以给定的类型和名称存在**，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明**只在编译时有它的意义**，在程序连接时编译器需要实际的变量声明。

当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 **extern** 关键字**在任何地方声明一个变量**。虽然您可以在 C++ 程序中多次声明一个变量，但**变量只能在某个文件、函数或代码块中被定义一次**。

#### 实例

尝试下面的实例，其中，**变量在头部就已经被声明**，但它们是在主函数内被定义和初始化的：

```
#include <iostream> 
using namespace std;  

// 变量声明 

extern int a, b; 
extern int c; 
extern float f;   

int main () 
{  
	// 变量定义  
    int a, b;  
    int c;  
    float f;   

    // 实际初始化  
    a = 10;  
    b = 20;  
    c = a + b;   

    cout << c << endl ;   

    f = 70.0/3.0;  
    cout << f << endl ;   

    return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
30
23.3333
```

同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如：

```c++
// 函数声明 
int func();  

int main() 
{    
    // 函数调用    
    int i = func(); 
}  

// 函数定义 
int func() 
{    
    return 0; 
}
```



## C++ 中的左值（Lvalues）和右值（Rvalues）

C++ 中有两种类型的表达式：

- **左值（lvalue）**：**指向内存位置的表达式**被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）**：术语右值（rvalue）指的是**存储在内存中某些地址的数值**。右值是**不能对其进行赋值的表达式**，也就是说，**右值可以出现在赋值号的右边**，但不能出现在赋值号的左边。

变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

```
int g = 20;
```

但是下面这个就不是一个有效的语句，会生成编译时错误：

```
10 = 20;
```

## C++ 变量作用域

作用域是**程序的一个区域**，一般来说有三个地方可以定义变量：

- 局部变量：在函数或一个代码块**内部**声明的变量
- 形式参数：在**函数参数的定义中**声明的变量
- 全局变量：**在所有函数外部**声明的变量

### 局部变量

在函数或一个代码块内部声明的变量，称为局部变量。

它们只**能被函数内部或者代码块内部的语句使用**。

### 全局变量

在所有函数外部定义的变量（通常是**在程序的头部**），称为全局变量。

全局变量的值**在程序的整个生命周期内都是有效的**。

全局变量**可以被任何函数访问**。也就是说，全局变量一旦声明，在整个程序中都是可用的。

### 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。

定义全局变量时，系统会自动初始化为下列值：

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。

## C++ 常量

常量是**固定值**，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

常量可以是**任何的基本数据类型**，可分为整型数字、浮点数字、字符、字符串和布尔值。

常量就像是**常规的变量**，只不过常量的值在定义后不能进行修改。

### 定义常量

在 C++ 中，有两种简单的定义常量的方式：

- 使用 **#define** 预处理器。
- 使用 **const** 关键字。

#### #define 预处理器

下面是使用 #define 预处理器定义常量的形式：

```
#define identifier value
```

具体请看下面的实例：

```
#include <iostream> 
using namespace std;  

#define LENGTH 10    
#define WIDTH  5 
#define NEWLINE '\n'  

int main() 
{    
    int area;        

    area = LENGTH * WIDTH;   
    cout << area;   
    cout << NEWLINE;   
    return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
50
```

#### const 关键字

您可以使用 **const** 前缀声明指定类型的常量，如下所示：

```
const type variable = value;
```

具体请看下面的实例：

```
#include <iostream> 
using namespace std;  


int main() 
{   
    const int  LENGTH = 10;   
    const int  WIDTH  = 5;   
    const char NEWLINE = '\n';   
    int area;        

    area = LENGTH * WIDTH;   
    cout << area;   
    cout << NEWLINE;   
    return 0; 
}
```



当上面的代码被编译和执行时，它会产生下列结果：

```
50
```

请注意，把常量定义为大写字母形式，是一个很好的编程实践。



## C++ 数组

C++ 支持**数组**数据结构，它可以存储一个**固定大小的相同类型元素**的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。

**所有的数组都是由连续的内存位置组成**。最低的地址对应第一个元素，最高的地址对应最后一个元素。

### 声明数组

在 C++ 中要声明一个数组，需要指定**元素的类型和元素的数量**，如下所示：

```
type arrayName [ arraySize ];
```

这叫做一维数组。**arraySize** 必须是一个大于零的整数常量，**type** 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 **balance**，声明语句如下：

```
double balance[10];
```

*balance* 是一个可用的数组，可以容纳 10 个类型为 double 的数字。

### 初始化数组

在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

```
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

```
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：

```
balance[4] = 50.0;
```

上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：

![数组表示](https://www.runoob.com/wp-content/uploads/2014/08/array_presentation.jpg)



### 访问数组元素

数组元素可以通过**数组名称加索引**进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```
double salary = balance[9];
```

上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：

```
#include <iostream> 
using namespace std;  

#include <iomanip> 
using std::setw;  

int main () 
{   
	int n[ 10 ]; // n 是一个包含 10 个整数的数组    
	
	// 初始化数组元素             
	for ( int i = 0; i < 10; i++ )   
	{      
		n[ i ] = i + 100; // 设置元素 i 为 i + 100   
     }   
     cout << "Element" << setw( 13 ) << "Value" << endl;    
     
     // 输出数组中每个元素的值                        
     for ( int j = 0; j < 10; j++ )   
     {      
     	cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;   
     }    
     
     return 0; 
}
```

上面的程序使用了 **[setw() 函数](https://www.runoob.com/w3cnote/cpp-func-setw.html)** 来格式化输出。当上面的代码被编译和执行时，它会产生下列结果：

```
Element        Value
      0          100
      1          101
      2          102
      3          103
      4          104
      5          105
      6          106
      7          107
      8          108
      9          109
```

### C++ 中数组详解

在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念：

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [多维数组](https://www.runoob.com/cplusplus/cpp-multi-dimensional-arrays.html) | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |
| [指向数组的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-an-array.html) | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |
| [传递数组给函数](https://www.runoob.com/cplusplus/cpp-passing-arrays-to-functions.html) | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |
| [从函数返回数组](https://www.runoob.com/cplusplus/cpp-return-arrays-from-function.html) | C++ 允许从函数返回数组。                                     |

## C++ 指针（变量，其值为另一个变量的地址，即内存位置的直接地址）

通过指针，可以**简化一些 C++ 编程任务的执行**，还有一些任务，如**动态内存分配，没有指针是无法执行的**。

**每一个变量都有一个内存位置**，每一个内存位置都定义了可使用**连字号（&）运算符**访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址：

```
#include <iostream>
 
using namespace std;
 
int main ()
{
   int  var1;
   char var2[10];
 
   cout << "var1 变量的地址： ";
   cout << &var1 << endl;
 
   cout << "var2 变量的地址： ";
   cout << &var2 << endl;
 
   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
var1 变量的地址： 0xbfebd5c0
var2 变量的地址： 0xbfebd5b6
```

### 什么是指针？

**指针**是一个**变量**，其值为**另一个变量的地址**，即，**内存位置的直接地址**。

就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

```
type *var-name;
```

在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，**在这个语句中，星号是用来指定一个变量是指针**。以下是有效的指针声明：

```
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */
```

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

### C++ 中使用指针

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。

### C++ 指针详解

在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念：

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [C++ Null 指针](https://www.runoob.com/cplusplus/cpp-null-pointers.html) | C++ 支持空指针。NULL 指针是**一个定义在标准库中的值为零的常量**。 |
| [C++ 指针的算术运算](https://www.runoob.com/cplusplus/cpp-pointer-arithmetic.html) | 可以对指针进行四种算术运算：++、--、+、-                     |
| [C++ 指针 vs 数组](https://www.runoob.com/cplusplus/cpp-pointers-vs-arrays.html) | 指针和数组之间有着密切的关系。                               |
| [C++ 指针数组](https://www.runoob.com/cplusplus/cpp-array-of-pointers.html) | 可以定义用来存储指针的数组。                                 |
| [C++ 指向指针的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-pointer.html) | C++ 允许指向指针的指针。                                     |
| [C++ 传递指针给函数](https://www.runoob.com/cplusplus/cpp-passing-pointers-to-functions.html) | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |
| [C++ 从函数返回指针](https://www.runoob.com/cplusplus/cpp-return-pointer-from-functions.html) | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |

## C++ 引用

引用变量是一个别名，也就是说，**它是某个已存在变量的另一个名字**。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

### C++ 引用 vs 指针

引用很容易与指针混淆，它们之间有三个主要的不同：

- 不存在空引用。**引用必须连接到一块合法的内存**。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

## C++ 函数（方法、子例程、程序）

函数是**一组一起执行一个任务的语句**。每个 C++ 程序都至少有一个函数，即主函数 **main()** ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数**声明**告诉**编译器**函数的名称、返回类型和参数。函数**定义**提供了函数的实际主体。

C++ 标准库提供了大量的程序可以调用的**内置函数**。例如，函数 **strcat()** 用来连接两个字符串，函数 **memcpy()** 用来复制内存到另一个位置。

函数还有很多叫法，比如**方法、子例程或程序**，等等。



## 定义函数

C++ 中的函数定义的一般形式如下：

return_type function_name( parameter list ) {   body of the function }

在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。



## C++ 数据结构

C/C++ **数组**允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种**用户自定义的可用的数据类型**，它允许您**存储不同类型的数据项**。

**结构用于表示一条记录**，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：

- Title ：标题
- Author ：作者
- Subject ：类目
- Book ID ：书的 ID

### 定义结构（**struct** 语句）

为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```
struct type_name { 
member_type1 member_name1; 
member_type2 member_name2; 
member_type3 member_name3; 
. 
. 
} object_names;
```

**type_name** 是**结构体类型的名称**，**member_type1 member_name1** 是标准的变量定义，比如 **int i;** 或者 **float f;** 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 **Books**，变量为 **book**：

```
struct Books 
{   
	char  title[50];   
	char  author[50];   
	char  subject[100];   
	int   book_id; 
} book;
```

### 访问结构成员

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。

## C++多线程

多线程是**多任务处理**的一种特殊形式，多任务处理**允许让电脑同时运行两个或两个以上的程序**。一般情况下，两种类型的多任务处理：**基于进程和基于线程**。

- 基于进程的多任务处理是程序的并发执行。
- 基于线程的多任务处理是同一程序的片段的并发执行。

多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。

本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。

