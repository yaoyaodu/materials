# 算力、数据类型、分辨率、FPS

## 算力（运算能力）

**处理器运算能力单位**。计算机的运算速度，通常用**每秒运算次数**度量。

### 每秒钟能处理的次数

- **TOPS** (Tera Operations Per Second): 1 TOPS代表**处理器每秒钟可进行一万亿次**（**10^12**）操作。
- **GOPS**（Giga Operations Per Second）：1 GOPS代表处理器每秒钟可进行十亿次（**10^9**）操作。
- **MOPS**（Million Operation Per Second）：1 MOPS代表处理器每秒钟可进行一百万次（**10^6**）操作。

TOPS同GOPS与MOPS可以换算，都代表**每秒钟能处理的次数**，单位不同而已。

在某些情况下，还使用 **TOPS/W** 来作为评价处理器运算能力的一个性能指标。

**TOPS/W** ：用于度量**在1W功耗的情况下，处理器能进行多少万亿次操作**。



### 每秒所执行的浮点运算次数

每秒所执行的浮点运算次数：**FL**OPS (Floating-point operations per second) 

浮点运算实际上包括了**所有涉及小数的运算**，在某类应用软件中常常出现，**比整数运算更费时间**。
现今大部分的处理器中都有**浮点运算器**。

FPU (Floating Processing Unit) （浮点计算单元）：**通用处理器中的浮点运算模块**。

因此每秒浮点运算次数所量测的实际上就是**浮点运算器的执行速度**。
而最常用来测量每秒浮点运算次数的基准程序（benchmark）之一，就是Linpack。

- 一个MFLOPS（megaFLOPS）等于每秒一百万（=10^6）次的浮点运算
- 一个GFLOPS（gigaFLOPS）等于每秒十亿（=10^9）次的浮点运算
- 一个TFLOPS（teraFLOPS）等于每秒一万亿（=10^12）次的浮点运算
- 一个PFLOPS（petaFLOPS）等于每秒一千万亿（=10^15）次的浮点运算
- 一个EFLOPS（exaFLOPS）等于每秒一百亿亿（=10^18）次的浮点运算



## 整数数据类型

Int8，Int16，Int32，Int64，后面的数字就代表**这个数据类型占据的空间**。

Int64：有符号 64 位**整数数据类型**。

- Int8, 等于**Byte**, 占1个字节。

- **Int16, 等于short**, 占2个字节。 -32768 32767
- **Int32, 等于int,** 占4个字节。 -2147483648 2147483647
- **Int64, 等于long,** 占8个字节。 -9223372036854775808 9223372036854775807

这样, 看起来比short,int,long更加直观些! 另外, 还有一个Byte, 它等于byte, 0 - 255.



## 浮点数格式

### FP64（HPC）、FP16（图形渲染）

浮点数精度

- FP64：**HPC**高精度需求
- FP16：**图形渲染**、**深度学习**

当GPGPU通用计算被普及的时候，高**性能运算(HPC)和深度学习(DL)对于浮点数精度有不同的需求**。

- 在HPC程序中，一般我们要求的**64位或者更高的精度**。
- 而在**DL**领域，我们在一直尝试着通过**降低精度来提供系统的吞吐量**，**从FP32, FP16到INT8，INT4**。

**FP64**是满足科学计算中需要的**更高精度的需求**，而**FP16**的结构，更多是服务了**图形渲染**的需求。

说明：

**吞吐量（throughput）**：**单位时间内成功地传送数据的数量**(以比特、字节、分组等测量)。



### TF32（加速推理）

2020年NVIDIA发布的Ampere架构GPU，带来了新的第三代TensorCore，支持专为**加速Inference**引入的TF32格式。用户升级TensorRT到7.1以后版本，**可以直接在TF32模型上面使用TF32的优化**，**带来了除了FP16, INT8以外的一个新的选择。**

**FP16**这个结构更多的是来自**图形渲染**的需求，**在DL领域我们认为FP16所表达的数据宽度不一定符合所有的模型**。所以最初在TPU上**Google提出了BFloat16**，将宽度改成和FP32一样，但是降低精度（mantissa由10位降低到7位，即精度降低到1/8）。

而**Ampere**提出的**TF32**更多是一个**Inference的场景**，在**Inference**中我们已经有一个**FP32**的模型，在这个假设前提下，我们可以不受16bits的限制，所以我们可以通过舍弃FP32在mantissa尾部的13bits，**达到使用FP32一样的宽度，FP16一样的精度的目的，使用TensorCore来加速TF32的运算**。

### BF16（深度学习）

BF16是一种相对较新的**浮点数格式**，又叫BFloat16或**Brain Float16**。

**深度学习中一般不需要FP64，FP32这种高精度的浮点格式**。虽然这两种浮点格式数据**精度高**，但也增加了**存储成本和处理过程中的时间成本**。

如果有一种数据格式能解决FP64，FP32这两种数据格式的这两个缺点，同时**又能满足一定的精度要求**，那无疑会大大提高**深度学习模型**的**推理速度和部署灵活性**。

这种数据格式就是BF16，使用BF16算法的**预测精度与FP32相似**，但不如FP32精确（**谷歌**曾说过，这是因为神经网络对指数的大小比尾数敏感得多）。对于大多数应用程序，尤其是**计算机视觉和语音**方面，这种折衷是可以接受的。

BF16的指数位比FP16多，跟FP32一样，不过小数位比较少。这样设计说明了设计者希望在16bits的空间中，通过**降低精度（比FP16的精度还低）的方式，来获得更大的数值空间（Dynamic Range）**。



## 分辨率

SD (Standard Definition) video specifies the video and audio codecs and file format that allows users to watch video on several electronic devices built to SD standards. SD video supports different formats, including VC-1, H.264, MPEG-4 and MPEG-2. Standard definition has always been a 4:3 aspect ratio with a **resolution** of 640 × 480 pixels.

- 标清是480p，720p是高清，1080p是全高清(超清)

- 标清 SD (Standard Definition)：480p、576p

- 高清 HD (High Definition)：720p

- 全高清 FHD (Full High Definition)：1080p

- 超高清 UHD (Ultra High Definition) (或 4k UHD)：4k

- 8k超高清 FUHD (Full Ultra High Definition) (或 8k UHD)：8k



## 每秒传输帧数 FPS

FPS（Frames Per Second）

FPS是图像领域中的定义，是指**画面每秒传输帧数**，通俗来讲就是指**动画或视频的画面数**。FPS是测量用于保存、显示动态视频的信息数量。

**每秒钟帧数越多，所显示的动作就会越流畅**。通常，要避免动作不流畅的**最低是30**。某些计算机视频格式，每秒只能提供15帧。

FPS也可以理解为我们常说的**“刷新率（单位为Hz）**”，例如我们常在游戏里说的“**FPS值**”。我们在装机选购显卡和显示器的时候，都会注意到“刷新率”。

一般我们设置缺省刷新率都在75Hz（即75帧/秒）以上。例如：75Hz的刷新率刷也就是指屏幕一秒内只扫描75次，即75帧/秒。而当刷新率太低时我们肉眼都能感觉到屏幕的闪烁，不连贯，对图像显示效果和视觉感观产生不好的影响。

**电影以每秒24张画面的速度播放，也就是一秒钟内在屏幕上连续投射出24张静止画面**。电影是24fps，通常简称为24帧。



## 制作工艺（Process）

制作工艺，指的是晶体管与晶体管之间的距离，单位是纳米。制作工艺越小说明集
成度越高，功耗越小，性能越好。



## 像素填充速率、纹理填充率

像素填充率和纹理填充率**反映的是 GPU 的性能**，而**显存带宽**则体现了**显存的性能**。

- 像素填充速率，指 GPU **一秒钟内能处理多少个像素**，单位是 GPixel/S（每秒十亿像素），或 MPixel/S（每秒百万像素）。像素填充速率是较好**衡量 GPU 图像显示功能的整体指标**，说明了显卡能以多快的速度对图像进行光栅化处理。**显卡的硬件指标对其速度具有直接影响**。
- 纹理填充率，指对多边形图像进行纹理贴图、实现 3D 效果的速度，和像素填充率类似，单位是 GTexels/S 或 MTexels/S。游戏采用了多纹理贴图的方式，使画面具有更好的光影效果。



## 零拷贝

零拷贝是一种**高效的数据传输机制**，在追求**低延迟的传输场景**中十分常用。

零拷贝指的是，从一个存储区域到另一个存储区域的copy任务**没有CPU参与**。

零拷贝通常用于**网络文件传输，以减少CPU消耗和内存带宽占用**，减少用户空间（用户可以操作的内存缓存区域）与CPU内核空间（CPU可以操作的内存缓存区域及寄存器）的拷贝过程，减少用户上下文（用户状态环境）与CPU内核上下文（CPU内核状态环境）间的切换，提高系统效率。



## 异构计算（异质运算）

在计算机系统里采用不**同体系结构的处理单元（如通用CPU和GPU等加速处理器）**来实现**不同的计算功能**或**分担不同的计算任务**而形成的**协同计算模式**。

**在异构计算系统上进行的并行计算**通常称为异构计算。人们已从不同角度对异构计算进行定义，综合起来我们给出如下定义：

异构计算是**一种特殊形式的并行和分布式计算**，它或是用能同时支持SIMD方式和MIMD方式的单个独立计算机，或是用由高速网络互连的一组独立计算机来完成计算任务。它能**协调地使用性能、结构各异地机器**以满足不同的计算需求，并使代码（或代码段）能以获取最大总体性能方式来执行。







