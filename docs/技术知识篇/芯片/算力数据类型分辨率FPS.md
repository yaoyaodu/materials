# 算力、数据类型、分辨率、FPS

## 算力（运算能力）

**处理器运算能力单位**。计算机的运算速度，通常用**每秒运算次数**度量。

### 每秒钟能处理的次数

- **TOPS** (Tera Operations Per Second): 1 TOPS代表**处理器每秒钟可进行一万亿次**（**10^12**）操作。
- **GOPS**（Giga Operations Per Second）：1 GOPS代表处理器每秒钟可进行十亿次（**10^9**）操作。
- **MOPS**（Million Operation Per Second）：1 MOPS代表处理器每秒钟可进行一百万次（**10^6**）操作。

TOPS同GOPS与MOPS可以换算，都代表**每秒钟能处理的次数**，单位不同而已。

在某些情况下，还使用 **TOPS/W** 来作为评价处理器运算能力的一个性能指标。

**TOPS/W** ：用于度量**在1W功耗的情况下，处理器能进行多少万亿次操作**。



### 每秒所执行的浮点运算次数

每秒所执行的浮点运算次数：**FL**OPS (Floating-point operations per second) 

浮点运算实际上包括了**所有涉及小数的运算**，在某类应用软件中常常出现，**比整数运算更费时间**。
现今大部分的处理器中都有**浮点运算器**。

FPU (Floating Processing Unit) （浮点计算单元）：**通用处理器中的浮点运算模块**。

因此每秒浮点运算次数所量测的实际上就是**浮点运算器的执行速度**。
而最常用来测量每秒浮点运算次数的基准程序（benchmark）之一，就是Linpack。

- 一个MFLOPS（megaFLOPS）等于每秒一百万（=10^6）次的浮点运算
- 一个GFLOPS（gigaFLOPS）等于每秒十亿（=10^9）次的浮点运算
- 一个TFLOPS（teraFLOPS）等于每秒一万亿（=10^12）次的浮点运算
- 一个PFLOPS（petaFLOPS）等于每秒一千万亿（=10^15）次的浮点运算
- 一个EFLOPS（exaFLOPS）等于每秒一百亿亿（=10^18）次的浮点运算



## IOPS：每秒进行读写操作的次数

IOPS（Input/Output Operations Per Second）是一个用于计算机存储设备（如硬盘（HDD）、固态硬盘（SSD）或存储区域网络（SAN））性能测试的量测方式，可以视为是每秒的读写次数。和其他性能测试一样，存储设备制造商提出的IOPS不保证就是实际应用下的性能。

作用：衡量随机访问的性能



## 整数数据类型

Int8，Int16，Int32，Int64，后面的数字就代表**这个数据类型占据的空间**。

Int64：有符号 64 位**整数数据类型**。

- Int8, 等于**Byte**, 占1个字节。

- **Int16, 等于short**, 占2个字节。 -32768 32767
- **Int32, 等于int,** 占4个字节。 -2147483648 2147483647
- **Int64, 等于long,** 占8个字节。 -9223372036854775808 9223372036854775807

这样, 看起来比short,int,long更加直观些! 另外, 还有一个Byte, 它等于byte, 0 - 255.



## 浮点数格式

### FP64（HPC）、FP16（图形渲染）

浮点数精度

- FP64：**HPC**高精度需求
- FP16：**图形渲染**、**深度学习（DL）**

当GPGPU通用计算被普及的时候，高**性能运算(HPC)和深度学习(DL)对于浮点数精度有不同的需求**。

- 在HPC程序中，一般我们要求的**64位或者更高的精度**。
- 而在**DL**领域，我们在一直尝试着通过**降低精度来提供系统的吞吐量**，**从FP32, FP16到INT8，INT4**。

**FP64**是满足科学计算中需要的**更高精度的需求**，而**FP16**的结构，更多是服务了**图形渲染**的需求。

说明：

**吞吐量（throughput）**：**单位时间内成功地传送数据的数量**(以比特、字节、分组等测量)。



### TF32（DL领域加速推理）

2020年NVIDIA发布的Ampere架构GPU，带来了新的第三代TensorCore，支持专为**加速Inference**引入的TF32格式。用户升级TensorRT到7.1以后版本，**可以直接在TF32模型上面使用TF32的优化**，**带来了除了FP16, INT8以外的一个新的选择。**

**FP16**这个结构更多的是来自**图形渲染**的需求，**在DL领域我们认为FP16所表达的数据宽度不一定符合所有的模型**。所以最初在TPU上**Google提出了BFloat16**，将宽度改成和FP32一样，但是降低精度（mantissa由10位降低到7位，即精度降低到1/8）。

而**Ampere**提出的**TF32**更多是一个**Inference的场景**，在**Inference**中我们已经有一个**FP32**的模型，在这个假设前提下，我们可以不受16bits的限制，所以我们可以通过舍弃FP32在mantissa尾部的13bits，**达到使用FP32一样的宽度，FP16一样的精度的目的，使用TensorCore来加速TF32的运算**。

### BF16（深度学习DL）

BF16是一种相对较新的**浮点数格式**，又叫BFloat16或**Brain Float16**。

**深度学习中一般不需要FP64，FP32这种高精度的浮点格式**。虽然这两种浮点格式数据**精度高**，但也增加了**存储成本和处理过程中的时间成本**。

如果有一种数据格式能解决FP64，FP32这两种数据格式的这两个缺点，同时**又能满足一定的精度要求**，那无疑会大大提高**深度学习模型**的**推理速度和部署灵活性**。

这种数据格式就是BF16，使用BF16算法的**预测精度与FP32相似**，但不如FP32精确（**谷歌**曾说过，这是因为神经网络对指数的大小比尾数敏感得多）。对于大多数应用程序，尤其是**计算机视觉和语音**方面，这种折衷是可以接受的。

BF16的指数位比FP16多，跟FP32一样，不过小数位比较少。这样设计说明了设计者希望在16bits的空间中，通过**降低精度（比FP16的精度还低）的方式，来获得更大的数值空间（Dynamic Range）**。



## 分辨率

SD (Standard Definition) video specifies the video and audio codecs and file format that allows users to watch video on several electronic devices built to SD standards. SD video supports different formats, including VC-1, H.264, MPEG-4 and MPEG-2. Standard definition has always been a 4:3 aspect ratio with a **resolution** of 640 × 480 pixels.

- 标清是480p，720p是高清，1080p是全高清(超清)

- 标清 SD (Standard Definition)：480p、576p

- 高清 HD (High Definition)：720p

- 全高清 FHD (Full High Definition)：1080p

- 超高清 UHD (Ultra High Definition) (或 4k UHD)：4k

- 8k超高清 FUHD (Full Ultra High Definition) (或 8k UHD)：8k



## 每秒传输帧数 FPS

FPS（Frames Per Second）

FPS是图像领域中的定义，是指**画面每秒传输帧数**，通俗来讲就是指**动画或视频的画面数**。FPS是测量用于保存、显示动态视频的信息数量。

**每秒钟帧数越多，所显示的动作就会越流畅**。通常，要避免动作不流畅的**最低是30**。某些计算机视频格式，每秒只能提供15帧。

FPS也可以理解为我们常说的**“刷新率（单位为Hz）**”，例如我们常在游戏里说的“**FPS值**”。我们在装机选购显卡和显示器的时候，都会注意到“刷新率”。

一般我们设置缺省刷新率都在75Hz（即75帧/秒）以上。例如：75Hz的刷新率刷也就是指屏幕一秒内只扫描75次，即75帧/秒。而当刷新率太低时我们肉眼都能感觉到屏幕的闪烁，不连贯，对图像显示效果和视觉感观产生不好的影响。

**电影以每秒24张画面的速度播放，也就是一秒钟内在屏幕上连续投射出24张静止画面**。电影是24fps，通常简称为24帧。



## 制作工艺（Process）

制作工艺，指的是晶体管与晶体管之间的距离，单位是纳米。制作工艺越小说明集
成度越高，功耗越小，性能越好。



## 像素填充速率、纹理填充率

像素填充率和纹理填充率**反映的是 GPU 的性能**，而**显存带宽**则体现了**显存的性能**。

- 像素填充速率，指 GPU **一秒钟内能处理多少个像素**，单位是 GPixel/S（每秒十亿像素），或 MPixel/S（每秒百万像素）。像素填充速率是较好**衡量 GPU 图像显示功能的整体指标**，说明了显卡能以多快的速度对图像进行光栅化处理。**显卡的硬件指标对其速度具有直接影响**。
- 纹理填充率，指对多边形图像进行纹理贴图、实现 3D 效果的速度，和像素填充率类似，单位是 GTexels/S 或 MTexels/S。游戏采用了多纹理贴图的方式，使画面具有更好的光影效果。



## 零拷贝

零拷贝是一种**高效的数据传输机制**，在追求**低延迟的传输场景**中十分常用。

零拷贝指的是，从一个存储区域到另一个存储区域的copy任务**没有CPU参与**。

零拷贝通常用于**网络文件传输，以减少CPU消耗和内存带宽占用**，减少用户空间（用户可以操作的内存缓存区域）与CPU内核空间（CPU可以操作的内存缓存区域及寄存器）的拷贝过程，减少用户上下文（用户状态环境）与CPU内核上下文（CPU内核状态环境）间的切换，提高系统效率。



## 并行计算

并行计算**将大任务分割成可以同时执行的小任务**。

**SIMD和MIMD**是两种使用多处理器甚至多机器**进行并行计算的架构**。

- SIMD代表一条指令处理多条数据组成的数据流。
- MIMD支持多条指令处理多条数据组成的数据流。

SIMD和SIMD实现相似的基本功能，但是它们在实际使用和技术实现上都是不同的。

SIMD

SIMD架构**在多条数据上同时执行同一条命令**，包括查询、计算和存储信息的命令。一个使用的示例是**同时检索多个文件**。具有局部内存的处理器以同步的方式使用同一条命令处理不同的数据，通过多处理器间通信来实现移位分配。

MIMD

MIMD架构**在大量数据集上同时执行多条命令**。一个使用示例是**执行各种数学运算（如加法，乘法）**，使用很多分离的计算组件，按照顺序同时解决复杂的数学问题。MIMD可能是也可能不是同步的，比SIMD计算越来越常见。

实际使用的差异：

- SIMD通常用于处理器**执行大量计算**的问题，这些计算需要处理器**并行执行相同命令**。
- MIMD常用于如下场景：**将复杂算法分割为无关的、独立的部分，每个部分分配给一个不同的处理器来并发处理**的解决方案。

技术上的差异：

SIMD和MIMD在技术实现上也不同。

- SIMD的处理器通常**更简单、更小、更便宜**，也比MIMD处理器**更快**。
- 但是MIMD能够**处理复杂的多的操作**。
- 使用SIMD模拟实现MIMD操作，会花费更多的时间。SIMD要顺序的执行复杂操作，可是SIMD处理器能够并行的处理。



## 粗粒度可重构计算架构（CGRA）

可重构计算(（CGRA）Coarse-grained Reconfigurable Architecture) 是一种**全新的芯片架构技术**，可根据算法和应用的不同**灵活配置硬件资源**，执行不同的任务，同时具备**通用芯片的灵活性**和**专用集成电路的高效性**。

可重构计算是一种**空域上的并行计算模式**，以**空域的硬件结构**组织**不同粒度和不同功能的计算资源**。

在运行时，根据数据流的特点，让配置好的硬件资源互连形成相对固定的**计算通路**，以接近“专用电路”的方式进行计算；当算法和应用变换时，再次通过配置，重构为不同的**计算通路**去执行不同的任务。



## 异构计算（异质运算）

在计算机系统里采用不**同体系结构的处理单元（如通用CPU和GPU等加速处理器）**来实现**不同的计算功能**或**分担不同的计算任务**而形成的**协同计算模式**。

**在异构计算系统上进行的并行计算**通常称为异构计算。人们已从不同角度对异构计算进行定义，综合起来我们给出如下定义：

异构计算是**一种特殊形式的并行和分布式计算**，它或是用能同时支持SIMD方式和MIMD方式的单个独立计算机，或是用由高速网络互连的一组独立计算机来完成计算任务。它能**协调地使用性能、结构各异地机器**以满足不同的计算需求，并使代码（或代码段）能以获取最大总体性能方式来执行。



## 智能视频编码

ROI属于IVE技术的一种，IVE指的是Intelligent video encoding, 即智能视频编码， IVE技术可以根据客户要求对视频进行智能编码，并在不损失图像质量的前提下，优化视频编码性能，最终降低网络带宽占用率和减少存储空间。

在监控画面中，有些监控区域是不需要被监控或无关紧要，例如天空，墙壁， 草地等等监控对象，普通网络监控摄像机对整个区域进行视频编码（压缩）并传输，这样就给网络带宽和视频存储带来了压力。

而ROI智能视频编码技术却很好的解决了这个问题，ROI功能的摄像机可以让用户选择画面中感兴趣的区域，启用ROI功能后，重要的或者移动的区域将会进行高质量无损编码， 而对那些不移动，不被选择的区域降低其码率和图像质量，进行标准清晰度视频压缩，甚至是不传输这部分区域视频，达到节省网络带宽占用和视频存储空间。



