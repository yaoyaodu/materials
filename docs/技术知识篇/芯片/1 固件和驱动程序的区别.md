# 固件和驱动程序的区别

来源：[固件（Firmware），固件与驱动的区别 - 简书 (jianshu.com)](https://www.jianshu.com/p/0222686c0fb4)

固件：Firmware. 就是写入EROM（可擦写只读存储器）或者EEPROM（电可茶歇可编程只读存储器）中的`程序`。

固件是只设备内部保存的设备“驱动程序”，通过固件，操作系统才能按照标准的设备驱动实现特定机器的运行运作，比如光驱，刻录机等都有内部固件。

固件是担任着一个系统最基础最底层工作的软件。而在硬件设备中，固件就是硬件设备的灵魂，因为一些硬件设备除了固件以外没有其他软件组成，因此固件也就决定这硬件设备的功能以及性能。

手机、数码相机、mp3、mp4、路由器、电子书、交换机、猫、PSP、PS3、NDS、XBOX、U盘、主板、打印机的BIOS（BIOS就是一种固件）、显卡的BIOS。

固件既然是软件，就有大小之分。大的可有几百兆，小的也许只有几K，甚至不足1K。

而对于非独立的电子产品，比如硬盘、鼠标、BIOS、光驱、U盘等设备，固件就是指其最底层的，让设备得以运行的程序代码。

------

固件与驱动的区别：

驱动和固件（firmware）都是代码，前者为软件服务，后者为硬件服务。

随着计算机体系结构的发展，硬件的种类开始变多，操作系统的种类也变多了。
这个时候，因为各种技术的、商业的原因，硬件厂商希望自己的硬件能被更多的软件厂商使用，所以就需要在硬件之上做一些封装，让自己的硬件操纵起来更容易，这个时候就要有firmware这种东西了，它简化了软件与硬件的交互。

但是为什么不把fimware做的很完美，做的不需要驱动支持呢？因为有不同的操作系统。

不同的操作系统，对于操作硬件的方式完全不同，在Windows里应用态是无法直接写IO端口的，而在嵌入式系统里，一般都不限制直接操作IO端口。所以，硬件厂商一方面为了自己的硬件能被软件更简单的使用，就需要写firmware，而另一方面为了兼容各种操作系统，又不能把firmware写的太死，必须预留足够的余地让软件自由发挥——软件的自由发挥就是驱动。

不同操作系统的驱动是不能兼容的，原因就是驱动是为操作系统服务的，有的操作系统是单线程的，有些操作系统不允许动态申请内存，所以不同的操作系统要操作硬件，就要根据自身的特性编写对应的操作代码，这就是驱动存在的意义——适应系统需要。

假如世界上只有一种操作系统，并且版本永远不会改变，那么firmware和驱动就可以融合在一起，但这只能一个不现实的梦想，要知道民用操作系统和工业控制操作系统差别是十分巨大的。

从计算机领域来说，驱动和固件从来没有过明确的定义，就好像今天我们说内存，大部分人用来表示SDRAM，但也有人把Android里的“固化的Flash/Storage"称为“内存”，你不能说这样说就错了，因为这确实是一种“内部存储”。
但在Linux Kernel中，Driver和Firmware是有明确含义的，其中Driver是控制被操作系统管理的外部设备（Device）的代码段。很多时候Driver会被实现为LKM，但这不是必要条件。driver通过register_dirver()注册到总线(bus_type）上，当某个device被注册到同样的总线的时候，driver和device会通过一定的策略进行binding，最终在probe()函数中由driver实际控制对应的设备，并把对该设备的控制接口注册到Linux的其他子系统上（例如字符设备，v4l2子系统等）。
而Firmware，是表示运行在非“控制处理器”（指不直接运行操作系统的处理器，例如外设中的处理器，或者被用于bare metal的主处理器的其中一些核)中的程序。这些程序很多时候使用和操作系统所运行的处理器完全不同的指令集。这些程序以二进制形式存在于Linux内核的源代码树中，根据配置，可以直接集成到最终的映像中，或者被拷贝到指定的位置。当driver对device进行初始化的时候，通过load_firmware()等接口，可以把指定的firmware加载到内存中，由驱动传输到指定的设备上。
所以，总的来说，其实driver和firmware没有什么直接的关系。