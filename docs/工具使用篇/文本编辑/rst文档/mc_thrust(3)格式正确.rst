Introduction
............
Thrust is a C++ template library for MACA based on the Standard
Template Library (STL). Thrust allows you to implement high
performance parallel applications with minimal programming effort
through a high-level interface that is fully interoperable with
MACA C.

Thrust provides a rich collection of data parallel primitives such
as scan, sort, and reduce, which can be composed together to
implement complex algorithms with concise, readable source code.
By describing your computation in terms of these high-level
abstractions you provide Thrust with the freedom to select the
most efficient implementation automatically. As a result, Thrust
can be utilized in rapid prototyping of MACA applications, where
programmer productivity matters most, as well as in production,
where robustness and absolute performance are crucial.
This document describes how to develop MACA applications with
Thrust. The tutorial is intended to be accessible, even if you
have limited C++ or MACA experience.

Installation
============

Installing the MACA Toolkit will copy Thrust header files to
the standard MACA include directory for your system. Since
Thrust is a template library of header files, no further
installation is necessary to start using Thrust.

::

   # header location:
   ${MACA_PATH}/include/thrust
   ${MACA_PATH}/include/cub

Porting a Thrust application
============================

Porting a CUDA applicatiotn which originally calls the CUDA Thrust API to an
application calling MACA Thrust API should be easy. The MACA toolkit provides
a CUDA wrapper tool which can help you to achieve the porting task. Basically,
you don't need to modify your source code, just switch CXX to mxcc and change
MACA_PATH to maca toolkits directory

::

   export ${MACA_PATH}=your/maca/toolkits/path
   export CXX=${MACA_PATH}/mxgpu_llvm/bin/mxcc

Hello thrust
============

Here shows how to use thrust in cmake project

`CMakeLists.txt`
::

   project(example)
   cmake_minimum_required(VERSION 3.16)

   # maca toolkits path
   set(MACA_PATH $ENV{MACA_PATH})

   # thrust path in maca toolkits
   set(thrust_src_dir ${MACA_PATH}/include)

   set(example_target thrust.example)
   set(example_src exmample.cpp)

   enable_language(CXX)

   add_compile_options( -x maca -std=c++17 -fPIC
                        -DENABLE_CUDA_TO_MACA_ADAPTOR=1
                        -DMACA_PLATFORM -DUSE_MACAELF
                        -DUSE_MC_HOST_AND_MC_DEVICE
                        --maca-device-lib-path=${MACA_PATH}/lib/
                        --maca-device-lib=maca-mathlib.bc
                        --maca-device-lib=maca_kernellib.bc
                        --maca-host-lib-paht=${MACA_PATH}/lib/
                        --maca-host-lib=maca_mathlib_host.bc
   )

   add_executable(${example_target} "${example_src}")
   target_include_directories(${example_target} PRIVATE ${thrust_src_dir)

`example.cpp`
::

   // Example. Application Using C and Thrust: copy
   #include <thrust/host_vector.h>
   #include <thrust/device_vector.h>
   #include <thrust/copy.h>
   #include <thrust/fill.h>
   #include <thrust/sequence.h>
   #include <iostream>
   int main(void)
   {
      // initialize all ten integers of a device_vector to 1
      thrust::device_vector<int> D(10, 1);

      // set the first seven elements of a vector to 9
      thrust::fill(D.begin(), D.begin() + 7, 9);

      // initialize a host_vector with the first five elements of D
      thrust::host_vector<int> H(D.begin(), D.begin() + 5);

      // set the elements of H to 0, 1, 2, 3, ...
      thrust::sequence(H.begin(), H.end());

      // copy all of H back to the beginning of D
      thrust::copy(H.begin(), H.end(), D.begin());

      // print D
      for(size_t i = 0; i < D.size(); i++)
         std::cout << "D[" << i << "] = " << D[i] << std::endl;

      return 0;
   }

store `example.cpp` and `CMakeLists.txt` together, run build command :
::

   export ${MACA_PATH}=your/maca/toolkits/path
   export CXX=${MACA_PATH}/mxgpu_llvm/bin/mxcc

   mkdir build
   cmake -B build .
   cmake --build build -j

thrust.example binary will show in build directory

Using Thrust API
................

Algorithms
==========
Copying
-------
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Size,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::copy_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     Size n,
     OutputIterator result);

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   thrust::copy(InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename InputIterator,
     typename Size,
     typename OutputIterator>
   OutputIterator
   thrust::copy_n(InputIterator first,
     Size n,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename ForwardIterator1,
     typename ForwardIterator2>
   __host__ __device__ ForwardIterator2
   thrust::swap_ranges(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator1 first1,
     ForwardIterator1 last1,
     ForwardIterator2 first2);

   template <typename ForwardIterator1,
     typename ForwardIterator2>
   ForwardIterator2
   thrust::swap_ranges(ForwardIterator1 first1,
     ForwardIterator1 last1,
     ForwardIterator2 first2);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   thrust::uninitialized_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     ForwardIterator result);

   template <typename InputIterator,
     typename ForwardIterator>
   ForwardIterator
   thrust::uninitialized_copy(InputIterator first,
     InputIterator last,
     ForwardIterator result);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Size,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   thrust::uninitialized_copy_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     Size n,
     ForwardIterator result);

   template <typename InputIterator,
     typename Size,
     typename ForwardIterator>
   ForwardIterator
   thrust::uninitialized_copy_n(InputIterator first,
     Size n,
     ForwardIterator result);

**thrust::copy**
::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

`copy` copies elements from the range [`first`, `last`) to the
range [`result`, `result` + (`last` - `first`)). That is, it
performs the assignments \*\ `result` = \*\ `first`,
\*(\ `result` + `1`) = \*(\ `first` + `1`), and so on.
Generally, for every integer `n` from `0` to `last` -
`first`, `copy` performs the assignment \*(\ `result` + `n`)
= \*(\ `first` + `n`). Unlike `std::copy`, `copy` offers no
guarantee on order of operation. As a result, calling `copy` with
overlapping source and destination ranges has undefined behavior.

The return value is `result` + (`last` - `first`).

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `copy` to copy
from one range to another using the `thrust::device`
parallelization policy:

::

   #include <thrust/copy.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...

   thrust::device_vector<int> vec0(100);
   thrust::device_vector<int> vec1(100);
   ...

   thrust::copy(thrust::device, vec0.begin(), vec0.end(), vec1.begin());

   // vec1 is now a copy of vec0

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator** must be a model of `Input Iterator` and `InputIterator's` `value_type` must be convertible to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first** The beginning of the sequence to copy.

-  **last** The end of the sequence to copy.

-  **result** The destination sequence.

**Preconditions**: `result` may be equal to `first`, but `result` shall not be in the range `[first, last)` otherwise.

**Returns**: The end of the destination sequence.

**See**: https://en.cppreference.com/w/cpp/algorithm/copy

**thrust::copy_n**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Size,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   copy_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     Size n,
     OutputIterator result);

`copy_n` copies elements from the range `[first, first + n)` to
the range `[result, result + n)`. That is, it performs the
assignments `*result = *first, *(result + 1) = *(first + 1)`, and
so on. Generally, for every integer `i` from `0` to `n`,
`copy` performs the assignment \*(\ `result` + `i`) =
\*(\ `first` + `i`). Unlike `std::copy_n`, `copy_n` offers no
guarantee on order of operation. As a result, calling `copy_n` with
overlapping source and destination ranges has undefined behavior.
The return value is `result` + `n`.
The algorithm’s execution is parallelized as determined by `exec`.
The following code snippet demonstrates how to use `copy` to copy
from one range to another using the `thrust::device`
parallelization policy:

::

   #include <thrust/copy.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   size_t n = 100;
   thrust::device_vector<int> vec0(n);
   thrust::device_vector<int> vec1(n);
   ...
   thrust::copy_n(thrust::device, vec0.begin(), n, vec1.begin());

   // vec1 is now a copy of vec0

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator** must be a model of `Input Iterator` and `InputIterator's` `value_type` must be convertible to `OutputIterator's` `value_type`.

-  **Size** is an integral type.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first** The beginning of the range to copy.

-  **n** The number of elements to copy.

-  **result** The beginning destination range.

**Preconditions**: `result` may be equal to `first`, but `result` shall not be in the range `[first, first + n)` otherwise.

**Returns**: The end of the destination range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/copy_n

-  thrust::copy

**thrust::copy**

::

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   copy(InputIterator first,
     InputIterator last,
     OutputIterator result);

`copy` copies elements from the range [`first`, `last`) to the
range [`result`, `result` + (`last` - `first`)). That is, it
performs the assignments \*\ `result` = \*\ `first`,
\*(\ `result` + `1`) = \*(\ `first` + `1`), and so on.
Generally, for every integer `n` from `0` to `last` -
`first`, `copy` performs the assignment \*(\ `result` + `n`)
= \*(\ `first` + `n`). Unlike `std::copy`, `copy` offers no
guarantee on order of operation. As a result, calling `copy` with
overlapping source and destination ranges has undefined behavior.
The return value is `result` + (`last` - `first`).
The following code snippet demonstrates how to use `copy` to copy
from one range to another.

::

   #include <thrust/copy.h>
   #include <thrust/device_vector.h>
   ...

   thrust::device_vector<int> vec0(100);
   thrust::device_vector<int> vec1(100);
   ...

   thrust::copy(vec0.begin(), vec0.end(),
   vec1.begin());

   // vec1 is now a copy of vec0

**Template Parameters**:

-  **InputIterator** must be a model of `Input Iterator` and `InputIterator's` `value_type` must be convertible to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **first** The beginning of the sequence to copy.

-  **last** The end of the sequence to copy.

-  **result** The destination sequence.

**Preconditions**: `result` may be equal to `first`, but `result` shall not be in the range `[first, last)` otherwise.

**Returns**: The end of the destination sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/copy

**thrust::copy_n**

::

   template <typename InputIterator,
     typename Size,
     typename OutputIterator>
   OutputIterator
   copy_n(InputIterator first,
     Size n,
     OutputIterator result);

`copy_n` copies elements from the range `[first, first + n)` to
the range `[result, result + n)`. That is, it performs the
assignments `*result = *first, *(result + 1) = *(first + 1)`, and
so on. Generally, for every integer `i` from `0` to `n`,
`copy` performs the assignment \*(\ `result` + `i`) =
\*(\ `first` + `i`). Unlike `std::copy_n`, `copy_n` offers no
guarantee on order of operation. As a result, calling `copy_n` with
overlapping source and destination ranges has undefined behavior.
The return value is `result` + `n`.
The following code snippet demonstrates how to use `copy` to copy
from one range to another.

::

   #include <thrust/copy.h>
   #include <thrust/device_vector.h>
   ...
   size_t n = 100;
   thrust::device_vector<int> vec0(n);
   thrust::device_vector<int> vec1(n);
   ...
   thrust::copy_n(vec0.begin(), n, vec1.begin());

   // vec1 is now a copy of vec0

**Template Parameters**:

-  **InputIterator** must be a model of `Input Iterator` and `InputIterator's` `value_type` must be convertible to `OutputIterator's` `value_type`.

-  **Size** is an integral type.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **first** The beginning of the range to copy.

-  **n** The number of elements to copy.

-  **result** The beginning destination range.

**Preconditions**: `result` may be equal to `first`, but `result` shall not be in the range `[first, first + n)` otherwise.

**Returns**: The end of the destination range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/copy_n

-  thrust::copy

**thrust::swap_ranges**

::

   template <typename DerivedPolicy,
     typename ForwardIterator1,
     typename ForwardIterator2>
   __host__ __device__ ForwardIterator2
   swap_ranges(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator1 first1,
     ForwardIterator1 last1,
     ForwardIterator2 first2);

`swap_ranges` swaps each of the elements in the range
`[first1, last1)` with the corresponding element in the range
`[first2, first2 + (last1 - first1))`. That is, for each integer
`n` such that `0 <= n < (last1 - first1)`, it swaps
`*(first1 + n)` and `*(first2 + n)`. The return value is
`first2 + (last1 - first1)`.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `swap_ranges` to
swap the contents of two `thrust::device_vectors` using the
`thrust::device` execution policy for parallelization:

::

   #include <thrust/swap.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> v1(2), v2(2);
   v1[0] = 1;
   v1[1] = 2;
   v2[0] = 3;
   v2[1] = 4;

   thrust::swap_ranges(thrust::device, v1.begin(), v1.end(), v2.begin());

   // v1[0] == 3, v1[1] == 4, v2[0] == 1, v2[1] == 2

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **ForwardIterator1** is a model of `Forward Iterator`, and `ForwardIterator1's` `value_type` must be convertible to `ForwardIterator2's` `value_type`.

-  **ForwardIterator2** is a model of `Forward Iterator`, and `ForwardIterator2's` `value_type` must be convertible to `ForwardIterator1's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first1** The beginning of the first sequence to swap.

-  **last1** One position past the last element of the first sequence to swap.

-  **first2** The beginning of the second sequence to swap.

**Preconditions**: `first1` may equal `first2`, but the range `[first1, last1)` shall not overlap the range `[first2, first2 + (last1 - first1))` otherwise.

**Returns**: An iterator pointing to one position past the last element of the second sequence to swap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/swap_ranges

-  `Swap`

**thrust::swap_ranges**

::

   template <typename ForwardIterator1,
     typename ForwardIterator2>
   ForwardIterator2
   swap_ranges(ForwardIterator1 first1,
     ForwardIterator1 last1,
     ForwardIterator2 first2);

`swap_ranges` swaps each of the elements in the range
`[first1, last1)` with the corresponding element in the range
`[first2, first2 + (last1 - first1))`. That is, for each integer
`n` such that `0 <= n < (last1 - first1)`, it swaps
`*(first1 + n)` and `*(first2 + n)`. The return value is
`first2 + (last1 - first1)`.

The following code snippet demonstrates how to use `swap_ranges` to
swap the contents of two `thrust::device_vectors`.

::

   #include <thrust/swap.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> v1(2), v2(2);
   v1[0] = 1;
   v1[1] = 2;
   v2[0] = 3;
   v2[1] = 4;

   thrust::swap_ranges(v1.begin(), v1.end(), v2.begin());

   // v1[0] == 3, v1[1] == 4, v2[0] == 1, v2[1] == 2

**Template Parameters**:

-  **ForwardIterator1** is a model of `Forward Iterator`,
   and `ForwardIterator1's` `value_type` must be convertible to
   `ForwardIterator2's` `value_type`.

-  **ForwardIterator2** is a model of `Forward Iterator`,
   and `ForwardIterator2's` `value_type` must be convertible to
   `ForwardIterator1's` `value_type`.

**Function Parameters**:

-  **first1** The beginning of the first sequence to swap.

-  **last1** One position past the last element of the first
   sequence to swap.

-  **first2** The beginning of the second sequence to swap.

**Preconditions**: `first1` may equal `first2`, but the range
`[first1, last1)` shall not overlap the range
`[first2, first2 + (last1 - first1))` otherwise.

**Returns**: An iterator pointing to one position past the last
element of the second sequence to swap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/swap_ranges

-  `Swap`

**thrust::uninitialized_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   uninitialized_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     ForwardIterator result);

In `thrust`, the function `thrust::device_new` allocates memory
for an object and then creates an object at that location by calling
a constructor. Occasionally, however, it is useful to separate those
two operations. If each iterator in the range
`[result, result + (last - first))` points to uninitialized memory,
then `uninitialized_copy` creates a copy of `[first, last)` in
that range. That is, for each iterator `i` in the input,
`uninitialized_copy` creates a copy of `*i` in the location
pointed to by the corresponding iterator in the output range by
`ForwardIterator's` `value_type's` copy constructor with \*i as
its argument.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use
`uninitialized_copy` to initialize a range of uninitialized memory
using the `thrust::device` execution policy for parallelization:

::

   #include <thrust/uninitialized_copy.h>
   #include <thrust/device_malloc.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_vector<Int> input(N, val);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_copy(thrust::device, input.begin(), input.end(), array);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator** is a model of `Input Iterator`.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` has a constructor that takes
   a single argument whose type is
   `InputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first** The first element of the input range to copy from.

-  **last** The last element of the input range to copy from.

-  **result** The first element of the output range to copy to.

**Preconditions**: `first` may equal `result`, but the range
`[first, last)` and the range `[result, result + (last - first))`
shall not overlap otherwise.

**Returns**: An iterator pointing to the last element of the output
range.

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_copy

-  `copy`

-  `uninitialized_fill`

-  `device_new`

-  `device_malloc`

**thrust::uninitialized_copy**

::

   template <typename InputIterator,
     typename ForwardIterator>
   ForwardIterator
   uninitialized_copy(InputIterator first,
     InputIterator last,
     ForwardIterator result);

In `thrust`, the function `thrust::device_new` allocates memory
for an object and then creates an object at that location by calling
a constructor. Occasionally, however, it is useful to separate those
two operations. If each iterator in the range
`[result, result + (last - first))` points to uninitialized memory,
then `uninitialized_copy` creates a copy of `[first, last)` in
that range. That is, for each iterator `i` in the input,
`uninitialized_copy` creates a copy of `*i` in the location
pointed to by the corresponding iterator in the output range by
`ForwardIterator's` `value_type's` copy constructor with \*i as
its argument.

The following code snippet demonstrates how to use
`uninitialized_copy` to initialize a range of uninitialized memory.

::

   #include <thrust/uninitialized_copy.h>
   #include <thrust/device_malloc.h>
   #include <thrust/device_vector.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_vector<Int> input(N, val);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_copy(input.begin(), input.end(), array);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` has a constructor that takes
   a single argument whose type is
   `InputIterator's` `value_type`.

**Function Parameters**:

-  **first** The first element of the input range to copy from.

-  **last** The last element of the input range to copy from.

-  **result** The first element of the output range to copy to.

**Preconditions**: `first` may equal `result`, but the range
`[first, last)` and the range `[result, result + (last - first))`
shall not overlap otherwise.

**Returns**: An iterator pointing to the last element of the output
range.

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_copy

-  `copy`

-  `uninitialized_fill`

-  `device_new`

-  `device_malloc`

**thrust::uninitialized_copy_n**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Size,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   uninitialized_copy_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     Size n,
     ForwardIterator result);

In `thrust`, the function `thrust::device_new` allocates memory
for an object and then creates an object at that location by calling
a constructor. Occasionally, however, it is useful to separate those
two operations. If each iterator in the range
`[result, result + n)` points to uninitialized memory, then
`uninitialized_copy_n` creates a copy of `[first, first + n)` in
that range. That is, for each iterator `i` in the input,
`uninitialized_copy_n` creates a copy of `*i` in the location
pointed to by the corresponding iterator in the output range by
`InputIterator's` `value_type's` copy constructor with \*i as
its argument.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use
`uninitialized_copy` to initialize a range of uninitialized memory
using the `thrust::device` execution policy for parallelization:

::

   #include <thrust/uninitialized_copy.h>
   #include <thrust/device_malloc.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_vector<Int> input(N, val);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_copy_n(thrust::device, input.begin(), N, array);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator** is a model of `Input Iterator`.

-  **Size** is an integral type.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` has a constructor that takes
   a single argument whose type is
   `InputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first** The first element of the input range to copy from.

-  **n** The number of elements to copy.

-  **result** The first element of the output range to copy to.

**Preconditions**: `first` may equal `result`, but the range
`[first, first + n)` and the range `[result, result + n)` shall
not overlap otherwise.

**Returns**: An iterator pointing to the last element of the output
range.

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_copy

-  `uninitialized_copy`

-  `copy`

-  `uninitialized_fill`

-  `device_new`

-  `device_malloc`

**thrust::uninitialized_copy_n**

::

   template <typename InputIterator,
     typename Size,
     typename ForwardIterator>
   ForwardIterator
   uninitialized_copy_n(InputIterator first,
     Size n,
     ForwardIterator result);

In `thrust`, the function `thrust::device_new` allocates memory
for an object and then creates an object at that location by calling
a constructor. Occasionally, however, it is useful to separate those
two operations. If each iterator in the range
`[result, result + n)` points to uninitialized memory, then
`uninitialized_copy_n` creates a copy of `[first, first + n)` in
that range. That is, for each iterator `i` in the input,
`uninitialized_copy_n` creates a copy of `*i` in the location
pointed to by the corresponding iterator in the output range by
`InputIterator's` `value_type's` copy constructor with \*i as
its argument.

The following code snippet demonstrates how to use
`uninitialized_copy` to initialize a range of uninitialized memory.

::

   #include <thrust/uninitialized_copy.h>
   #include <thrust/device_malloc.h>
   #include <thrust/device_vector.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_vector<Int> input(N, val);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_copy_n(input.begin(), N, array);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`.

-  **Size** is an integral type.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` has a constructor that takes
   a single argument whose type is
   `InputIterator's` `value_type`.

**Function Parameters**:

-  **first** The first element of the input range to copy from.

-  **n** The number of elements to copy.

-  **result** The first element of the output range to copy to.

**Preconditions**: `first` may equal `result`, but the range
`[first, first + n)` and the range `[result, result + n)` shall
not overlap otherwise.

**Returns**: An iterator pointing to the last element of the output
range.

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_copy

-  `uninitialized_copy`

-  `copy`

-  `uninitialized_fill`

-  `device_new`

-  `device_malloc`

Gathering
*********
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename RandomAccessIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::gather(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator map_first,
     InputIterator map_last,
     RandomAccessIterator input_first,
     OutputIterator result);

   template <typename InputIterator,
     typename RandomAccessIterator,
     typename OutputIterator> OutputIterator
   thrust::gather(InputIterator map_first,
     InputIterator map_last,
     RandomAccessIterator input_first,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::gather_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator> OutputIterator
   thrust::gather_if(InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   thrust::gather_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result,
     Predicate pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator,
     typename Predicate> OutputIterator
   thrust::gather_if(InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result,
     Predicate pred);

**thrust::gather**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename RandomAccessIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   gather(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator map_first,
     InputIterator map_last,
     RandomAccessIterator input_first,
     OutputIterator result);

`gather` copies elements from a source array into a destination
range according to a map. For each input iterator `i` in the range
`[map_first, map_last)`, the value `input_first[*i]` is assigned
to `*(result + (i - map_first))`. `RandomAccessIterator` must
permit random access.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `gather` to
reorder a range using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/gather.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   // mark even indices with a 1; odd indices with a 0
   int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
   thrust::device_vector<int> d_values(values, values + 10);

   // gather all even indices into the first half of the range
   // and odd indices to the last half of the range
   int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10);
   thrust::gather(thrust::device,
   d_map.begin(), d_map.end(),
   d_values.begin(),
   d_output.begin());
   // d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}

**Remark**: `gather` is the inverse of thrust::scatter.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator** must be a model of `Input Iterator`
   and `InputIterator's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`
   and `RandomAccessIterator's` `value_type` must be convertible
   to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **map_first** Beginning of the range of gather locations.

-  **map_last** End of the range of gather locations.

-  **input_first** Beginning of the source range.

-  **result** Beginning of the destination range.

**Preconditions**:

-  The range `[map_first, map_last)` shall not overlap the range
   `[result, result + (map_last - map_first))`.

-  The input data shall not overlap the range
   `[result, result + (map_last - map_first))`.

**thrust::gather**

::

   template <typename InputIterator,
     typename RandomAccessIterator,
     typename OutputIterator> OutputIterator
   gather(InputIterator map_first,
     InputIterator map_last,
     RandomAccessIterator input_first,
     OutputIterator result);

`gather` copies elements from a source array into a destination
range according to a map. For each input iterator `i` in the range
`[map_first, map_last)`, the value `input_first[*i]` is assigned
to `*(result + (i - map_first))`. `RandomAccessIterator` must
permit random access.

The following code snippet demonstrates how to use `gather` to
reorder a range.

::

   #include <thrust/gather.h>
   #include <thrust/device_vector.h>
   ...
   // mark even indices with a 1; odd indices with a 0
   int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
   thrust::device_vector<int> d_values(values, values + 10);

   // gather all even indices into the first half of the range
   // and odd indices to the last half of the range
   int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10);
   thrust::gather(d_map.begin(), d_map.end(),
   d_values.begin(),
   d_output.begin());
   // d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}

**Remark**: `gather` is the inverse of thrust::scatter.

**Template Parameters**:

-  **InputIterator** must be a model of `Input Iterator`
   and `InputIterator's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`
   and `RandomAccessIterator's` `value_type` must be convertible
   to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **map_first** Beginning of the range of gather locations.

-  **map_last** End of the range of gather locations.

-  **input_first** Beginning of the source range.

-  **result** Beginning of the destination range.

**Preconditions**:

-  The range `[map_first, map_last)` shall not overlap the range
   `[result, result + (map_last - map_first))`.

-  The input data shall not overlap the range
   `[result, result + (map_last - map_first))`.

**thrust::gather_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   gather_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result);

`gather_if` conditionally copies elements from a source array into
a destination range according to a map. For each input iterator `i`
in the range `[map_first, map_last)`, such that the value of
`*(stencil + (i - map_first))` is `true`, the value
`input_first[*i]` is assigned to `*(result + (i - map_first))`.
`RandomAccessIterator` must permit random access.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `gather_if` to
gather selected values from an input range using the
`thrust::device` execution policy:

::

   #include <thrust/gather.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...

   int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   thrust::device_vector<int> d_values(values, values + 10);

   // select elements at even-indexed locations
   int stencil[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
   thrust::device_vector<int> d_stencil(stencil, stencil + 10);

   // map all even indices into the first half of the range
   // and odd indices to the last half of the range
   int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10, 7);
   thrust::gather_if(thrust::device,
   d_map.begin(), d_map.end(),
   d_stencil.begin(),
   d_values.begin(),
   d_output.begin());
   // d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}

**Remark**: `gather_if` is the inverse of `scatter_if`.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `bool`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`
   and `RandomAccessIterator's` `value_type` must be convertible
   to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **map_first** Beginning of the range of gather locations.

-  **map_last** End of the range of gather locations.

-  **stencil** Beginning of the range of predicate values.

-  **input_first** Beginning of the source range.

-  **result** Beginning of the destination range.

**Preconditions**:

-  The range `[map_first, map_last)` shall not overlap the range
   `[result, result + (map_last - map_first))`.

-  The range `[stencil, stencil + (map_last - map_first))` shall
   not overlap the range
   `[result, result + (map_last - map_first))`.

-  The input data shall not overlap the range
   `[result, result + (map_last - map_first))`.

**thrust::gather_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator> OutputIterator
   gather_if(InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result);

`gather_if` conditionally copies elements from a source array into
a destination range according to a map. For each input iterator `i`
in the range `[map_first, map_last)`, such that the value of
`*(stencil + (i - map_first))` is `true`, the value
`input_first[*i]` is assigned to `*(result + (i - map_first))`.
`RandomAccessIterator` must permit random access.

The following code snippet demonstrates how to use `gather_if` to
gather selected values from an input range.

::

   #include <thrust/gather.h>
   #include <thrust/device_vector.h>
   ...

   int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   thrust::device_vector<int> d_values(values, values + 10);

   // select elements at even-indexed locations
   int stencil[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
   thrust::device_vector<int> d_stencil(stencil, stencil + 10);

   // map all even indices into the first half of the range
   // and odd indices to the last half of the range
   int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10, 7);
   thrust::gather_if(d_map.begin(), d_map.end(),
   d_stencil.begin(),
   d_values.begin(),
   d_output.begin());
   // d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}

**Remark**: `gather_if` is the inverse of `scatter_if`.

**Template Parameters**:

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `bool`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`
   and `RandomAccessIterator's` `value_type` must be convertible
   to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

**Function Parameters**:

-  **map_first** Beginning of the range of gather locations.

-  **map_last** End of the range of gather locations.

-  **stencil** Beginning of the range of predicate values.

-  **input_first** Beginning of the source range.

-  **result** Beginning of the destination range.

**Preconditions**:

-  The range `[map_first, map_last)` shall not overlap the range
   `[result, result + (map_last - map_first))`.

-  The range `[stencil, stencil + (map_last - map_first))` shall
   not overlap the range
   `[result, result + (map_last - map_first))`.

-  The input data shall not overlap the range
   `[result, result + (map_last - map_first))`.

**thrust::gather_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   gather_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result,
     Predicate pred);

`gather_if` conditionally copies elements from a source array into
a destination range according to a map. For each input iterator `i`
in the range `[map_first, map_last)` such that the value of
`pred(*(stencil + (i - map_first)))` is `true`, the value
`input_first[*i]` is assigned to `*(result + (i - map_first))`.
`RandomAccessIterator` must permit random access.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `gather_if` to
gather selected values from an input range based on an arbitrary
selection function using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/gather.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...

   int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   thrust::device_vector<int> d_values(values, values + 10);

   // we will select an element when our stencil is even
   int stencil[10] = {0, 3, 4, 1, 4, 1, 2, 7, 8, 9};
   thrust::device_vector<int> d_stencil(stencil, stencil + 10);

   // map all even indices into the first half of the range
   // and odd indices to the last half of the range
   int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10, 7);
   thrust::gather_if(thrust::device,
   d_map.begin(), d_map.end(),
   d_stencil.begin(),
   d_values.begin(),
   d_output.begin(),
   is_even());
   // d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}

**Remark**: `gather_if` is the inverse of `scatter_if`.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `Predicate's` `argument_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`
   and `RandomAccessIterator's` `value_type` must be convertible
   to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **map_first** Beginning of the range of gather locations.

-  **map_last** End of the range of gather locations.

-  **stencil** Beginning of the range of predicate values.

-  **input_first** Beginning of the source range.

-  **result** Beginning of the destination range.

-  **pred** Predicate to apply to the stencil values.

**Preconditions**:

-  The range `[map_first, map_last)` shall not overlap the range
   `[result, result + (map_last - map_first))`.

-  The range `[stencil, stencil + (map_last - map_first))` shall
   not overlap the range
   `[result, result + (map_last - map_first))`.

-  The input data shall not overlap the range
   `[result, result + (map_last - map_first))`.

**thrust::gather_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator,
     typename OutputIterator,
     typename Predicate>
   OutputIterator
   gather_if(InputIterator1 map_first,
     InputIterator1 map_last,
     InputIterator2 stencil,
     RandomAccessIterator input_first,
     OutputIterator result,
     Predicate pred);

`gather_if` conditionally copies elements from a source array into
a destination range according to a map. For each input iterator `i`
in the range `[map_first, map_last)` such that the value of
`pred(*(stencil + (i - map_first)))` is `true`, the value
`input_first[*i]` is assigned to `*(result + (i - map_first))`.
`RandomAccessIterator` must permit random access.

The following code snippet demonstrates how to use `gather_if` to
gather selected values from an input range based on an arbitrary
selection function.

::

   #include <thrust/gather.h>
   #include <thrust/device_vector.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...

   int values[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   thrust::device_vector<int> d_values(values, values + 10);

   // we will select an element when our stencil is even
   int stencil[10] = {0, 3, 4, 1, 4, 1, 2, 7, 8, 9};
   thrust::device_vector<int> d_stencil(stencil, stencil + 10);

   // map all even indices into the first half of the range
   // and odd indices to the last half of the range
   int map[10]   = {0, 2, 4, 6, 8, 1, 3, 5, 7, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10, 7);
   thrust::gather_if(d_map.begin(), d_map.end(),
   d_stencil.begin(),
   d_values.begin(),
   d_output.begin(),
   is_even());
   // d_output is now {0, 7, 4, 7, 8, 7, 3, 7, 7, 7}

**Remark**: `gather_if` is the inverse of `scatter_if`.

**Template Parameters**:

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `Predicate's` `argument_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`
   and `RandomAccessIterator's` `value_type` must be convertible
   to `OutputIterator's` `value_type`.

-  **OutputIterator** must be a model of `Output Iterator`.

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **map_first** Beginning of the range of gather locations.

-  **map_last** End of the range of gather locations.

-  **stencil** Beginning of the range of predicate values.

-  **input_first** Beginning of the source range.

-  **result** Beginning of the destination range.

-  **pred** Predicate to apply to the stencil values.

**Preconditions**:

-  The range `[map_first, map_last)` shall not overlap the range
   `[result, result + (map_last - map_first))`.

-  The range `[stencil, stencil + (map_last - map_first))` shall
   not overlap the range
   `[result, result + (map_last - map_first))`.

-  The input data shall not overlap the range
   `[result, result + (map_last - map_first))`.

Scattering
**********
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator>
   __host__ __device__ void
   thrust::scatter(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     RandomAccessIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator> void
   thrust::scatter(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     RandomAccessIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator>
   __host__ __device__ void
   thrust::scatter_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator> void
   thrust::scatter_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator,
     typename Predicate>
   __host__ __device__ void
   thrust::scatter_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output,
     Predicate pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator,
     typename Predicate> void
   thrust::scatter_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output,
     Predicate pred);

**thrust::scatter**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator>
   __host__ __device__ void
   scatter(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     RandomAccessIterator result);

`scatter` copies elements from a source range into an output array
according to a map. For each iterator `i` in the range [`first`,
`last`), the value `*i` is assigned to
`output[*(map + (i - first))]`. The output iterator must permit
random access. If the same index appears more than once in the range
`[map, map + (last - first))`, the result is undefined.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `scatter` to
reorder a range using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/scatter.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   // mark even indices with a 1; odd indices with a 0
   int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
   thrust::device_vector<int> d_values(values, values + 10);

   // scatter all even indices into the first half of the
   // range, and odd indices vice versa
   int map[10]   = {0, 5, 1, 6, 2, 7, 3, 8, 4, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10);
   thrust::scatter(thrust::device,
   d_values.begin(), d_values.end(),
   d_map.begin(), d_output.begin());
   // d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}

**Note**: `scatter` is the inverse of thrust::gather.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `value_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first** Beginning of the sequence of values to scatter.

-  **last** End of the sequence of values to scatter.

-  **map** Beginning of the sequence of output indices.

-  **result** Destination of the source elements.

**Preconditions**:

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range `[first,last)` for
   all iterators `i` in the range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[map,map + (last - first))` for all iterators `i` in the
   range `[map,map + (last - first))`.

-  The expression `result[*i]` shall be valid for all iterators in
   the range `[map,map + (last - first))`.

**thrust::scatter**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename RandomAccessIterator> void
   scatter(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     RandomAccessIterator result);

`scatter` copies elements from a source range into an output array
according to a map. For each iterator `i` in the range [`first`,
`last`), the value `*i` is assigned to
`output[*(map + (i - first))]`. The output iterator must permit
random access. If the same index appears more than once in the range
`[map, map + (last - first))`, the result is undefined.

The following code snippet demonstrates how to use `scatter` to
reorder a range.

::

   #include <thrust/scatter.h>
   #include <thrust/device_vector.h>
   ...
   // mark even indices with a 1; odd indices with a 0
   int values[10] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
   thrust::device_vector<int> d_values(values, values + 10);

   // scatter all even indices into the first half of the
   // range, and odd indices vice versa
   int map[10]   = {0, 5, 1, 6, 2, 7, 3, 8, 4, 9};
   thrust::device_vector<int> d_map(map, map + 10);

   thrust::device_vector<int> d_output(10);
   thrust::scatter(d_values.begin(), d_values.end(),
   d_map.begin(), d_output.begin());
   // d_output is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}

**Note**: `scatter` is the inverse of thrust::gather.

**Template Parameters**:

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `value_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`.

**Function Parameters**:

-  **first** Beginning of the sequence of values to scatter.

-  **last** End of the sequence of values to scatter.

-  **map** Beginning of the sequence of output indices.

-  **result** Destination of the source elements.

**Preconditions**:

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range `[first,last)` for
   all iterators `i` in the range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[map,map + (last - first))` for all iterators `i` in the
   range `[map,map + (last - first))`.

-  The expression `result[*i]` shall be valid for all iterators in
   the range `[map,map + (last - first))`.

**thrust::scatter_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator>
   __host__ __device__ void
   scatter_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output);

`scatter_if` conditionally copies elements from a source range into
an output array according to a map. For each iterator `i` in the
range `[first, last)` such that `*(stencil + (i - first))` is
true, the value `*i` is assigned to
`output[*(map + (i - first))]`. The output iterator must permit
random access. If the same index appears more than once in the range
`[map, map + (last - first))` the result is undefined.

The algorithm’s execution is parallelized as determined by `exec`.

::

   #include <thrust/scatter.h>
   #include <thrust/execution_policy.h>
   ...
   int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
   int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
   int S[8] = {1, 0, 1, 0, 1, 0, 1, 0};
   int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

   thrust::scatter_if(thrust::host, V, V + 8, M, S, D);

   // D contains [10, 30, 50, 70, 0, 0, 0, 0];

**Note**: `scatter_if` is the inverse of thrust::gather_if.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `value_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator3** must be a model of `Input Iterator`
   and `InputIterator3's` `value_type` must be convertible to
   `bool`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first** Beginning of the sequence of values to scatter.

-  **last** End of the sequence of values to scatter.

-  **map** Beginning of the sequence of output indices.

-  **stencil** Beginning of the sequence of predicate values.

-  **output** Beginning of the destination range.

**Preconditions**:

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range `[first,last)` for
   all iterators `i` in the range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[map,map + (last - first))` for all iterators `i` in the
   range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[stencil,stencil + (last - first))` for all iterators `i` in
   the range `[map,map + (last - first))`.

-  The expression `result[*i]` shall be valid for all iterators
   `i` in the range `[map,map + (last - first))` for which the
   following condition holds: `*(stencil + i) != false`.

**thrust::scatter_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator> void
   scatter_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output);

`scatter_if` conditionally copies elements from a source range into
an output array according to a map. For each iterator `i` in the
range `[first, last)` such that `*(stencil + (i - first))` is
true, the value `*i` is assigned to
`output[*(map + (i - first))]`. The output iterator must permit
random access. If the same index appears more than once in the range
`[map, map + (last - first))` the result is undefined.

::

   #include <thrust/scatter.h>
   ...
   int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
   int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
   int S[8] = {1, 0, 1, 0, 1, 0, 1, 0};
   int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

   thrust::scatter_if(V, V + 8, M, S, D);

   // D contains [10, 30, 50, 70, 0, 0, 0, 0];

**Note**: `scatter_if` is the inverse of thrust::gather_if.

**Template Parameters**:

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `value_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator3** must be a model of `Input Iterator`
   and `InputIterator3's` `value_type` must be convertible to
   `bool`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`.

**Function Parameters**:

-  **first** Beginning of the sequence of values to scatter.

-  **last** End of the sequence of values to scatter.

-  **map** Beginning of the sequence of output indices.

-  **stencil** Beginning of the sequence of predicate values.

-  **output** Beginning of the destination range.

**Preconditions**:

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range `[first,last)` for
   all iterators `i` in the range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[map,map + (last - first))` for all iterators `i` in the
   range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[stencil,stencil + (last - first))` for all iterators `i` in
   the range `[map,map + (last - first))`.

-  The expression `result[*i]` shall be valid for all iterators
   `i` in the range `[map,map + (last - first))` for which the
   following condition holds: `*(stencil + i) != false`.

**thrust::scatter_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator,
     typename Predicate>
   __host__ __device__ void
   scatter_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output,
     Predicate pred);

`scatter_if` conditionally copies elements from a source range into
an output array according to a map. For each iterator `i` in the
range `[first, last)` such that `pred(*(stencil + (i - first)))`
is `true`, the value `*i` is assigned to
`output[*(map + (i - first))]`. The output iterator must permit
random access. If the same index appears more than once in the range
`[map, map + (last - first))` the result is undefined.

The algorithm’s execution is parallelized as determined by `exec`.

::

   #include <thrust/scatter.h>
   #include <thrust/execution_policy.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(int x)
   {
      return (x % 2) == 0;
   }
   };

   ...

   int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
   int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
   int S[8] = {2, 1, 2, 1, 2, 1, 2, 1};
   int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

   is_even pred;
   thrust::scatter_if(thrust::host, V, V + 8, M, S, D, pred);

   // D contains [10, 30, 50, 70, 0, 0, 0, 0];

**Note**: `scatter_if` is the inverse of thrust::gather_if.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `value_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator3** must be a model of `Input Iterator`
   and `InputIterator3's` `value_type` must be convertible to
   `Predicate's` `argument_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`.

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first** Beginning of the sequence of values to scatter.

-  **last** End of the sequence of values to scatter.

-  **map** Beginning of the sequence of output indices.

-  **stencil** Beginning of the sequence of predicate values.

-  **output** Beginning of the destination range.

-  **pred** Predicate to apply to the stencil values.

**Preconditions**:

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range `[first,last)` for
   all iterators `i` in the range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[map,map + (last - first))` for all iterators `i` in the
   range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[stencil,stencil + (last - first))` for all iterators `i` in
   the range `[map,map + (last - first))`.

-  The expression `result[*i]` shall be valid for all iterators
   `i` in the range `[map,map + (last - first))` for which the
   following condition holds: `pred(*(stencil + i)) != false`.

**thrust::scatter_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename RandomAccessIterator,
     typename Predicate> void
   scatter_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 map,
     InputIterator3 stencil,
     RandomAccessIterator output,
     Predicate pred);

`scatter_if` conditionally copies elements from a source range into
an output array according to a map. For each iterator `i` in the
range `[first, last)` such that `pred(*(stencil + (i - first)))`
is `true`, the value `*i` is assigned to
`output[*(map + (i - first))]`. The output iterator must permit
random access. If the same index appears more than once in the range
`[map, map + (last - first))` the result is undefined.

::

   #include <thrust/scatter.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(int x)
   {
      return (x % 2) == 0;
   }
   };

   ...

   int V[8] = {10, 20, 30, 40, 50, 60, 70, 80};
   int M[8] = {0, 5, 1, 6, 2, 7, 3, 4};
   int S[8] = {2, 1, 2, 1, 2, 1, 2, 1};
   int D[8] = {0, 0, 0, 0, 0, 0, 0, 0};

   is_even pred;
   thrust::scatter_if(V, V + 8, M, S, D, pred);

   // D contains [10, 30, 50, 70, 0, 0, 0, 0];

**Note**: `scatter_if` is the inverse of thrust::gather_if.

**Template Parameters**:

-  **InputIterator1** must be a model of `Input Iterator`
   and `InputIterator1's` `value_type` must be convertible to
   `RandomAccessIterator's` `value_type`.

-  **InputIterator2** must be a model of `Input Iterator`
   and `InputIterator2's` `value_type` must be convertible to
   `RandomAccessIterator's` `difference_type`.

-  **InputIterator3** must be a model of `Input Iterator`
   and `InputIterator3's` `value_type` must be convertible to
   `Predicate's` `argument_type`.

-  **RandomAccessIterator** must be a model of `Random Access Iterator`.

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **first** Beginning of the sequence of values to scatter.

-  **last** End of the sequence of values to scatter.

-  **map** Beginning of the sequence of output indices.

-  **stencil** Beginning of the sequence of predicate values.

-  **output** Beginning of the destination range.

-  **pred** Predicate to apply to the stencil values.

**Preconditions**:

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range `[first,last)` for
   all iterators `i` in the range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[map,map + (last - first))` for all iterators `i` in the
   range `[map,map + (last - first))`.

-  The iterator `result + i` shall not refer to any element
   referenced by any iterator `j` in the range
   `[stencil,stencil + (last - first))` for all iterators `i` in
   the range `[map,map + (last - first))`.

-  The expression `result[*i]` shall be valid for all iterators
   `i` in the range `[map,map + (last - first))` for which the
   following condition holds: `pred(*(stencil + i)) != false`.

Merging
-------
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::merge(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   thrust::merge(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   thrust::merge(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   thrust::merge(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::merge_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2> t
   hrust::pair< OutputIterator1, OutputIterator2 >
   thrust::merge_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Compare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::merge_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     Compare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >

   thrust::merge_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

**thrust::merge**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   merge(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`merge` combines two sorted ranges `[first1, last1)` and
`[first2, last2)` into a single sorted range. That is, it copies
from `[first1, last1)` and `[first2, last2)` into
`[result, result + (last1 - first1) + (last2 - first2))` such that
the resulting range is in ascending order. `merge` is stable,
meaning both that the relative order of elements within each input
range is preserved, and that for equivalent elements in both input
ranges the element from the first range precedes the element from the
second. The return value is
`result + (last1 - first1) + (last2 - first2)`.

This version of `merge` compares elements using `operator<`.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `merge` to
compute the merger of two sorted sets of integers using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/merge.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[6] = {1, 3, 5, 7, 9, 11};
   int A2[7] = {1, 1, 2, 3, 5,  8, 13};

   int result[13];

   int *result_end =
   thrust::merge(thrust::host,
   A1, A1 + 6,
   A2, A2 + 7,
   result);
   // result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the merged output.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall be
   sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/merge

-  `set_union`

-  `sort`

-  `is_sorted`

**thrust::merge**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   merge(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`merge` combines two sorted ranges `[first1, last1)` and
`[first2, last2)` into a single sorted range. That is, it copies
from `[first1, last1)` and `[first2, last2)` into
`[result, result + (last1 - first1) + (last2 - first2))` such that
the resulting range is in ascending order. `merge` is stable,
meaning both that the relative order of elements within each input
range is preserved, and that for equivalent elements in both input
ranges the element from the first range precedes the element from the
second. The return value is
`result + (last1 - first1) + (last2 - first2)`.

This version of `merge` compares elements using `operator<`.

The following code snippet demonstrates how to use `merge` to
compute the merger of two sorted sets of integers.

::

   #include <thrust/merge.h>
   ...
   int A1[6] = {1, 3, 5, 7, 9, 11};
   int A2[7] = {1, 1, 2, 3, 5,  8, 13};

   int result[13];

   int *result_end = thrust::merge(A1, A1 + 6, A2, A2 + 7, result);
   // result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the merged output.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall be
   sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/merge

-  `set_union`

-  `sort`

-  `is_sorted`

**thrust::merge**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   merge(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`merge` combines two sorted ranges `[first1, last1)` and
`[first2, last2)` into a single sorted range. That is, it copies
from `[first1, last1)` and `[first2, last2)` into
`[result, result + (last1 - first1) + (last2 - first2))` such that
the resulting range is in ascending order. `merge` is stable,
meaning both that the relative order of elements within each input
range is preserved, and that for equivalent elements in both input
ranges the element from the first range precedes the element from the
second. The return value is
`result + (last1 - first1) + (last2 - first2)`.

This version of `merge` compares elements using a function object
`comp`.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `merge` to
compute the merger of two sets of integers sorted in descending order
using the `thrust::host` execution policy for parallelization:

::

   #include <thrust/merge.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[6] = {11, 9, 7, 5, 3, 1};
   int A2[7] = {13, 8, 5, 3, 2, 1, 1};

   int result[13];

   int *result_end = thrust::merge(thrust::host,
   A1, A1 + 6,
   A2, A2 + 7,
   result,
   thrust::greater<int>());
   // result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a type in
   `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a type in
   `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the merged output.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall be
   sorted with respect to `comp`.

-  The resulting range shall not overlap with either input range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/merge

-  `sort`

-  `is_sorted`

**thrust::merge**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   merge(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`merge` combines two sorted ranges `[first1, last1)` and
`[first2, last2)` into a single sorted range. That is, it copies
from `[first1, last1)` and `[first2, last2)` into
`[result, result + (last1 - first1) + (last2 - first2))` such that
the resulting range is in ascending order. `merge` is stable,
meaning both that the relative order of elements within each input
range is preserved, and that for equivalent elements in both input
ranges the element from the first range precedes the element from the
second. The return value is
`result + (last1 - first1) + (last2 - first2)`.

This version of `merge` compares elements using a function object
`comp`.

The following code snippet demonstrates how to use `merge` to
compute the merger of two sets of integers sorted in descending
order.

::

   #include <thrust/merge.h>
   #include <thrust/functional.h>
   ...
   int A1[6] = {11, 9, 7, 5, 3, 1};
   int A2[7] = {13, 8, 5, 3, 2, 1, 1};

   int result[13];

   int *result_end = thrust::merge(A1, A1 + 6, A2, A2 + 7, result, thrust::greater<int>());
   // result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a type in
   `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a type in
   `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the merged output.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall be
   sorted with respect to `comp`.

-  The resulting range shall not overlap with either input range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/merge

-  `sort`

-  `is_sorted`

**thrust::merge_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   merge_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`merge_by_key` performs a key-value merge. That is,
`merge_by_key` copies elements from `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)` into a single range,
`[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending key order.

At the same time, `merge_by_key` copies elements from the two
associated ranges `[values_first1 + (keys_last1 - keys_first1))`
and `[values_first2 + (keys_last2 - keys_first2))` into a single
range,
`[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending order implied by each
input element’s associated key.

`merge_by_key` is stable, meaning both that the relative order of
elements within each input range is preserved, and that for
equivalent elements in all input key ranges the element from the
first range precedes the element from the second.

The return value is is
`(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
and
`(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`.

The algorithm’s execution is parallelized as determined by `exec`.

The following code snippet demonstrates how to use `merge_by_key`
to compute the merger of two sets of integers sorted in ascending
order using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/merge.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {1, 3, 5, 7, 9, 11};
   int A_vals[6] = {0, 0, 0, 0, 0, 0};

   int B_keys[7] = {1, 1, 2, 3, 5, 8, 13};
   int B_vals[7] = {1, 1, 1, 1, 1, 1, 1};

   int keys_result[13];
   int vals_result[13];

   thrust::pair<int*,int*> end =
   thrust::merge_by_key(thrust::host,
   A_keys, A_keys + 6,
   B_keys, B_keys + 7,
   A_vals, B_vals,
   keys_result, vals_result);

   // keys_result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}
   // vals_result = {0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0,  0,  1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **keys_first1** The beginning of the first input range of
   keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range of
   keys.

-  **keys_last2** The end of the second input range of keys.

-  **values_first1** The beginning of the first input range of
   values.

-  **values_first2** The beginning of the first input range of
   values.

-  **keys_result** The beginning of the merged output range of
   keys.

-  **values_result** The beginning of the merged output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect to
   `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end of
the output range of keys, and such that `p.second` is the end of
the output range of values.

**See**:

-  merge

-  `sort_by_key`

-  `is_sorted`

**thrust::merge_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   merge_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`merge_by_key` performs a key-value merge. That is,
`merge_by_key` copies elements from `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)` into a single range,
`[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending key order.

At the same time, `merge_by_key` copies elements from the two
associated ranges `[values_first1 + (keys_last1 - keys_first1))`
and `[values_first2 + (keys_last2 - keys_first2))` into a single
range,
`[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending order implied by each
input element’s associated key.

`merge_by_key` is stable, meaning both that the relative order of
elements within each input range is preserved, and that for
equivalent elements in all input key ranges the element from the
first range precedes the element from the second.

The return value is is
`(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
and
`(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`.

The following code snippet demonstrates how to use `merge_by_key`
to compute the merger of two sets of integers sorted in ascending
order.

::

   #include <thrust/merge.h>
   #include <thrust/functional.h>
   ...
   int A_keys[6] = {1, 3, 5, 7, 9, 11};
   int A_vals[6] = {0, 0, 0, 0, 0, 0};

   int B_keys[7] = {1, 1, 2, 3, 5, 8, 13};
   int B_vals[7] = {1, 1, 1, 1, 1, 1, 1};

   int keys_result[13];
   int vals_result[13];

   thrust::pair<int*,int*> end = thrust::merge_by_key(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, B_vals, keys_result, vals_result);

   // keys_result = {1, 1, 1, 2, 3, 3, 5, 5, 7, 8, 9, 11, 13}
   // vals_result = {0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0,  0,  1}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a model of
   `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a strict
   weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range of
   keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range of
   keys.

-  **keys_last2** The end of the second input range of keys.

-  **values_first1** The beginning of the first input range of
   values.

-  **values_first2** The beginning of the first input range of
   values.

-  **keys_result** The beginning of the merged output range of
   keys.

-  **values_result** The beginning of the merged output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect to
   `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end of
the output range of keys, and such that `p.second` is the end of
the output range of values.

**See**:

-  merge

-  `sort_by_key`

-  `is_sorted`

**thrust::merge_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Compare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   merge_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     Compare comp);

`merge_by_key` performs a key-value merge. That is,
`merge_by_key` copies elements from `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)` into a single range,
`[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending key order.

At the same time, `merge_by_key` copies elements from the two
associated ranges `[values_first1 + (keys_last1 - keys_first1))`
and `[values_first2 + (keys_last2 - keys_first2))` into a single
range,
`[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending order implied by each
input element’s associated key.

`merge_by_key` is stable, meaning both that the relative order of
elements within each input range is preserved, and that for
equivalent elements in all input key ranges the element from the
first range precedes the element from the second.

The return value is is
`(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
and
`(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`.

This version of `merge_by_key` compares key elements using a
function object `comp`.

The algorithm’s execution is parallelized using `exec`.

The following code snippet demonstrates how to use `merge_by_key`
to compute the merger of two sets of integers sorted in descending
order using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/merge.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {11, 9, 7, 5, 3, 1};
   int A_vals[6] = { 0, 0, 0, 0, 0, 0};

   int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};
   int B_vals[7] = { 1, 1, 1, 1, 1, 1, 1};

   int keys_result[13];
   int vals_result[13];

   thrust::pair<int*,int*> end =
   thrust::merge_by_key(thrust::host,
   A_keys, A_keys + 6,
   B_keys, B_keys + 7,
   A_vals, B_vals,
   keys_result, vals_result,
   thrust::greater<int>());

   // keys_result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}
   // vals_result = { 1,  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a type in
   `OutputIterator1's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a type in
   `OutputIterator1's` set of `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for parallelization.

-  **keys_first1** The beginning of the first input range of
   keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range of
   keys.

-  **keys_last2** The end of the second input range of keys.

-  **values_first1** The beginning of the first input range of
   values.

-  **values_first2** The beginning of the first input range of
   values.

-  **keys_result** The beginning of the merged output range of
   keys.

-  **values_result** The beginning of the merged output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect to
   `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end of
the output range of keys, and such that `p.second` is the end of
the output range of values.

**See**:

-  merge

-  `sort_by_key`

-  `is_sorted`

**thrust::merge_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare> thrust::pair< OutputIterator1, OutputIterator2 >
   merge_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`merge_by_key` performs a key-value merge. That is,
`merge_by_key` copies elements from `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)` into a single range,
`[keys_result, keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending key order.

At the same time, `merge_by_key` copies elements from the two
associated ranges `[values_first1 + (keys_last1 - keys_first1))`
and `[values_first2 + (keys_last2 - keys_first2))` into a single
range,
`[values_result, values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
such that the resulting range is in ascending order implied by each
input element’s associated key.

`merge_by_key` is stable, meaning both that the relative order of
elements within each input range is preserved, and that for
equivalent elements in all input key ranges the element from the
first range precedes the element from the second.

The return value is is
`(keys_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`
and
`(values_result + (keys_last1 - keys_first1) + (keys_last2 - keys_first2))`.

This version of `merge_by_key` compares key elements using a
function object `comp`.

The following code snippet demonstrates how to use `merge_by_key`
to compute the merger of two sets of integers sorted in descending
order.

::

   #include <thrust/merge.h>
   #include <thrust/functional.h>
   ...
   int A_keys[6] = {11, 9, 7, 5, 3, 1};
   int A_vals[6] = { 0, 0, 0, 0, 0, 0};

   int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};
   int B_vals[7] = { 1, 1, 1, 1, 1, 1, 1};

   int keys_result[13];
   int vals_result[13];

   thrust::pair<int*,int*> end = thrust::merge_by_key(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());

   // keys_result = {13, 11, 9, 8, 7, 5, 5, 3, 3, 2, 1, 1, 1}
   // vals_result = { 1,  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a type in
   `OutputIterator1's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a type in
   `OutputIterator1's` set of `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a type
   in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range of
   keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range of
   keys.

-  **keys_last2** The end of the second input range of keys.

-  **values_first1** The beginning of the first input range of
   values.

-  **values_first2** The beginning of the first input range of
   values.

-  **keys_result** The beginning of the merged output range of
   keys.

-  **values_result** The beginning of the merged output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect to
   `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end of
the output range of keys, and such that `p.second` is the end of
the output range of values.

**See**:

-  merge

-  `sort_by_key`

-  `is_sorted`

Prefix Sums
-----------
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::inclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   thrust::inclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename AssociativeOperator>

   __host__ __device__ OutputIterator
   thrust::inclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     AssociativeOperator binary_op);

   template <typename InputIterator,
     typename OutputIterator,
     typename AssociativeOperator>
   OutputIterator
   thrust::inclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     AssociativeOperator binary_op);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   thrust::exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename T>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init);

   template <typename InputIterator,
     typename OutputIterator,
     typename T>
   OutputIterator
   thrust::exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename T,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init,
     AssociativeOperator binary_op);

   template <typename InputIterator,
     typename OutputIterator,
     typename T,
     typename AssociativeOperator>
   OutputIterator
   thrust::exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init,
     AssociativeOperator binary_op);

**thrust::inclusive_scan**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   inclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

`inclusive_scan` computes an inclusive prefix sum operation.
The term ‘inclusive’ means that each result includes the
corresponding input operand in the partial sum. More precisely,
`*first` is assigned to `*result` and the sum of `*first`
and `*(first + 1)` is assigned to `*(result + 1)`, and so
on. This version of `inclusive_scan` assumes plus as the
associative operator.

When the input and output sequences are the same, the scan is
performed in-place.

`inclusive_scan` is similar to `std::partial_sum` in the
STL. The primary difference between the two functions is that
`std::partial_sum` guarantees a serial summation order, while
`inclusive_scan` requires associativity of the binary
operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`inclusive_scan` to compute an in-place prefix sum using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/execution_policy.h>
   ...

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::inclusive_scan(thrust::host, data, data + 6, data); // in-place scan

   // data is now {1, 1, 3, 5, 6, 9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then `x + y` is
   defined. If `T` is `OutputIterator's` `value_type`,
   then `T(0)` is defined.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::inclusive_scan**

::

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   inclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result);

`inclusive_scan` computes an inclusive prefix sum operation.
The term ‘inclusive’ means that each result includes the
corresponding input operand in the partial sum. More precisely,
`*first` is assigned to `*result` and the sum of `*first`
and `*(first + 1)` is assigned to `*(result + 1)`, and so
on. This version of `inclusive_scan` assumes plus as the
associative operator.

When the input and output sequences are the same, the scan is
performed in-place.

`inclusive_scan` is similar to `std::partial_sum` in the
STL. The primary difference between the two functions is that
`std::partial_sum` guarantees a serial summation order, while
`inclusive_scan` requires associativity of the binary
operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`inclusive_scan`

::

   #include <thrust/scan.h>

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::inclusive_scan(data, data + 6, data); // in-place scan

   // data is now {1, 1, 3, 5, 6, 9}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then `x + y` is
   defined. If `T` is `OutputIterator's` `value_type`,
   then `T(0)` is defined.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::inclusive_scan**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   thrust::inclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     AssociativeOperator binary_op);

`inclusive_scan` computes an inclusive prefix sum operation.
The term ‘inclusive’ means that each result includes the
corresponding input operand in the partial sum. When the input
and output sequences are the same, the scan is performed
in-place.

`inclusive_scan` is similar to `std::partial_sum` in the
STL. The primary difference between the two functions is that
`std::partial_sum` guarantees a serial summation order, while
`inclusive_scan` requires associativity of the binary
operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`inclusive_scan` to compute an in-place prefix sum using the
`thrust::host` execution policy for parallelization:

::

   int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   thrust::maximum<int> binary_op;

   thrust::inclusive_scan(thrust::host, data, data + 10, data, binary_op); // in-place scan

   // data is now {-5, 0, 2, 2, 2, 4, 4, 4, 4, 8}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`
   and `OutputIterator's` `value_type` is convertible to
   both `AssociativeOperator's` `first_argument_type` and
   `second_argument_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::inclusive_scan**
::

   template <typename InputIterator,
     typename OutputIterator,
     typename AssociativeOperator>
   OutputIterator
   thrust::inclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     AssociativeOperator binary_op);

`inclusive_scan` computes an inclusive prefix sum operation.
The term ‘inclusive’ means that each result includes the
corresponding input operand in the partial sum. When the input
and output sequences are the same, the scan is performed
in-place.

`inclusive_scan` is similar to `std::partial_sum` in the
STL. The primary difference between the two functions is that
`std::partial_sum` guarantees a serial summation order, while
`inclusive_scan` requires associativity of the binary
operation to parallelize the prefix sum.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`inclusive_scan`

::

   int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   thrust::maximum<int> binary_op;

   thrust::inclusive_scan(data, data + 10, data, binary_op); // in-place scan

   // data is now {-5, 0, 2, 2, 2, 4, 4, 4, 4, 8}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`
   and `OutputIterator's` `value_type` is convertible to
   both `AssociativeOperator's` `first_argument_type` and
   `second_argument_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::exclusive_scan**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

`exclusive_scan` computes an exclusive prefix sum operation.
The term ‘exclusive’ means that each result does not include
the corresponding input operand in the partial sum. More
precisely, `0` is assigned to `*result` and the sum of
`0` and `*first` is assigned to `*(result + 1)`, and so
on. This version of `exclusive_scan` assumes plus as the
associative operator and `0` as the initial value. When the
input and output sequences are the same, the scan is performed
in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`exclusive_scan` to compute an in-place prefix sum using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/execution_policy.h>
   ...

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::exclusive_scan(thrust::host, data, data + 6, data); // in-place scan

   // data is now {0, 1, 1, 3, 5, 6}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then `x + y` is
   defined. If `T` is `OutputIterator's` `value_type`,
   then `T(0)` is defined.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::exclusive_scan**

::

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   thrust::exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result);

`exclusive_scan` computes an exclusive prefix sum operation.
The term ‘exclusive’ means that each result does not include
the corresponding input operand in the partial sum. More
precisely, `0` is assigned to `*result` and the sum of
`0` and `*first` is assigned to `*(result + 1)`, and so
on. This version of `exclusive_scan` assumes plus as the
associative operator and `0` as the initial value. When the
input and output sequences are the same, the scan is performed
in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`exclusive_scan`

::

   #include <thrust/scan.h>

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::exclusive_scan(data, data + 6, data); // in-place scan

   // data is now {0, 1, 1, 3, 5, 6}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then `x + y` is
   defined. If `T` is `OutputIterator's` `value_type`,
   then `T(0)` is defined.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::exclusive_scan**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename T>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init);

`exclusive_scan` computes an exclusive prefix sum operation.
The term ‘exclusive’ means that each result does not include
the corresponding input operand in the partial sum. More
precisely, `init` is assigned to `*result` and the sum of
`init` and `*first` is assigned to `*(result + 1)`, and
so on. This version of `exclusive_scan` assumes plus as the
associative operator but requires an initial value `init`.
When the input and output sequences are the same, the scan is
performed in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`exclusive_scan` to compute an in-place prefix sum using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/execution_policy.h>

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::exclusive_scan(thrust::host, data, data + 6, data, 4); // in-place scan

   // data is now {4, 5, 5, 7, 9, 10}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then `x + y` is
   defined.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **init** The initial value.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::exclusive_scan**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename T>
   OutputIterator
   thrust::exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init);

`exclusive_scan` computes an exclusive prefix sum operation.
The term ‘exclusive’ means that each result does not include
the corresponding input operand in the partial sum. More
precisely, `init` is assigned to `*result` and the sum of
`init` and `*first` is assigned to `*(result + 1)`, and
so on. This version of `exclusive_scan` assumes plus as the
associative operator but requires an initial value `init`.
When the input and output sequences are the same, the scan is
performed in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`exclusive_scan`

::

   #include <thrust/scan.h>

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::exclusive_scan(data, data + 6, data, 4); // in-place scan

   // data is now {4, 5, 5, 7, 9, 10}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then `x + y` is
   defined.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **init** The initial value.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::exclusive_scan**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename T,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init,
     AssociativeOperator binary_op);

`exclusive_scan` computes an exclusive prefix sum operation.
The term ‘exclusive’ means that each result does not include
the corresponding input operand in the partial sum. More
precisely, `init` is assigned to `*result` and the value
`binary_op(init, *first)` is assigned to `*(result + 1)`,
and so on. This version of the function requires both an
associative operator and an initial value `init`. When the
input and output sequences are the same, the scan is performed
in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`exclusive_scan` to compute an in-place prefix sum using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   thrust::maximum<int> binary_op;

   thrust::exclusive_scan(thrust::host, data, data + 10, data, 1, binary_op); // in-place scan

   // data is now {1, 1, 1, 2, 2, 2, 4, 4, 4, 4 }

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`
   and `OutputIterator's` `value_type` is convertible to
   both `AssociativeOperator's` `first_argument_type` and
   `second_argument_type`.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **init** The initial value.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

**thrust::exclusive_scan**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename T,
     typename AssociativeOperator>
   OutputIterator
   thrust::exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     T init,
     AssociativeOperator binary_op);

`exclusive_scan` computes an exclusive prefix sum operation.
The term ‘exclusive’ means that each result does not include
the corresponding input operand in the partial sum. More
precisely, `init` is assigned to `*result` and the value
`binary_op(init, *first)` is assigned to `*(result + 1)`,
and so on. This version of the function requires both an
associative operator and an initial value `init`. When the
input and output sequences are the same, the scan is performed
in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`exclusive_scan`

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>

   int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   thrust::maximum<int> binary_op;

   thrust::exclusive_scan(data, data + 10, data, 1, binary_op); // in-place scan

   // data is now {1, 1, 1, 2, 2, 2, 4, 4, 4, 4 }

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`
   and `OutputIterator's` `value_type` is convertible to
   both `AssociativeOperator's` `first_argument_type` and
   `second_argument_type`.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **init** The initial value.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**: `first` may equal `result` but the range
`[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:
https://en.cppreference.com/w/cpp/algorithm/partial_sum

Segmented Prefix Sums
*********************
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::inclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   thrust::inclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate>
   __host__ __device__ OutputIterator
   thrust::inclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryPredicate binary_pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate>
   OutputIterator
   thrust::inclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   thrust::inclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate,
     typename AssociativeOperator>
   OutputIterator
   thrust::inclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);
   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator> OutputIterator
   thrust::exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T>
   OutputIterator
   thrust::exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,
     typename BinaryPredicate>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init,
     BinaryPredicate binary_pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,
     typename BinaryPredicate>
   OutputIterator
   thrust::exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,
     typename BinaryPredicate,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   thrust::exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init,
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,
     typename BinaryPredicate,
     typename AssociativeOperator>
   OutputIterator
   thrust::exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init,
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

**thrust::inclusive_scan_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   inclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);

`inclusive_scan_by_key` computes an inclusive key-value or
‘segmented’ prefix sum operation. The term ‘inclusive’ means
that each result includes the corresponding input operand in
the partial sum. The term ‘segmented’ means that the partial
sums are broken into distinct segments. In other words, within
each segment a separate inclusive scan operation is computed.
Refer to the code sample below for example usage.

This version of `inclusive_scan_by_key` assumes `equal_to`
as the binary predicate used to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1)` belong to the same segment if
`*i == *(i+1)`, and belong to different segments otherwise.

This version of `inclusive_scan_by_key` assumes `plus` as
the associative operator used to perform the prefix sum. When
the input and output sequences are the same, the scan is
performed in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`inclusive_scan_by_key` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/execution_policy.h>
   ...

   int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

   thrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data); // in-place scan

   // data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  inclusive_scan

-  exclusive_scan_by_key

**thrust::inclusive_scan_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   inclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);

`inclusive_scan_by_key` computes an inclusive key-value or
‘segmented’ prefix sum operation. The term ‘inclusive’ means
that each result includes the corresponding input operand in
the partial sum. The term ‘segmented’ means that the partial
sums are broken into distinct segments. In other words, within
each segment a separate inclusive scan operation is computed.
Refer to the code sample below for example usage.

This version of `inclusive_scan_by_key` assumes `equal_to`
as the binary predicate used to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1)` belong to the same segment if
`*i == *(i+1)`, and belong to different segments otherwise.

This version of `inclusive_scan_by_key` assumes `plus` as
the associative operator used to perform the prefix sum. When
the input and output sequences are the same, the scan is
performed in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`inclusive_scan_by_key`

::

   #include <thrust/scan.h>

   int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

   thrust::inclusive_scan_by_key(keys, keys + 10, data, data); // in-place scan

   // data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

**Function Parameters**:

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  inclusive_scan

-  exclusive_scan_by_key

**thrust::inclusive_scan_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate>
   __host__ __device__ OutputIterator
   inclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryPredicate binary_pred);

`inclusive_scan_by_key` computes an inclusive key-value or
‘segmented’ prefix sum operation. The term ‘inclusive’ means
that each result includes the corresponding input operand in
the partial sum. The term ‘segmented’ means that the partial
sums are broken into distinct segments. In other words, within
each segment a separate inclusive scan operation is computed.
Refer to the code sample below for example usage.

This version of `inclusive_scan_by_key` uses the binary
predicate `pred` to compare adjacent keys. Specifically,
consecutive iterators `i` and `i+1` in the range
`[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

This version of `inclusive_scan_by_key` assumes `plus` as
the associative operator used to perform the prefix sum. When
the input and output sequences are the same, the scan is
performed in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`inclusive_scan_by_key` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

   thrust::equal_to<int> binary_pred;

   thrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data, binary_pred); // in-place scan

   // data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  inclusive_scan

-  exclusive_scan_by_key

**thrust::inclusive_scan_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate>
   OutputIterator
   inclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,  
     InputIterator2 first2,  
     OutputIterator result,
     BinaryPredicate binary_pred);

`inclusive_scan_by_key` computes an inclusive key-value or
‘segmented’ prefix sum operation. The term ‘inclusive’ means
that each result includes the corresponding input operand in
the partial sum. The term ‘segmented’ means that the partial
sums are broken into distinct segments. In other words, within
each segment a separate inclusive scan operation is computed.
Refer to the code sample below for example usage.

This version of `inclusive_scan_by_key` uses the binary
predicate `pred` to compare adjacent keys. Specifically,
consecutive iterators `i` and `i+1` in the range
`[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

This version of `inclusive_scan_by_key` assumes `plus` as
the associative operator used to perform the prefix sum. When
the input and output sequences are the same, the scan is
performed in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`inclusive_scan_by_key`

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>

   int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

   thrust::equal_to<int> binary_pred;

   thrust::inclusive_scan_by_key(keys, keys + 10, data, data, binary_pred); // in-place scan

   // data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  inclusive_scan

-  exclusive_scan_by_key

**thrust::inclusive_scan_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   inclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

`inclusive_scan_by_key` computes an inclusive key-value or
‘segmented’ prefix sum operation. The term ‘inclusive’ means
that each result includes the corresponding input operand in
the partial sum. The term ‘segmented’ means that the partial
sums are broken into distinct segments. In other words, within
each segment a separate inclusive scan operation is computed.
Refer to the code sample below for example usage.

This version of `inclusive_scan_by_key` uses the binary
predicate `pred` to compare adjacent keys. Specifically,
consecutive iterators `i` and `i+1` in the range
`[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

This version of `inclusive_scan_by_key` uses the associative
operator `binary_op` to perform the prefix sum. When the
input and output sequences are the same, the scan is performed
in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`inclusive_scan_by_key` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

   thrust::equal_to<int> binary_pred;
   thrust::plus<int>     binary_op;

   thrust::inclusive_scan_by_key(thrust::host, keys, keys + 10, data, data, binary_pred, binary_op); // in-place scan

   // data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

-  **BinaryPredicate** is a model of `Binary Predicate`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  inclusive_scan

-  exclusive_scan_by_key

**thrust::inclusive_scan_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryPredicate,
     typename AssociativeOperator>
   OutputIterator
   inclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,  
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

`inclusive_scan_by_key` computes an inclusive key-value or
‘segmented’ prefix sum operation. The term ‘inclusive’ means
that each result includes the corresponding input operand in
the partial sum. The term ‘segmented’ means that the partial
sums are broken into distinct segments. In other words, within
each segment a separate inclusive scan operation is computed.
Refer to the code sample below for example usage.

This version of `inclusive_scan_by_key` uses the binary
predicate `pred` to compare adjacent keys. Specifically,
consecutive iterators `i` and `i+1` in the range
`[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

This version of `inclusive_scan_by_key` uses the associative
operator `binary_op` to perform the prefix sum. When the
input and output sequences are the same, the scan is performed
in-place.

The following code snippet demonstrates how to use
`inclusive_scan_by_key`

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>

   int data[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};

   thrust::equal_to<int> binary_pred;
   thrust::plus<int>     binary_op;

   thrust::inclusive_scan_by_key(keys, keys + 10, data, data, binary_pred, binary_op); // in-place scan

   // data is now {1, 2, 3, 1, 2, 1, 1, 2, 3, 4};

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

-  **BinaryPredicate** is a model of `Binary Predicate`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  inclusive_scan

-  exclusive_scan_by_key

**thrust::exclusive_scan_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);

`exclusive_scan_by_key` computes an exclusive segmented
prefix

This version of `exclusive_scan_by_key` uses the value `0`
to initialize the exclusive scan operation.

This version of `exclusive_scan_by_key` assumes `plus` as
the associative operator used to perform the prefix sum. When
the input and output sequences are the same, the scan is
performed in-place.

This version of `exclusive_scan_by_key` assumes `equal_to`
as the binary predicate used to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1` belong to the same segment if
`*i == *(i+1)`, and belong to different segments otherwise.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

Refer to the most general form of `exclusive_scan_by_key` for
additional details.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`exclusive_scan_by_key` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/execution_policy.h>
   ...

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals); // in-place scan

   // vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**See**: exclusive_scan

**thrust::exclusive_scan_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result);

`exclusive_scan_by_key` computes an exclusive segmented
prefix

This version of `exclusive_scan_by_key` uses the value `0`
to initialize the exclusive scan operation.

This version of `exclusive_scan_by_key` assumes `plus` as
the associative operator used to perform the prefix sum. When
the input and output sequences are the same, the scan is
performed in-place.

This version of `exclusive_scan_by_key` assumes `equal_to`
as the binary predicate used to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1` belong to the same segment if
`*i == *(i+1)`, and belong to different segments otherwise.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

Refer to the most general form of `exclusive_scan_by_key` for
additional details.

The following code snippet demonstrates how to use
`exclusive_scan_by_key`.

::

   #include <thrust/scan.h>

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   thrust::exclusive_scan_by_key(key, key + 10, vals, vals); // in-place scan

   // vals is now {0, 1, 2, 0, 1, 0, 0, 1, 2, 3};

**Function Parameters**:

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**See**: exclusive_scan

**thrust::exclusive_scan_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T>
   __host__ __device__ OutputIterator
   exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,  
     InputIterator2 first2,
     OutputIterator result,
     T init);

`exclusive_scan_by_key` computes an exclusive key-value or
‘segmented’ prefix sum operation. The term ‘exclusive’ means
that each result does not include the corresponding input
operand in the partial sum. The term ‘segmented’ means that the
partial sums are broken into distinct segments. In other words,
within each segment a separate exclusive scan operation is
computed. Refer to the code sample below for example usage.

This version of `exclusive_scan_by_key` uses the value
`init` to initialize the exclusive scan operation.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`exclusive_scan_by_key` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   int init = 5;

   thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init); // in-place scan

   // vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **init** The initial of the exclusive sum value.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  exclusive_scan

-  inclusive_scan_by_key

**thrust::exclusive_scan_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T>
   OutputIterator
   exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init);

`exclusive_scan_by_key` computes an exclusive key-value or
‘segmented’ prefix sum operation. The term ‘exclusive’ means
that each result does not include the corresponding input
operand in the partial sum. The term ‘segmented’ means that the
partial sums are broken into distinct segments. In other words,
within each segment a separate exclusive scan operation is
computed. Refer to the code sample below for example usage.

This version of `exclusive_scan_by_key` uses the value
`init` to initialize the exclusive scan operation.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`exclusive_scan_by_key`

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   int init = 5;

   thrust::exclusive_scan_by_key(key, key + 10, vals, vals, init); // in-place scan

   // vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};

**Function Parameters**:

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **init** The initial of the exclusive sum value.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  exclusive_scan

-  inclusive_scan_by_key

**thrust::exclusive_scan_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,  
     typename BinaryPredicate>
    __host__ __device__
    OutputIterator exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
      InputIterator1 first1,  
      InputIterator1 last1,
       InputIterator2 first2,
       OutputIterator result,
       T init,
       BinaryPredicate binary_pred);

`exclusive_scan_by_key` computes an exclusive key-value or
‘segmented’ prefix sum operation. The term ‘exclusive’ means
that each result does not include the corresponding input
operand in the partial sum. The term ‘segmented’ means that the
partial sums are broken into distinct segments. In other words,
within each segment a separate exclusive scan operation is
computed. Refer to the code sample below for example usage.

This version of `exclusive_scan_by_key` uses the value
`init` to initialize the exclusive scan operation.

This version of `exclusive_scan_by_key` uses the binary
predicate `binary_pred` to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`exclusive_scan_by_key` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   int init = 5;

   thrust::equal_to<int> binary_pred;

   thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init, binary_pred); // in-place scan

   // vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **init** The initial of the exclusive sum value.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  exclusive_scan

-  inclusive_scan_by_key

**thrust::exclusive_scan_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,
     typename BinaryPredicate> OutputIterator exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,  
     InputIterator2 first2,  
     OutputIterator result,  
     T init,  
     BinaryPredicate binary_pred);

`exclusive_scan_by_key` computes an exclusive key-value or
‘segmented’ prefix sum operation. The term ‘exclusive’ means
that each result does not include the corresponding input
operand in the partial sum. The term ‘segmented’ means that the
partial sums are broken into distinct segments. In other words,
within each segment a separate exclusive scan operation is
computed. Refer to the code sample below for example usage.

This version of `exclusive_scan_by_key` uses the value
`init` to initialize the exclusive scan operation.

This version of `exclusive_scan_by_key` uses the binary
predicate `binary_pred` to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`exclusive_scan_by_key`

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   int init = 5;

   thrust::equal_to<int> binary_pred;

   thrust::exclusive_scan_by_key(key, key + 10, vals, vals, init, binary_pred); // in-place scan

   // vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};

**Function Parameters**:

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **init** The initial of the exclusive sum value.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  exclusive_scan

-  inclusive_scan_by_key

**thrust::exclusive_scan_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,
     typename BinaryPredicate,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   exclusive_scan_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init,
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

`exclusive_scan_by_key` computes an exclusive key-value or
‘segmented’ prefix sum operation. The term ‘exclusive’ means
that each result does not include the corresponding input
operand in the partial sum. The term ‘segmented’ means that the
partial sums are broken into distinct segments. In other words,
within each segment a separate exclusive scan operation is
computed. Refer to the code sample below for example usage.

This version of `exclusive_scan_by_key` uses the value
`init` to initialize the exclusive scan operation.

This version of `exclusive_scan_by_key` uses the binary
predicate `binary_pred` to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

This version of `exclusive_scan_by_key` uses the associative
operator `binary_op` to perform the prefix sum. When the
input and output sequences are the same, the scan is performed
in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`exclusive_scan_by_key` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   int init = 5;

   thrust::equal_to<int> binary_pred;
   thrust::plus<int>     binary_op;

   thrust::exclusive_scan_by_key(thrust::host, key, key + 10, vals, vals, init, binary_pred, binary_op); // in-place scan

   // vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **init** The initial of the exclusive sum value.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  exclusive_scan

-  inclusive_scan_by_key

**thrust::exclusive_scan_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename T,
     typename BinaryPredicate,
     typename AssociativeOperator>
   OutputIterator exclusive_scan_by_key(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     T init,
     BinaryPredicate binary_pred,
     AssociativeOperator binary_op);

`exclusive_scan_by_key` computes an exclusive key-value or
‘segmented’ prefix sum operation. The term ‘exclusive’ means
that each result does not include the corresponding input
operand in the partial sum. The term ‘segmented’ means that the
partial sums are broken into distinct segments. In other words,
within each segment a separate exclusive scan operation is
computed. Refer to the code sample below for example usage.

This version of `exclusive_scan_by_key` uses the value
`init` to initialize the exclusive scan operation.

This version of `exclusive_scan_by_key` uses the binary
predicate `binary_pred` to compare adjacent keys.
Specifically, consecutive iterators `i` and `i+1` in the
range `[first1, last1)` belong to the same segment if
`binary_pred(*i, *(i+1))` is true, and belong to different
segments otherwise.

This version of `exclusive_scan_by_key` uses the associative
operator `binary_op` to perform the prefix sum. When the
input and output sequences are the same, the scan is performed
in-place.

Results are not deterministic for pseudo-associative operators
(e.g., addition of floating-point types). Results for
pseudo-associative operators may vary from run to run.

The following code snippet demonstrates how to use
`exclusive_scan_by_key`

::

   #include <thrust/scan.h>
   #include <thrust/functional.h>

   int keys[10] = {0, 0, 0, 1, 1, 2, 3, 3, 3, 3};
   int vals[10] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

   int init = 5;

   thrust::equal_to<int> binary_pred;
   thrust::plus<int>     binary_op;

   thrust::exclusive_scan_by_key(key, key + 10, vals, vals, init, binary_pred, binary_op); // in-place scan

   // vals is now {5, 6, 7, 5, 6, 5, 5, 6, 7, 8};

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `OutputIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`,
   and if `x` and `y` are objects of
   `OutputIterator's` `value_type`, then
   `binary_op(x,y)` is defined.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first1** The beginning of the key sequence.

-  **last1** The end of the key sequence.

-  **first2** The beginning of the input value sequence.

-  **result** The beginning of the output value sequence.

-  **init** The initial of the exclusive sum value.

-  **binary_pred** The binary predicate used to determine
   equality of keys.

-  **binary_op** The associatve operator used to ‘sum’
   values.

**Preconditions**:

-  `first1` may equal `result` but the range
   `[first1, last1)` and the range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

-  `first2` may equal `result` but the range
   `[first2, first2 + (last1 - first1)` and range
   `[result, result + (last1 - first1))` shall not overlap
   otherwise.

**Returns**: The end of the output sequence.

**See**:

-  exclusive_scan

-  inclusive_scan_by_key

Transformed Prefix Sums
***********************
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   thrust::transform_inclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction unary_op,
     AssociativeOperator binary_op);

   template <typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction,
     typename AssociativeOperator>
   OutputIterator
   thrust::transform_inclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction unary_op,  
     AssociativeOperator binary_op);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction,  
     typename T,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   thrust::transform_exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,  
     OutputIterator result,
     UnaryFunction unary_op,  
     T init,
     AssociativeOperator binary_op);

   template <typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction,
     typename T,
     typename AssociativeOperator>
   OutputIterator
   thrust::transform_exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,  
     UnaryFunction unary_op,
     T init,
     AssociativeOperator binary_op);

**thrust::transform_inclusive_scan**

::

   template <typename DerivedPolicy,
     typename InputIterator,  
     typename OutputIterator,
     typename UnaryFunction,  
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   transform_inclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,  
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction unary_op,  
     AssociativeOperator binary_op);

`transform_inclusive_scan` fuses the `transform` and
`inclusive_scan` operations. `transform_inclusive_scan` is
equivalent to performing a tranformation defined by
`unary_op` into a temporary sequence and then performing an
`inclusive_scan` on the tranformed sequence. In most cases,
fusing these two operations together is more efficient, since
fewer memory reads and writes are required. In
`transform_inclusive_scan`, `unary_op(*first)` is assigned
to `*result` and the result of
`binary_op(unary_op(*first), unary_op(*(first + 1)))` is
assigned to `*(result + 1)`, and so on. The transform scan
operation is permitted to be in-place.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform_inclusive_scan` using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/transform_scan.h>
   #include <thrust/execution_policy.h>
   ...

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::negate<int> unary_op;
   thrust::plus<int> binary_op;

   thrust::transform_inclusive_scan(thrust::host, data, data + 6, data, unary_op, binary_op); // in-place scan

   // data is now {-1, -1, -3, -5, -6, -9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `unary_op's` input type.

-  **OutputIterator** is a model of `Output Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and accepts inputs of `InputIterator's` `value_type`.
   `UnaryFunction's` result_type is convertable to
   `OutputIterator's` `value_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **unary_op** The function used to tranform the input
   sequence.

-  **binary_op** The associatve operator used to ‘sum’
   transformed values.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:

-  `transform`

-  `inclusive_scan`

**thrust::transform_inclusive_scan**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction,
     typename AssociativeOperator> OutputIterator
   transform_inclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,  
     UnaryFunction unary_op,
     AssociativeOperator binary_op);

`transform_inclusive_scan` fuses the `transform` and
`inclusive_scan` operations. `transform_inclusive_scan` is
equivalent to performing a tranformation defined by
`unary_op` into a temporary sequence and then performing an
`inclusive_scan` on the tranformed sequence. In most cases,
fusing these two operations together is more efficient, since
fewer memory reads and writes are required. In
`transform_inclusive_scan`, `unary_op(*first)` is assigned
to `*result` and the result of
`binary_op(unary_op(*first), unary_op(*(first + 1)))` is
assigned to `*(result + 1)`, and so on. The transform scan
operation is permitted to be in-place.

The following code snippet demonstrates how to use
`transform_inclusive_scan`

::

   #include <thrust/transform_scan.h>

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::negate<int> unary_op;
   thrust::plus<int> binary_op;

   thrust::transform_inclusive_scan(data, data + 6, data, unary_op, binary_op); // in-place scan

   // data is now {-1, -1, -3, -5, -6, -9}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `unary_op's` input type.

-  **OutputIterator** is a model of `Output Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and accepts inputs of `InputIterator's` `value_type`.
   `UnaryFunction's` result_type is convertable to
   `OutputIterator's` `value_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **unary_op** The function used to tranform the input
   sequence.

-  **binary_op** The associatve operator used to ‘sum’
   transformed values.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:

-  `transform`

-  `inclusive_scan`

**thrust::transform_exclusive_scan**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction,
     typename T,
     typename AssociativeOperator>
   __host__ __device__ OutputIterator
   transform_exclusive_scan(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction unary_op,
     T init,
     AssociativeOperator binary_op);

`transform_exclusive_scan` fuses the `transform` and
`exclusive_scan` operations. `transform_exclusive_scan` is
equivalent to performing a tranformation defined by
`unary_op` into a temporary sequence and then performing an
`exclusive_scan` on the tranformed sequence. In most cases,
fusing these two operations together is more efficient, since
fewer memory reads and writes are required. In
`transform_exclusive_scan`, `init` is assigned to
`*result` and the result of
`binary_op(init, unary_op(*first))` is assigned to
`*(result + 1)`, and so on. The transform scan operation is
permitted to be in-place.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform_exclusive_scan` using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/transform_scan.h>
   #include <thrust/execution_policy.h>
   ...

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::negate<int> unary_op;
   thrust::plus<int> binary_op;

   thrust::transform_exclusive_scan(thrust::host, data, data + 6, data, unary_op, 4, binary_op); // in-place scan

   // data is now {4, 3, 3, 1, -1, -2}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `unary_op's` input type.

-  **OutputIterator** is a model of `Output Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and accepts inputs of `InputIterator's` `value_type`.
   `UnaryFunction's` result_type is convertable to
   `OutputIterator's` `value_type`.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **unary_op** The function used to tranform the input
   sequence.

-  **init** The initial value of the `exclusive_scan`

-  **binary_op** The associatve operator used to ‘sum’
   transformed values.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:

-  `transform`

-  `exclusive_scan`

**thrust::transform_exclusive_scan**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction,
     typename T,
     typename AssociativeOperator> OutputIterator transform_exclusive_scan(InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction unary_op,
     T init,
     AssociativeOperator binary_op);

`transform_exclusive_scan` fuses the `transform` and
`exclusive_scan` operations. `transform_exclusive_scan` is
equivalent to performing a tranformation defined by
`unary_op` into a temporary sequence and then performing an
`exclusive_scan` on the tranformed sequence. In most cases,
fusing these two operations together is more efficient, since
fewer memory reads and writes are required. In
`transform_exclusive_scan`, `init` is assigned to
`*result` and the result of
`binary_op(init, unary_op(*first))` is assigned to
`*(result + 1)`, and so on. The transform scan operation is
permitted to be in-place.

The following code snippet demonstrates how to use
`transform_exclusive_scan`

::

   #include <thrust/transform_scan.h>

   int data[6] = {1, 0, 2, 2, 1, 3};

   thrust::negate<int> unary_op;
   thrust::plus<int> binary_op;

   thrust::transform_exclusive_scan(data, data + 6, data, unary_op, 4, binary_op); // in-place scan

   // data is now {4, 3, 3, 1, -1, -2}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `unary_op's` input type.

-  **OutputIterator** is a model of `Output Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and accepts inputs of `InputIterator's` `value_type`.
   `UnaryFunction's` result_type is convertable to
   `OutputIterator's` `value_type`.

-  **T** is convertible to
   `OutputIterator's` `value_type`.

-  **AssociativeOperator** is a model of `Binary Function`
   and `AssociativeOperator's` `result_type` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **unary_op** The function used to tranform the input
   sequence.

-  **init** The initial value of the `exclusive_scan`

-  **binary_op** The associatve operator used to ‘sum’
   transformed values.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` and the range
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: The end of the output sequence.

**See**:

-  `transform`

-  `exclusive_scan`

Reductions
----------
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator>
   __host__ __device__ thrust::iterator_traits< InputIterator >::value_type
   thrust::reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last);

   template <typename InputIterator>
   thrust::iterator_traits< InputIterator >::value_type
   thrust::reduce(InputIterator first,
     InputIterator last);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename T>
   __host__ __device__ T
   thrust::reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,  
     InputIterator first,
     InputIterator last,  
     T init);

   template <typename InputIterator,
     typename T>
   T
   thrust::reduce(InputIterator first,
     InputIterator last,
     T init);

   template <typename DerivedPolicy,  
     typename InputIterator,
     typename T,
     typename BinaryFunction>
   __host__ __device__
   T
   thrust::reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     T init,  
     BinaryFunction binary_op);

   template <typename InputIterator,
     typename T,
     typename BinaryFunction>
   T
   thrust::reduce(InputIterator first,
     InputIterator last,  
     T init,  
     BinaryFunction binary_op);

   template <typename DerivedPolicy,  
     typename InputIterator1,
     typename InputIterator2,  
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::reduce_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,  
     OutputIterator1 keys_output,
     OutputIterator2 values_output);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::reduce_by_key(InputIterator1 keys_first,
     InputIterator1 keys_last,  
     InputIterator2 values_first,  
     OutputIterator1 keys_output,
     OutputIterator2 values_output);

   template <typename DerivedPolicy,  
     typename InputIterator1,  
     typename InputIterator2,  
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::reduce_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output,
     BinaryPredicate binary_pred);

   template <typename InputIterator1,
     typename InputIterator2,  
     typename OutputIterator1,
     typename OutputIterator2,  
     typename BinaryPredicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::reduce_by_key(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename InputIterator1,  
     typename InputIterator2,  
     typename OutputIterator1,  
     typename OutputIterator2,  
     typename BinaryPredicate,  
     typename BinaryFunction>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::reduce_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,  
     InputIterator1 keys_first,
     InputIterator1 keys_last,  
     InputIterator2 values_first,
     OutputIterator1 keys_output,  
     OutputIterator2 values_output,
     BinaryPredicate binary_pred,  
     BinaryFunction binary_op);

   template <typename InputIterator1,  
     typename InputIterator2,   
     typename OutputIterator1,  
     typename OutputIterator2,
     typename BinaryPredicate,  
     typename BinaryFunction>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::reduce_by_key(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output,  
     BinaryPredicate binary_pred,
     BinaryFunction binary_op);

**thrust::reduce**

::

   template <typename DerivedPolicy,  
     typename InputIterator>
   __host__ __device__ thrust::iterator_traits< InputIterator >::value_type
   reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last);

`reduce` is a generalization of summation: it computes the
sum (or some other binary operation) of all the elements in the
range `[first, last)`. This version of `reduce` uses `0`
as the initial value of the reduction. `reduce` is similar to
the C++ Standard Template Library’s `std::accumulate`. The
primary difference between the two functions is that
`std::accumulate` guarantees the order of summation, while
`reduce` requires associativity of the binary operation to
parallelize the reduction.

Note that `reduce` also assumes that the binary reduction
operator (in this case operator+) is commutative. If the
reduction operator is not commutative then `thrust::reduce`
should not be used. Instead, one could use `inclusive_scan`
(which does not require commutativity) and select the last
element of the output array.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `reduce`
to compute the sum of a sequence of integers using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/reduce.h>
   #include <thrust/execution_policy.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int result = thrust::reduce(thrust::host, data, data + 6);

   // result == 9

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and if `x` and `y` are objects of
   `InputIterator's` `value_type`, then `x + y` is
   defined and is convertible to
   `InputIterator's` `value_type`. If `T` is
   `InputIterator's` `value_type`, then `T(0)` is
   defined.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: The result of the reduction.

**See**: https://en.cppreference.com/w/cpp/algorithm/accumulate

**thrust::reduce**

::

   template <typename InputIterator>
   thrust::iterator_traits< InputIterator >::value_type
   reduce(InputIterator first,
     InputIterator last);

`reduce` is a generalization of summation: it computes the
sum (or some other binary operation) of all the elements in the
range `[first, last)`. This version of `reduce` uses `0`
as the initial value of the reduction. `reduce` is similar to
the C++ Standard Template Library’s `std::accumulate`. The
primary difference between the two functions is that
`std::accumulate` guarantees the order of summation, while
`reduce` requires associativity of the binary operation to
parallelize the reduction.

Note that `reduce` also assumes that the binary reduction
operator (in this case operator+) is commutative. If the
reduction operator is not commutative then `thrust::reduce`
should not be used. Instead, one could use `inclusive_scan`
(which does not require commutativity) and select the last
element of the output array.

The following code snippet demonstrates how to use `reduce`
to compute the sum of a sequence of integers.

::

   #include <thrust/reduce.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int result = thrust::reduce(data, data + 6);

   // result == 9

**Template Parameters**: **InputIterator**: is a model of
`Input Iterator`
and if `x` and `y` are objects of
`InputIterator's` `value_type`, then `x + y` is defined
and is convertible to `InputIterator's` `value_type`. If
`T` is `InputIterator's` `value_type`, then `T(0)` is
defined.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: The result of the reduction.

**See**: https://en.cppreference.com/w/cpp/algorithm/accumulate

**thrust::reduce**

::

   template <typename DerivedPolicy,  
     typename InputIterator,
     typename T>
    __host__ __device__ T
    reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,  
    InputIterator first,  
    InputIterator last,  
    T init);

`reduce` is a generalization of summation: it computes the
sum (or some other binary operation) of all the elements in the
range `[first, last)`. This version of `reduce` uses
`init` as the initial value of the reduction. `reduce` is
similar to the C++ Standard Template Library’s
`std::accumulate`. The primary difference between the two
functions is that `std::accumulate` guarantees the order of
summation, while `reduce` requires associativity of the
binary operation to parallelize the reduction.

Note that `reduce` also assumes that the binary reduction
operator (in this case operator+) is commutative. If the
reduction operator is not commutative then `thrust::reduce`
should not be used. Instead, one could use `inclusive_scan`
(which does not require commutativity) and select the last
element of the output array.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `reduce`
to compute the sum of a sequence of integers including an
intialization value using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/reduce.h>
   #include <thrust/execution_policy.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int result = thrust::reduce(thrust::host, data, data + 6, 1);

   // result == 10

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and if `x` and `y` are objects of
   `InputIterator's` `value_type`, then `x + y` is
   defined and is convertible to `T`.

-  **T** is convertible to
   `InputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **init** The initial value.

**Returns**: The result of the reduction.

**See**: https://en.cppreference.com/w/cpp/algorithm/accumulate

**thrust::reduce**

::

   template <typename InputIterator,
     typename T>
   T
   reduce(InputIterator first,
     InputIterator last,
     T init);

`reduce` is a generalization of summation: it computes the
sum (or some other binary operation) of all the elements in the
range `[first, last)`. This version of `reduce` uses
`init` as the initial value of the reduction. `reduce` is
similar to the C++ Standard Template Library’s
`std::accumulate`. The primary difference between the two
functions is that `std::accumulate` guarantees the order of
summation, while `reduce` requires associativity of the
binary operation to parallelize the reduction.

Note that `reduce` also assumes that the binary reduction
operator (in this case operator+) is commutative. If the
reduction operator is not commutative then `thrust::reduce`
should not be used. Instead, one could use `inclusive_scan`
(which does not require commutativity) and select the last
element of the output array.

The following code snippet demonstrates how to use `reduce`
to compute the sum of a sequence of integers including an
intialization value.

::

   #include <thrust/reduce.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int result = thrust::reduce(data, data + 6, 1);

   // result == 10

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and if `x` and `y` are objects of
   `InputIterator's` `value_type`, then `x + y` is
   defined and is convertible to `T`.

-  **T** is convertible to
   `InputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **init** The initial value.

**Returns**: The result of the reduction.

**See**: https://en.cppreference.com/w/cpp/algorithm/accumulate

**thrust::reduce**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename T,
     typename BinaryFunction>
   __host__ __device__ T
   reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     T init,
     BinaryFunction binary_op);

`reduce` is a generalization of summation: it computes the
sum (or some other binary operation) of all the elements in the
range `[first, last)`. This version of `reduce` uses
`init` as the initial value of the reduction and
`binary_op` as the binary function used for summation.
`reduce` is similar to the C++ Standard Template Library’s
`std::accumulate`. The primary difference between the two
functions is that `std::accumulate` guarantees the order of
summation, while `reduce` requires associativity of
`binary_op` to parallelize the reduction.

Note that `reduce` also assumes that the binary reduction
operator (in this case `binary_op`) is commutative. If the
reduction operator is not commutative then `thrust::reduce`
should not be used. Instead, one could use `inclusive_scan`
(which does not require commutativity) and select the last
element of the output array.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `reduce`
to compute the maximum value of a sequence of integers using
the `thrust::host` execution policy for parallelization:

::

   #include <thrust/reduce.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int result = thrust::reduce(thrust::host,
      data, data + 6,
      -1,
      thrust::maximum<int>());
   // result == 3

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `T`.

-  **T** is a model of
   `Assignable`,
   and is convertible to
   `BinaryFunction's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryFunction** is a model of `Binary Function`,
   and `BinaryFunction's` `result_type` is convertible to
   `OutputType`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **init** The initial value.

-  **binary_op** The binary function used to ‘sum’ values.

**Returns**: The result of the reduction.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/accumulate

-  transform_reduce

**thrust::reduce**

::

   template <typename InputIterator,
     typename T,
     typename BinaryFunction>
   T
   reduce(InputIterator first,
     InputIterator last,
     T init,
     BinaryFunction binary_op);

`reduce` is a generalization of summation: it computes the
sum (or some other binary operation) of all the elements in the
range `[first, last)`. This version of `reduce` uses
`init` as the initial value of the reduction and
`binary_op` as the binary function used for summation.
`reduce` is similar to the C++ Standard Template Library’s
`std::accumulate`. The primary difference between the two
functions is that `std::accumulate` guarantees the order of
summation, while `reduce` requires associativity of
`binary_op` to parallelize the reduction.

Note that `reduce` also assumes that the binary reduction
operator (in this case `binary_op`) is commutative. If the
reduction operator is not commutative then `thrust::reduce`
should not be used. Instead, one could use `inclusive_scan`
(which does not require commutativity) and select the last
element of the output array.

The following code snippet demonstrates how to use `reduce`
to compute the maximum value of a sequence of integers.

::

   #include <thrust/reduce.h>
   #include <thrust/functional.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int result = thrust::reduce(data, data + 6,
      -1,
      thrust::maximum<int>());
   // result == 3

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `T`.

-  **T** is a model of
   `Assignable`,
   and is convertible to
   `BinaryFunction's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryFunction** is a model of `Binary Function`,
   and `BinaryFunction's` `result_type` is convertible to
   `OutputType`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **init** The initial value.

-  **binary_op** The binary function used to ‘sum’ values.

**Returns**: The result of the reduction.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/accumulate

-  transform_reduce

**thrust::reduce_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   reduce_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output);

`reduce_by_key` is a generalization of `reduce` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`reduce_by_key` copies the first element of the group to the
`keys_output`. The corresponding values in the range are
reduced using the `plus` and the result copied to
`values_output`.

This version of `reduce_by_key` uses the function object
`equal_to` to test for equality and `plus` to reduce values
with equal keys.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`reduce_by_key` to compact a sequence of key/value pairs and
sum values with equal keys using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/reduce.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   new_end = thrust::reduce_by_key(thrust::host, A, A + N, B, C, D);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_output** The beginning of the output key range.

-  **values_output** The beginning of the output value
   range.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_output, keys_output_last)` and
`[values_output, values_output_last)`.

**See**:

-  reduce

-  unique_copy

-  unique_by_key

-  unique_by_key_copy

**thrust::reduce_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   reduce_by_key(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output);

`reduce_by_key` is a generalization of `reduce` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`reduce_by_key` copies the first element of the group to the
`keys_output`. The corresponding values in the range are
reduced using the `plus` and the result copied to
`values_output`.

This version of `reduce_by_key` uses the function object
`equal_to` to test for equality and `plus` to reduce values
with equal keys.

The following code snippet demonstrates how to use
`reduce_by_key` to compact a sequence of key/value pairs and
sum values with equal keys.

::

   #include <thrust/reduce.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   new_end = thrust::reduce_by_key(A, A + N, B, C, D);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

**Function Parameters**:

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_output** The beginning of the output key range.

-  **values_output** The beginning of the output value
   range.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_output, keys_output_last)` and
`[values_output, values_output_last)`.

**See**:

-  reduce

-  unique_copy

-  unique_by_key

-  unique_by_key_copy

**thrust::reduce_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   reduce_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output,
     BinaryPredicate binary_pred);

`reduce_by_key` is a generalization of `reduce` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`reduce_by_key` copies the first element of the group to the
`keys_output`. The corresponding values in the range are
reduced using the `plus` and the result copied to
`values_output`.

This version of `reduce_by_key` uses the function object
`binary_pred` to test for equality and `plus` to reduce
values with equal keys.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`reduce_by_key` to compact a sequence of key/value pairs and
sum values with equal keys using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/reduce.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   new_end = thrust::reduce_by_key(thrust::host, A, A + N, B, C, D, binary_pred);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_output** The beginning of the output key range.

-  **values_output** The beginning of the output value
   range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_output, keys_output_last)` and
`[values_output, values_output_last)`.

**See**:

-  reduce

-  unique_copy

-  unique_by_key

-  unique_by_key_copy

**thrust::reduce_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   reduce_by_key(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output,
     BinaryPredicate binary_pred);

`reduce_by_key` is a generalization of `reduce` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`reduce_by_key` copies the first element of the group to the
`keys_output`. The corresponding values in the range are
reduced using the `plus` and the result copied to
`values_output`.

This version of `reduce_by_key` uses the function object
`binary_pred` to test for equality and `plus` to reduce
values with equal keys.

The following code snippet demonstrates how to use
`reduce_by_key` to compact a sequence of key/value pairs and
sum values with equal keys.

::

   #include <thrust/reduce.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   new_end = thrust::reduce_by_key(A, A + N, B, C, D, binary_pred);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_output** The beginning of the output key range.

-  **values_output** The beginning of the output value
   range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_output, keys_output_last)` and
`[values_output, values_output_last)`.

**See**:

-  reduce

-  unique_copy

-  unique_by_key

-  unique_by_key_copy

**thrust::reduce_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate,
     typename BinaryFunction>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   reduce_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output,
     BinaryPredicate binary_pred,
     BinaryFunction binary_op);

`reduce_by_key` is a generalization of `reduce` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`reduce_by_key` copies the first element of the group to the
`keys_output`. The corresponding values in the range are
reduced using the `BinaryFunction` `binary_op` and the
result copied to `values_output`. Specifically, if
consecutive key iterators `i` and `(i + 1)` are such that
`binary_pred(*i, *(i+1))` is `true`, then the corresponding
values are reduced to a single value with `binary_op`.

This version of `reduce_by_key` uses the function object
`binary_pred` to test for equality and `binary_op` to
reduce values with equal keys.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`reduce_by_key` to compact a sequence of key/value pairs and
sum values with equal keys using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/reduce.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   thrust::plus<int> binary_op;
   new_end = thrust::reduce_by_key(thrust::host, A, A + N, B, C, D, binary_pred, binary_op);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

-  **BinaryFunction** is a model of `Binary Function`
   and `BinaryFunction's` `result_type` is convertible to
   `OutputIterator2's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_output** The beginning of the output key range.

-  **values_output** The beginning of the output value
   range.

-  **binary_pred** The binary predicate used to determine
   equality.

-  **binary_op** The binary function used to accumulate
   values.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_output, keys_output_last)` and
`[values_output, values_output_last)`.

**See**:

-  reduce

-  unique_copy

-  unique_by_key

-  unique_by_key_copy

**thrust::reduce_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate,
     typename BinaryFunction>
   thrust::pair< OutputIterator1, OutputIterator2 >
   reduce_by_key(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_output,
     OutputIterator2 values_output,
     BinaryPredicate binary_pred,
     BinaryFunction binary_op);

`reduce_by_key` is a generalization of `reduce` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`reduce_by_key` copies the first element of the group to the
`keys_output`. The corresponding values in the range are
reduced using the `BinaryFunction` `binary_op` and the
result copied to `values_output`. Specifically, if
consecutive key iterators `i` and `(i + 1)` are such that
`binary_pred(*i, *(i+1))` is `true`, then the corresponding
values are reduced to a single value with `binary_op`.

This version of `reduce_by_key` uses the function object
`binary_pred` to test for equality and `binary_op` to
reduce values with equal keys.

The following code snippet demonstrates how to use
`reduce_by_key` to compact a sequence of key/value pairs and
sum values with equal keys.

::

   #include <thrust/reduce.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   thrust::plus<int> binary_op;
   new_end = thrust::reduce_by_key(A, A + N, B, C, D, binary_pred, binary_op);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 21, 9, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

-  **BinaryFunction** is a model of `Binary Function`
   and `BinaryFunction's` `result_type` is convertible to
   `OutputIterator2's` `value_type`.

**Function Parameters**:

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_output** The beginning of the output key range.

-  **values_output** The beginning of the output value
   range.

-  **binary_pred** The binary predicate used to determine
   equality.

-  **binary_op** The binary function used to accumulate
   values.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_output, keys_output_last)` and
`[values_output, values_output_last)`.

**See**:

-  reduce

-  unique_copy

-  unique_by_key

-  unique_by_key_copy

Comparisons
***********
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2>
   __host__ __device__ bool
   thrust::equal(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);

   template <typename InputIterator1,
     typename InputIterator2>
   bool
   thrust::equal(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename BinaryPredicate>
   __host__ __device__ bool
   thrust::equal(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     BinaryPredicate binary_pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename BinaryPredicate>
   bool
   thrust::equal(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     BinaryPredicate binary_pred);

**thrust::equal**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2>
   __host__ __device__ bool
   equal(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);

`equal` returns `true` if the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
are identical when compared element-by-element, and otherwise
returns `false`.

This version of `equal` returns `true` if and only if for
every iterator `i` in `[first1, last1)`,
`*i == *(first2 + (i - first1))`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `equal` to
test two ranges for equality using the `thrust::host`
execution policy:

::

   #include <thrust/equal.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[7] = {3, 1, 4, 1, 5, 9, 3};
   int A2[7] = {3, 1, 4, 2, 8, 5, 7};
   ...
   bool result = thrust::equal(thrust::host, A1, A1 + 7, A2);

   // result == false

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator1's` `value_type` is a model of
   `Equality Comparable`,
   and `InputIterator1's` `value_type` can be compared for
   equality with `InputIterator2's` `value_type`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is a model of
   `Equality Comparable`,
   and `InputIterator2's` `value_type` can be compared for
   equality with `InputIterator1's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

**Returns**: `true`, if the sequences are equal; `false`,
otherwise.

**See**: https://en.cppreference.com/w/cpp/algorithm/equal

**thrust::equal**

::

   template <typename InputIterator1,
     typename InputIterator2>
   bool
   equal(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);

`equal` returns `true` if the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
are identical when compared element-by-element, and otherwise
returns `false`.

This version of `equal` returns `true` if and only if for
every iterator `i` in `[first1, last1)`,
`*i == *(first2 + (i - first1))`.

The following code snippet demonstrates how to use `equal` to
test two ranges for equality.

::

   #include <thrust/equal.h>
   ...
   int A1[7] = {3, 1, 4, 1, 5, 9, 3};
   int A2[7] = {3, 1, 4, 2, 8, 5, 7};
   ...
   bool result = thrust::equal(A1, A1 + 7, A2);

   // result == false

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator1's` `value_type` is a model of
   `Equality Comparable`,
   and `InputIterator1's` `value_type` can be compared for
   equality with `InputIterator2's` `value_type`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is a model of
   `Equality Comparable`,
   and `InputIterator2's` `value_type` can be compared for
   equality with `InputIterator1's` `value_type`.

**Function Parameters**:

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

**Returns**: `true`, if the sequences are equal; `false`,
otherwise.

**See**: https://en.cppreference.com/w/cpp/algorithm/equal

**thrust::equal**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename BinaryPredicate>
   __host__ __device__ bool
   equal(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     BinaryPredicate binary_pred);

`equal` returns `true` if the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
are identical when compared element-by-element, and otherwise
returns `false`.

This version of `equal` returns `true` if and only if for
every iterator `i` in `[first1, last1)`,
`binary_pred(*i, *(first2 + (i - first1)))` is `true`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `equal` to
compare the elements in two ranges modulo 2 using the
`thrust::host` execution policy.

::

   #include <thrust/equal.h>
   #include <thrust/execution_policy.h>
   ...

   struct compare_modulo_two
   {
   __host__ __device__
   bool operator()(int x, int y) const
   {
      return (x % 2) == (y % 2);
   }
   };
   ...
   int x[6] = {0, 2, 4, 6, 8, 10};
   int y[6] = {1, 3, 5, 7, 9, 11};

   bool result = thrust::equal(x, x + 6, y, compare_modulo_two());

   // result is false

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator1's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **binary_pred** Binary predicate used to test element
   equality.

**Returns**: `true`, if the sequences are equal; `false`,
otherwise.

**See**: https://en.cppreference.com/w/cpp/algorithm/equal

**thrust::equal**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename BinaryPredicate>
   bool
   equal(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     BinaryPredicate binary_pred);

`equal` returns `true` if the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
are identical when compared element-by-element, and otherwise
returns `false`.

This version of `equal` returns `true` if and only if for
every iterator `i` in `[first1, last1)`,
`binary_pred(*i, *(first2 + (i - first1)))` is `true`.

The following code snippet demonstrates how to use `equal` to
compare the elements in two ranges modulo 2.

::

   #include <thrust/equal.h>

   struct compare_modulo_two
   {
   __host__ __device__
   bool operator()(int x, int y) const
   {
      return (x % 2) == (y % 2);
   }
   };
   ...
   int x[6] = {0, 2, 4, 6, 8, 10};
   int y[6] = {1, 3, 5, 7, 9, 11};

   bool result = thrust::equal(x, x + 5, y, compare_modulo_two());

   // result is true

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator1's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **binary_pred** Binary predicate used to test element
   equality.

**Returns**: `true`, if the sequences are equal; `false`,
otherwise.

**See**: https://en.cppreference.com/w/cpp/algorithm/equal

Counting
********
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename EqualityComparable>
   __host__ __device__ thrust::iterator_traits< InputIterator >::difference_type
   thrust::count(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     const EqualityComparable & value);

   template <typename InputIterator,
     typename EqualityComparable>
   thrust::iterator_traits< InputIterator >::difference_type
   thrust::count(InputIterator first,
     InputIterator last,
     const EqualityComparable & value);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ thrust::iterator_traits< InputIterator >::difference_type
   thrust::count_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename InputIterator,
     typename Predicate>
   thrust::iterator_traits< InputIterator >::difference_type
   thrust::count_if(InputIterator first,
     InputIterator last,
     Predicate pred);

**thrust::count**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename EqualityComparable>
   __host__ __device__ thrust::iterator_traits< InputIterator >::difference_type
   count(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     const EqualityComparable & value);

`count` finds the number of elements in `[first,last)` that
are equal to `value`. More precisely, `count` returns the
number of iterators `i` in `[first, last)` such that
`*i == value`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `count` to
count the number of instances in a range of a value of interest
using the `thrust::device` execution policy:

::

   #include <thrust/count.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   // put 3 1s in a device_vector
   thrust::device_vector<int> vec(5,0);
   vec[1] = 1;
   vec[3] = 1;
   vec[4] = 1;

   // count the 1s
   int result = thrust::count(thrust::device, vec.begin(), vec.end(), 1);
   // result == 3

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** must be a model of `Input Iterator`
   and `InputIterator's` `value_type` must be a model of
   must be a model of `Equality Comparable`.

-  **EqualityComparable** must be a model of `Equality Comparable`
   and can be compared for equality with
   `InputIterator's` `value_type`

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **value** The value to be counted.

**Returns**: The number of elements equal to `value`.

**See**: https://en.cppreference.com/w/cpp/algorithm/count

**thrust::count**

::

   template <typename InputIterator,
     typename EqualityComparable> thrust::iterator_traits< InputIterator >::difference_type
   count(InputIterator first,
     InputIterator last,
     const EqualityComparable & value);

`count` finds the number of elements in `[first,last)` that
are equal to `value`. More precisely, `count` returns the
number of iterators `i` in `[first, last)` such that
`*i == value`.

The following code snippet demonstrates how to use `count` to
count the number of instances in a range of a value of
interest.

::

   #include <thrust/count.h>
   #include <thrust/device_vector.h>
   ...
   // put 3 1s in a device_vector
   thrust::device_vector<int> vec(5,0);
   vec[1] = 1;
   vec[3] = 1;
   vec[4] = 1;

   // count the 1s
   int result = thrust::count(vec.begin(), vec.end(), 1);
   // result == 3

**Template Parameters**:

-  **InputIterator** must be a model of `Input Iterator`
   and `InputIterator's` `value_type` must be a model of
   must be a model of `Equality Comparable`.

-  **EqualityComparable** must be a model of `Equality Comparable`
   and can be compared for equality with
   `InputIterator's` `value_type`

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **value** The value to be counted.

**Returns**: The number of elements equal to `value`.

**See**: https://en.cppreference.com/w/cpp/algorithm/count

**thrust::count_if**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ thrust::iterator_traits< InputIterator >::difference_type
   count_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

`count_if` finds the number of elements in `[first,last)`
for which a predicate is `true`. More precisely, `count_if`
returns the number of iterators `i` in `[first, last)` such
that `pred(*i) == true`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `count` to
count the number of odd numbers in a range using the
`thrust::device` execution policy:

::

   #include <thrust/count.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_odd
   {
   __host__ __device__
   bool operator()(int &x)
   {
      return x & 1;
   }
   };
   ...
   // fill a device_vector with even & odd numbers
   thrust::device_vector<int> vec(5);
   vec[0] = 0;
   vec[1] = 1;
   vec[2] = 2;
   vec[3] = 3;
   vec[4] = 4;

   // count the odd elements in vec
   int result = thrust::count_if(thrust::device, vec.begin(), vec.end(), is_odd());
   // result == 2

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** must be a model of `Input Iterator`
   and `InputIterator's` `value_type` must be convertible
   to `Predicate's` `argument_type`.

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** The predicate.

**Returns**: The number of elements where `pred` is `true`.

**See**: https://en.cppreference.com/w/cpp/algorithm/count

**thrust::count_if**

::

   template <typename InputIterator,
     typename Predicate>
   thrust::iterator_traits< InputIterator >::difference_type
   count_if(InputIterator first,
     InputIterator last,
     Predicate pred);

`count_if` finds the number of elements in `[first,last)`
for which a predicate is `true`. More precisely, `count_if`
returns the number of iterators `i` in `[first, last)` such
that `pred(*i) == true`.

The following code snippet demonstrates how to use `count` to
count the number of odd numbers in a range.

::

   #include <thrust/count.h>
   #include <thrust/device_vector.h>
   ...
   struct is_odd
   {
   __host__ __device__
   bool operator()(int &x)
   {
      return x & 1;
   }
   };
   ...
   // fill a device_vector with even & odd numbers
   thrust::device_vector<int> vec(5);
   vec[0] = 0;
   vec[1] = 1;
   vec[2] = 2;
   vec[3] = 3;
   vec[4] = 4;

   // count the odd elements in vec
   int result = thrust::count_if(vec.begin(), vec.end(), is_odd());
   // result == 2

**Template Parameters**:

-  **InputIterator** must be a model of `Input Iterator`
   and `InputIterator's` `value_type` must be convertible
   to `Predicate's` `argument_type`.

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** The predicate.

**Returns**: The number of elements where `pred` is `true`.

**See**: https://en.cppreference.com/w/cpp/algorithm/count

Extrema
*******
  **Functions**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   thrust::min_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator>
   ForwardIterator
   thrust::min_element(ForwardIterator first,
     ForwardIterator last);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ ForwardIterator
   thrust::min_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

   template <typename ForwardIterator,
     typename BinaryPredicate>
   ForwardIterator
   thrust::min_element(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   thrust::max_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator>
   ForwardIterator
   thrust::max_element(ForwardIterator first,
     ForwardIterator last);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__
   ForwardIterator
   thrust::max_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

   template <typename ForwardIterator,
     typename BinaryPredicate>
   ForwardIterator
   thrust::max_element(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   thrust::minmax_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator>
   thrust::pair< ForwardIterator, ForwardIterator >
   thrust::minmax_element(ForwardIterator first,
     ForwardIterator last);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   thrust::minmax_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

   template <typename ForwardIterator,
     typename BinaryPredicate>
   thrust::pair< ForwardIterator, ForwardIterator >
   thrust::minmax_element(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

**thrust::min_element**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   min_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

`min_element` finds the smallest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value smaller than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `min_element` differ in how they define
whether one element is less than another. This version compares
objects using `operator<`. Specifically, this version of
`min_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `*j < *i` is `false`.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/extrema.h>
   #include <thrust/execution_policy.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int *result = thrust::min_element(thrust::host, data, data + 6);

   // result is data + 1
   // *result is 0

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
and `ForwardIterator's` `value_type` is a model of
`LessThan Comparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: An iterator pointing to the smallest element of
the range `[first, last)`, if it is not an empty range;
`last`, otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/min_element

**thrust::min_element**

::

   template <typename ForwardIterator>
   ForwardIterator
   min_element(ForwardIterator first,
     ForwardIterator last);

`min_element` finds the smallest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value smaller than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `min_element` differ in how they define
whether one element is less than another. This version compares
objects using `operator<`. Specifically, this version of
`min_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `*j < *i` is `false`.

::

   #include <thrust/extrema.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int *result = thrust::min_element(data, data + 6);

   // result is data + 1
   // *result is 0

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
and `ForwardIterator's` `value_type` is a model of
`LessThan Comparable`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: An iterator pointing to the smallest element of
the range `[first, last)`, if it is not an empty range;
`last`, otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/min_element

**thrust::min_element**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ ForwardIterator
   min_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

`min_element` finds the smallest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value smaller than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `min_element` differ in how they define
whether one element is less than another. This version compares
objects using a function object `comp`. Specifically, this
version of `min_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `comp(*j, *i)` is `false`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`min_element` to find the smallest element of a collection of
key-value pairs using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/extrema.h>
   #include <thrust/execution_policy.h>
   ...

   struct key_value
   {
   int key;
   int value;
   };

   struct compare_key_value
   {
   __host__ __device__
   bool operator()(key_value lhs, key_value rhs)
   {
      return lhs.key < rhs.key;
   }
   };

   ...
   key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

   key_value *smallest = thrust::min_element(thrust::host, data, data + 4, compare_key_value());

   // smallest == data + 1
   // *smallest == {0,7}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `comp's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** A binary predicate used for comparison.

**Returns**: An iterator pointing to the smallest element of
the range `[first, last)`, if it is not an empty range;
`last`, otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/min_element

**thrust::min_element**

::

   template <typename ForwardIterator,
     typename BinaryPredicate>
   ForwardIterator
   min_element(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

`min_element` finds the smallest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value smaller than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `min_element` differ in how they define
whether one element is less than another. This version compares
objects using a function object `comp`. Specifically, this
version of `min_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `comp(*j, *i)` is `false`.

The following code snippet demonstrates how to use
`min_element` to find the smallest element of a collection of
key-value pairs.

::

   #include <thrust/extrema.h>

   struct key_value
   {
   int key;
   int value;
   };

   struct compare_key_value
   {
   __host__ __device__
   bool operator()(key_value lhs, key_value rhs)
   {
      return lhs.key < rhs.key;
   }
   };

   ...
   key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

   key_value *smallest = thrust::min_element(data, data + 4, compare_key_value());

   // smallest == data + 1
   // *smallest == {0,7}

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `comp's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** A binary predicate used for comparison.

**Returns**: An iterator pointing to the smallest element of
the range `[first, last)`, if it is not an empty range;
`last`, otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/min_element

**thrust::max_element**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   max_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

`max_element` finds the largest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value larger than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `max_element` differ in how they define
whether one element is greater than another. This version
compares objects using `operator<`. Specifically, this
version of `max_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `*i < *j` is `false`.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/extrema.h>
   #include <thrust/execution_policy.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int *result = thrust::max_element(thrust::host, data, data + 6);

   // *result == 3

**Template Parameters**:

-  **A** Thrust backend system.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is a model of
   `LessThan Comparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: An iterator pointing to the largest element of the
range `[first, last)`, if it is not an empty range; `last`,
otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/max_element

**thrust::max_element**

::

   template <typename ForwardIterator>
   ForwardIterator
   max_element(ForwardIterator first,
     ForwardIterator last);

`max_element` finds the largest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value larger than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `max_element` differ in how they define
whether one element is greater than another. This version
compares objects using `operator<`. Specifically, this
version of `max_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `*i < *j` is `false`.

::

   #include <thrust/extrema.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   int *result = thrust::max_element(data, data + 6);

   // *result == 3

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
and `ForwardIterator's` `value_type` is a model of
`LessThan Comparable`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: An iterator pointing to the largest element of the
range `[first, last)`, if it is not an empty range; `last`,
otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/max_element

**thrust::max_element**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ ForwardIterator
   max_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

`max_element` finds the largest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value larger than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `max_element` differ in how they define
whether one element is less than another. This version compares
objects using a function object `comp`. Specifically, this
version of `max_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `comp(*i, *j)` is `false`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`max_element` to find the largest element of a collection of
key-value pairs using the `thrust::host` execution policy for
parallelization.

::

   #include <thrust/extrema.h>
   #include <thrust/execution_policy.h>
   ...

   struct key_value
   {
   int key;
   int value;
   };

   struct compare_key_value
   {
   __host__ __device__
   bool operator()(key_value lhs, key_value rhs)
   {
      return lhs.key < rhs.key;
   }
   };

   ...
   key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

   key_value *largest = thrust::max_element(thrust::host, data, data + 4, compare_key_value());

   // largest == data + 3
   // *largest == {6,1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `comp's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** A binary predicate used for comparison.

**Returns**: An iterator pointing to the largest element of the
range `[first, last)`, if it is not an empty range; `last`,
otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/max_element

**thrust::max_element**

::

   template <typename ForwardIterator,
     typename BinaryPredicate>
   ForwardIterator
   max_element(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

`max_element` finds the largest element in the range
`[first, last)`. It returns the first iterator `i` in
`[first, last)` such that no other iterator in
`[first, last)` points to a value larger than `*i`. The
return value is `last` if and only if `[first, last)` is an
empty range.

The two versions of `max_element` differ in how they define
whether one element is less than another. This version compares
objects using a function object `comp`. Specifically, this
version of `max_element` returns the first iterator `i` in
`[first, last)` such that, for every iterator `j` in
`[first, last)`, `comp(*i, *j)` is `false`.

The following code snippet demonstrates how to use
`max_element` to find the largest element of a collection of
key-value pairs.

::

   #include <thrust/extrema.h>

   struct key_value
   {
   int key;
   int value;
   };

   struct compare_key_value
   {
   __host__ __device__
   bool operator()(key_value lhs, key_value rhs)
   {
      return lhs.key < rhs.key;
   }
   };

   ...
   key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

   key_value *largest = thrust::max_element(data, data + 4, compare_key_value());

   // largest == data + 3
   // *largest == {6,1}

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `comp's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** A binary predicate used for comparison.

**Returns**: An iterator pointing to the largest element of the
range `[first, last)`, if it is not an empty range; `last`,
otherwise.

**See**:
https://en.cppreference.com/w/cpp/algorithm/max_element

**thrust::minmax_element**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   minmax_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

`minmax_element` finds the smallest and largest elements in
the range `[first, last)`. It returns a pair of iterators
`(imin, imax)` where `imin` is the same iterator returned
by `min_element` and `imax` is the same iterator returned
by `max_element`. This function is potentially more efficient
than separate calls to `min_element` and `max_element`.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/extrema.h>
   #include <thrust/execution_policy.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   thrust::pair<int *, int *> result = thrust::minmax_element(thrust::host, data, data + 6);

   // result.first is data + 1
   // result.second is data + 5
   // *result.first is 0
   // *result.second is 3

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is a model of
   `LessThan Comparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: A pair of iterator pointing to the smallest and
largest elements of the range `[first, last)`, if it is not
an empty range; `last`, otherwise.

**See**:

-  min_element

-  max_element

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf

**thrust::minmax_element**

::

   template <typename ForwardIterator>
   thrust::pair< ForwardIterator, ForwardIterator >
   minmax_element(ForwardIterator first,  
     ForwardIterator last);

`minmax_element` finds the smallest and largest elements in
the range `[first, last)`. It returns a pair of iterators
`(imin, imax)` where `imin` is the same iterator returned
by `min_element` and `imax` is the same iterator returned
by `max_element`. This function is potentially more efficient
than separate calls to `min_element` and `max_element`.

::

   #include <thrust/extrema.h>
   ...
   int data[6] = {1, 0, 2, 2, 1, 3};
   thrust::pair<int *, int *> result = thrust::minmax_element(data, data + 6);

   // result.first is data + 1
   // result.second is data + 5
   // *result.first is 0
   // *result.second is 3

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
and `ForwardIterator's` `value_type` is a model of
`LessThan Comparable`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: A pair of iterator pointing to the smallest and
largest elements of the range `[first, last)`, if it is not
an empty range; `last`, otherwise.

**See**:

-  min_element

-  max_element

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf

**thrust::minmax_element**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   minmax_element(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

`minmax_element` finds the smallest and largest elements in
the range `[first, last)`. It returns a pair of iterators
`(imin, imax)` where `imin` is the same iterator returned
by `min_element` and `imax` is the same iterator returned
by `max_element`. This function is potentially more efficient
than separate calls to `min_element` and `max_element`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`minmax_element` to find the smallest and largest elements of
a collection of key-value pairs using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/extrema.h>
   #include <thrust/pair.h>
   #include <thrust/execution_policy.h>
   ...

   struct key_value
   {
   int key;
   int value;
   };

   struct compare_key_value
   {
   __host__ __device__
   bool operator()(key_value lhs, key_value rhs)
   {
      return lhs.key < rhs.key;
   }
   };

   ...
   key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

   thrust::pair<key_value*,key_value*> extrema = thrust::minmax_element(thrust::host, data, data + 4, compare_key_value());

   // extrema.first   == data + 1
   // *extrema.first  == {0,7}
   // extrema.second  == data + 3
   // *extrema.second == {6,1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `comp's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** A binary predicate used for comparison.

**Returns**: A pair of iterator pointing to the smallest and
largest elements of the range `[first, last)`, if it is not
an empty range; `last`, otherwise.

**See**:

-  min_element

-  max_element

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf

**thrust::minmax_element**

::

   template <typename ForwardIterator,
     typename BinaryPredicate>
   thrust::pair< ForwardIterator, ForwardIterator >
   minmax_element(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate comp);

`minmax_element` finds the smallest and largest elements in
the range `[first, last)`. It returns a pair of iterators
`(imin, imax)` where `imin` is the same iterator returned
by `min_element` and `imax` is the same iterator returned
by `max_element`. This function is potentially more efficient
than separate calls to `min_element` and `max_element`.

The following code snippet demonstrates how to use
`minmax_element` to find the smallest and largest elements of
a collection of key-value pairs.

::

   #include <thrust/extrema.h>
   #include <thrust/pair.h>

   struct key_value
   {
   int key;
   int value;
   };

   struct compare_key_value
   {
   __host__ __device__
   bool operator()(key_value lhs, key_value rhs)
   {
      return lhs.key < rhs.key;
   }
   };

   ...
   key_value data[4] = { {4,5}, {0,7}, {2,3}, {6,1} };

   thrust::pair<key_value*,key_value*> extrema = thrust::minmax_element(data, data + 4, compare_key_value());

   // extrema.first   == data + 1
   // *extrema.first  == {0,7}
   // extrema.second  == data + 3
   // *extrema.second == {6,1}

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `comp's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** A binary predicate used for comparison.

**Returns**: A pair of iterator pointing to the smallest and
largest elements of the range `[first, last)`, if it is not
an empty range; `last`, otherwise.

**See**:

-  min_element

-  max_element

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1840.pdf

Logical
*******
**Logical**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   thrust::all_of(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,  
    Predicate pred);

   template <typename InputIterator,
     typename Predicate>
   bool
   thrust::all_of(InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   thrust::any_of(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename InputIterator,
     typename Predicate>
   bool
   thrust::any_of(InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   thrust::none_of(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename InputIterator,
     typename Predicate>
   bool
   thrust::none_of(InputIterator first,
     InputIterator last,
     Predicate pred);

**thrust::all_of**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   all_of(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

`all_of` determines whether all elements in a range satify a
predicate. Specifically, `all_of` returns `true` if
`pred(*i)` is `true` for every iterator `i` in the range
`[first, last)` and `false` otherwise.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/logical.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   bool A[3] = {true, true, false};

   thrust::all_of(thrust::host, A, A + 2, thrust::identity<bool>()); // returns true
   thrust::all_of(thrust::host, A, A + 3, thrust::identity<bool>()); // returns false

   // empty range
   thrust::all_of(thrust::host, A, A, thrust::identity<bool>()); // returns false

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** A predicate used to test range elements.

**Returns**: `true`, if all elements satisfy the predicate;
`false`, otherwise.

**See**:

-  any_of

-  none_of

-  transform_reduce

**thrust::all_of**

::

   template <typename InputIterator,
     typename Predicate>
   bool
   all_of(InputIterator first,
     InputIterator last,
     Predicate pred);

`all_of` determines whether all elements in a range satify a
predicate. Specifically, `all_of` returns `true` if
`pred(*i)` is `true` for every iterator `i` in the range
`[first, last)` and `false` otherwise.

::

   #include <thrust/logical.h>
   #include <thrust/functional.h>
   ...
   bool A[3] = {true, true, false};

   thrust::all_of(A, A + 2, thrust::identity<bool>()); // returns true
   thrust::all_of(A, A + 3, thrust::identity<bool>()); // returns false

   // empty range
   thrust::all_of(A, A, thrust::identity<bool>()); // returns false

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** A predicate used to test range elements.

**Returns**: `true`, if all elements satisfy the predicate;
`false`, otherwise.

**See**:

-  any_of

-  none_of

-  transform_reduce

**thrust::any_of**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   any_of(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

`any_of` determines whether any element in a range satifies a
predicate. Specifically, `any_of` returns `true` if
`pred(*i)` is `true` for any iterator `i` in the range
`[first, last)` and `false` otherwise.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/logical.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   bool A[3] = {true, true, false};

   thrust::any_of(thrust::host, A, A + 2, thrust::identity<bool>()); // returns true
   thrust::any_of(thrust::host, A, A + 3, thrust::identity<bool>()); // returns true

   thrust::any_of(thrust::host, A + 2, A + 3, thrust::identity<bool>()); // returns false

   // empty range
   thrust::any_of(thrust::host, A, A, thrust::identity<bool>()); // returns false

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** A predicate used to test range elements.

**Returns**: `true`, if any element satisfies the predicate;
`false`, otherwise.

**See**:

-  all_of

-  none_of

-  transform_reduce

**thrust::any_of**

::

   template <typename InputIterator,
     typename Predicate>
   bool
   any_of(InputIterator first,
     InputIterator last,
     Predicate pred);

`any_of` determines whether any element in a range satifies a
predicate. Specifically, `any_of` returns `true` if
`pred(*i)` is `true` for any iterator `i` in the range
`[first, last)` and `false` otherwise.

::

   #include <thrust/logical.h>
   #include <thrust/functional.h>
   ...
   bool A[3] = {true, true, false};

   thrust::any_of(A, A + 2, thrust::identity<bool>()); // returns true
   thrust::any_of(A, A + 3, thrust::identity<bool>()); // returns true

   thrust::any_of(A + 2, A + 3, thrust::identity<bool>()); // returns false

   // empty range
   thrust::any_of(A, A, thrust::identity<bool>()); // returns false

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** A predicate used to test range elements.

**Returns**: `true`, if any element satisfies the predicate;
`false`, otherwise.

**See**:

-  all_of

-  none_of

-  transform_reduce

**thrust::none_of**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   none_of(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

`none_of` determines whether no element in a range satifies a
predicate. Specifically, `none_of` returns `true` if there
is no iterator `i` in the range `[first, last)` such that
`pred(*i)` is `true`, and `false` otherwise.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/logical.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   bool A[3] = {true, true, false};

   thrust::none_of(thrust::host, A, A + 2, thrust::identity<bool>()); // returns false
   thrust::none_of(thrust::host, A, A + 3, thrust::identity<bool>()); // returns false

   thrust::none_of(thrust::host, A + 2, A + 3, thrust::identity<bool>()); // returns true

   // empty range
   thrust::none_of(thrust::host, A, A, thrust::identity<bool>()); // returns true

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** A predicate used to test range elements.

**Returns**: `true`, if no element satisfies the predicate;
`false`, otherwise.

**See**:

-  all_of

-  any_of

-  transform_reduce

**thrust::none_of**

::

   template <typename InputIterator,
     typename Predicate>
   bool
   none_of(InputIterator first,
     InputIterator last,
     Predicate pred);

`none_of` determines whether no element in a range satifies a
predicate. Specifically, `none_of` returns `true` if there
is no iterator `i` in the range `[first, last)` such that
`pred(*i)` is `true`, and `false` otherwise.

::

   #include <thrust/logical.h>
   #include <thrust/functional.h>
   ...
   bool A[3] = {true, true, false};

   thrust::none_of(A, A + 2, thrust::identity<bool>()); // returns false
   thrust::none_of(A, A + 3, thrust::identity<bool>()); // returns false

   thrust::none_of(A + 2, A + 3, thrust::identity<bool>()); // returns true

   // empty range
   thrust::none_of(A, A, thrust::identity<bool>()); // returns true

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,

-  **Predicate** must be a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **pred** A predicate used to test range elements.

**Returns**: `true`, if no element satisfies the predicate;
`false`, otherwise.

**See**:

-  all_of

-  any_of

-  transform_reduce

Predicates
**********
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   thrust::is_partitioned(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename InputIterator,
     typename Predicate>
   bool
   thrust::is_partitioned(InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ bool
   thrust::is_sorted(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator>
   bool
   thrust::is_sorted(ForwardIterator first,
     ForwardIterator last);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Compare>
   __host__ __device__ bool
   thrust::is_sorted(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Compare comp);

   template <typename ForwardIterator,
     typename Compare>
   bool
   thrust::is_sorted(ForwardIterator first,
     ForwardIterator last,
     Compare comp);

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   thrust::is_sorted_until(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator>
   ForwardIterator
   thrust::is_sorted_until(ForwardIterator first,
     ForwardIterator last);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Compare>
   __host__ __device__ ForwardIterator
   thrust::is_sorted_until(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Compare comp);

   template <typename ForwardIterator,
     typename Compare>
   ForwardIterator
   thrust::is_sorted_until(ForwardIterator first,
     ForwardIterator last,
     Compare comp);

**thrust::is_partitioned**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ bool
   is_partitioned(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

`is_partitioned` returns `true` if the given range is
partitioned with respect to a predicate, and `false`
otherwise.

Specifically, `is_partitioned` returns `true` if
`[first, last)` is empty of if `[first, last)` is
partitioned by `pred`, i.e. if all elements that satisfy
`pred` appear before those that do not.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };

   ...

   int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
   int B[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

   thrust::is_partitioned(thrust::host, A, A + 10, is_even()); // returns true
   thrust::is_partitioned(thrust::host, B, B + 10, is_even()); // returns false

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range to consider.

-  **last** The end of the range to consider.

-  **pred** A function object which decides to which
   partition each element of the range `[first, last)`
   belongs.

**Returns**: `true` if the range `[first, last)` is
partitioned with respect to `pred`, or if `[first, last)`
is empty. `false`, otherwise.

**See**: `partition`

**thrust::is_partitioned**

::

   template <typename InputIterator,
     typename Predicate>
   bool
   is_partitioned(InputIterator first,
     InputIterator last,
     Predicate pred);

`is_partitioned` returns `true` if the given range is
partitioned with respect to a predicate, and `false`
otherwise.

Specifically, `is_partitioned` returns `true` if
`[first, last)` is empty of if `[first, last)` is
partitioned by `pred`, i.e. if all elements that satisfy
`pred` appear before those that do not.

::

   #include <thrust/partition.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };

   ...

   int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
   int B[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

   thrust::is_partitioned(A, A + 10, is_even()); // returns true
   thrust::is_partitioned(B, B + 10, is_even()); // returns false

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the range to consider.

-  **last** The end of the range to consider.

-  **pred** A function object which decides to which
   partition each element of the range `[first, last)`
   belongs.

**Returns**: `true` if the range `[first, last)` is
partitioned with respect to `pred`, or if `[first, last)`
is empty. `false`, otherwise.

**See**: `partition`

**thrust::is_sorted**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ bool
   is_sorted(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

`is_sorted` returns `true` if the range `[first, last)`
is sorted in ascending order, and `false` otherwise.

Specifically, this version of `is_sorted` returns `false`
if for some iterator `i` in the range `[first, last - 1)`
the expression `*(i + 1) < *i` is `true`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code demonstrates how to use `is_sorted` to
test whether the contents of a `device_vector` are stored in
ascending order using the `thrust::device` execution policy
for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/device_vector.h>
   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> v(6);
   v[0] = 1;
   v[1] = 4;
   v[2] = 2;
   v[3] = 8;
   v[4] = 5;
   v[5] = 7;

   bool result = thrust::is_sorted(thrust::device, v.begin(), v.end());

   // result == false

   thrust::sort(v.begin(), v.end());
   result = thrust::is_sorted(thrust::device, v.begin(), v.end());

   // result == true

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator's` `value_type` is a model of
   `LessThan Comparable`,
   and the ordering on objects of
   `ForwardIterator's` `value_type` is a *strict weak
   ordering*, as defined in the `LessThan Comparable`
   requirements.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: `true`, if the sequence is sorted; `false`,
otherwise.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/is_sorted

-  is_sorted_until

-  `sort`

-  `stable_sort`

-  `less<T>`

**thrust::is_sorted**

::

   template <typename ForwardIterator> bool is_sorted(ForwardIterator first,   ForwardIterator last);

`is_sorted` returns `true` if the range `[first, last)`
is sorted in ascending order, and `false` otherwise.

Specifically, this version of `is_sorted` returns `false`
if for some iterator `i` in the range `[first, last - 1)`
the expression `*(i + 1) < *i` is `true`.

The following code demonstrates how to use `is_sorted` to
test whether the contents of a `device_vector` are stored in
ascending order.

::

   #include <thrust/sort.h>
   #include <thrust/device_vector.h>
   #include <thrust/sort.h>
   ...
   thrust::device_vector<int> v(6);
   v[0] = 1;
   v[1] = 4;
   v[2] = 2;
   v[3] = 8;
   v[4] = 5;
   v[5] = 7;

   bool result = thrust::is_sorted(v.begin(), v.end());

   // result == false

   thrust::sort(v.begin(), v.end());
   result = thrust::is_sorted(v.begin(), v.end());

   // result == true

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
`ForwardIterator's` `value_type` is a model of `LessThan Comparable`,
and the ordering on objects of
`ForwardIterator's` `value_type` is a *strict weak
ordering*, as defined in the `LessThan Comparable`
requirements.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**Returns**: `true`, if the sequence is sorted; `false`,
otherwise.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/is_sorted

-  is_sorted_until

-  `sort`

-  `stable_sort`

-  `less<T>`

**thrust::is_sorted**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Compare>
   __host__ __device__ bool
   is_sorted(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Compare comp);

`is_sorted` returns `true` if the range `[first, last)`
is sorted in ascending order accoring to a user-defined
comparison operation, and `false` otherwise.

Specifically, this version of `is_sorted` returns `false`
if for some iterator `i` in the range `[first, last - 1)`
the expression `comp(*(i + 1), *i)` is `true`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`is_sorted` to test whether the contents of a
`device_vector` are stored in descending order using the
`thrust::device` execution policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> v(6);
   v[0] = 1;
   v[1] = 4;
   v[2] = 2;
   v[3] = 8;
   v[4] = 5;
   v[5] = 7;

   thrust::greater<int> comp;
   bool result = thrust::is_sorted(thrust::device, v.begin(), v.end(), comp);

   // result == false

   thrust::sort(v.begin(), v.end(), comp);
   result = thrust::is_sorted(thrust::device, v.begin(), v.end(), comp);

   // result == true

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **Compare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** Comparison operator.

**Returns**: `true`, if the sequence is sorted according to
comp; `false`, otherwise.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/is_sorted

-  `sort`

-  `stable_sort`

-  `less<T>`

**thrust::is_sorted**

::

   template <typename ForwardIterator,
     typename Compare>
   bool
   is_sorted(ForwardIterator first,
     ForwardIterator last,
     Compare comp);

`is_sorted` returns `true` if the range `[first, last)`
is sorted in ascending order accoring to a user-defined
comparison operation, and `false` otherwise.

Specifically, this version of `is_sorted` returns `false`
if for some iterator `i` in the range `[first, last - 1)`
the expression `comp(*(i + 1), *i)` is `true`.

The following code snippet demonstrates how to use
`is_sorted` to test whether the contents of a
`device_vector` are stored in descending order.

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> v(6);
   v[0] = 1;
   v[1] = 4;
   v[2] = 2;
   v[3] = 8;
   v[4] = 5;
   v[5] = 7;

   thrust::greater<int> comp;
   bool result = thrust::is_sorted(v.begin(), v.end(), comp);

   // result == false

   thrust::sort(v.begin(), v.end(), comp);
   result = thrust::is_sorted(v.begin(), v.end(), comp);

   // result == true

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   both `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **Compare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** Comparison operator.

**Returns**: `true`, if the sequence is sorted according to
comp; `false`, otherwise.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/is_sorted

-  `sort`

-  `stable_sort`

-  `less<T>`

**thrust::is_sorted_until**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   is_sorted_until(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

This version of `is_sorted_until` returns the last iterator
`i` in `[first,last]` for which the range `[first,last)`
is sorted using `operator<`. If `distance(first,last) < 2`,
`is_sorted_until` simply returns `last`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`is_sorted_until` to find the first position in an array
where the data becomes unsorted using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>

   ...

   int A[8] = {0, 1, 2, 3, 0, 1, 2, 3};

   int * B = thrust::is_sorted_until(thrust::host, A, A + 8);

   // B - A is 4
   // [A, B) is sorted

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`
   and `ForwardIterator's` `value_type` is a model of
   `LessThan Comparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

**Returns**: The last iterator in the input range for which it
is sorted.

**See**:

-  `is_sorted`

-  `sort`

-  `sort_by_key`

-  `stable_sort`

-  `stable_sort_by_key`

**thrust::is_sorted_until**

::

   template <typename ForwardIterator>
   ForwardIterator
   is_sorted_until(ForwardIterator first,
     ForwardIterator last);

This version of `is_sorted_until` returns the last iterator
`i` in `[first,last]` for which the range `[first,last)`
is sorted using `operator<`. If `distance(first,last) < 2`,
`is_sorted_until` simply returns `last`.

The following code snippet demonstrates how to use
`is_sorted_until` to find the first position in an array
where the data becomes unsorted:

::

   #include <thrust/sort.h>

   ...

   int A[8] = {0, 1, 2, 3, 0, 1, 2, 3};

   int * B = thrust::is_sorted_until(A, A + 8);

   // B - A is 4
   // [A, B) is sorted

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`
and `ForwardIterator's` `value_type` is a model of
`LessThan Comparable`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

**Returns**: The last iterator in the input range for which it
is sorted.

**See**:

-  `is_sorted`

-  `sort`

-  `sort_by_key`

-  `stable_sort`

-  `stable_sort_by_key`

**thrust::is_sorted_until**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Compare>
   __host__ __device__ ForwardIterator
   is_sorted_until(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Compare comp);

This version of `is_sorted_until` returns the last iterator
`i` in `[first,last]` for which the range `[first,last)`
is sorted using the function object `comp`. If
`distance(first,last) < 2`, `is_sorted_until` simply
returns `last`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`is_sorted_until` to find the first position in an array
where the data becomes unsorted in descending order using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>

   ...

   int A[8] = {3, 2, 1, 0, 3, 2, 1, 0};

   thrust::greater<int> comp;
   int * B = thrust::is_sorted_until(thrust::host, A, A + 8, comp);

   // B - A is 4
   // [A, B) is sorted in descending order

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`
   and `ForwardIterator's` `value_type` is convertible to
   `Compare's` `argument_type`.

-  **Compare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **comp** The function object to use for comparison.

**Returns**: The last iterator in the input range for which it
is sorted.

**See**:

-  `is_sorted`

-  `sort`

-  `sort_by_key`

-  `stable_sort`

-  `stable_sort_by_key`

**thrust::is_sorted_until**

::

   template <typename ForwardIterator,
     typename Compare>
   ForwardIterator
   is_sorted_until(ForwardIterator first,
     ForwardIterator last,
     Compare comp);

This version of `is_sorted_until` returns the last iterator
`i` in `[first,last]` for which the range `[first,last)`
is sorted using the function object `comp`. If
`distance(first,last) < 2`, `is_sorted_until` simply
returns `last`.

The following code snippet demonstrates how to use
`is_sorted_until` to find the first position in an array
where the data becomes unsorted in descending order:

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>

   ...

   int A[8] = {3, 2, 1, 0, 3, 2, 1, 0};

   thrust::greater<int> comp;
   int * B = thrust::is_sorted_until(A, A + 8, comp);

   // B - A is 4
   // [A, B) is sorted in descending order

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`
   and `ForwardIterator's` `value_type` is convertible to
   `Compare's` `argument_type`.

-  **Compare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **comp** The function object to use for comparison.

**Returns**: The last iterator in the input range for which it
is sorted.

**See**:

-  `is_sorted`

-  `sort`

-  `sort_by_key`

-  `stable_sort`

-  `stable_sort_by_key`

Transformed Reductions
**********************
**Functions**
Transformed Reductions

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputType>
   __host__ __device__ OutputType
   thrust::inner_product(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputType>
   OutputType
   thrust::inner_product(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputType,
     typename BinaryFunction1,
     typename BinaryFunction2>
   __host__ __device__ OutputType
   thrust::inner_product(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init,
     BinaryFunction1 binary_op1,
     BinaryFunction2 binary_op2);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputType,
     typename BinaryFunction1,
     typename BinaryFunction2>
   OutputType
   thrust::inner_product(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init,
     BinaryFunction1 binary_op1,
     BinaryFunction2 binary_op2);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename UnaryFunction,
     typename OutputType,
     typename BinaryFunction>
   __host__ __device__ OutputType
   thrust::transform_reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     UnaryFunction unary_op,
     OutputType init,
     BinaryFunction binary_op);

   template <typename InputIterator,
     typename UnaryFunction,
     typename OutputType,
     typename BinaryFunction>
   OutputType
   thrust::transform_reduce(InputIterator first,
     InputIterator last,
     UnaryFunction unary_op,
     OutputType init,
     BinaryFunction binary_op);

**thrust::inner_product**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputType>
   __host__ __device__ OutputType
   inner_product(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init);

`inner_product` calculates an inner product of the ranges
`[first1, last1)` and
`[first2, first2 + (last1 - first1))`.

Specifically, this version of `inner_product` computes the
sum
`init + (*first1 * *first2) + (*(first1+1) * *(first2+1)) + ...`

The algorithm’s execution is parallelized as determined by
`exec`.

The following code demonstrates how to use `inner_product` to
compute the dot product of two vectors using the
`thrust::host` execution policy for parallelization.

::

   #include <thrust/inner_product.h>
   #include <thrust/execution_policy.h>
   ...
   float vec1[3] = {1.0f, 2.0f, 5.0f};
   float vec2[3] = {4.0f, 1.0f, 5.0f};

   float result = thrust::inner_product(thrust::host, vec1, vec1 + 3, vec2, 0.0f);

   // result == 31.0f

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputType** is a model of
   `Assignable`,
   and if `x` is an object of type `OutputType`, and `y`
   is an object of `InputIterator1's` `value_type`, and
   `z` is an object of `InputIterator2's` `value_type`,
   then `x + y * z` is defined and is convertible to
   `OutputType`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **init** Initial value of the result.

**Returns**: The inner product of sequences `[first1, last1)`
and `[first2, last2)` plus `init`.

**See**:
https://en.cppreference.com/w/cpp/algorithm/inner_product

**thrust::inner_product**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputType>
   OutputType
   inner_product(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init);

`inner_product` calculates an inner product of the ranges
`[first1, last1)` and
`[first2, first2 + (last1 - first1))`.

Specifically, this version of `inner_product` computes the
sum
`init + (*first1 * *first2) + (*(first1+1) * *(first2+1)) + ...`

Unlike the C++ Standard Template Library function
`std::inner_product`, this version offers no guarantee on
order of execution.

The following code demonstrates how to use `inner_product` to
compute the dot product of two vectors.

::

   #include <thrust/inner_product.h>
   ...
   float vec1[3] = {1.0f, 2.0f, 5.0f};
   float vec2[3] = {4.0f, 1.0f, 5.0f};

   float result = thrust::inner_product(vec1, vec1 + 3, vec2, 0.0f);

   // result == 31.0f

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputType** is a model of
   `Assignable`,
   and if `x` is an object of type `OutputType`, and `y`
   is an object of `InputIterator1's` `value_type`, and
   `z` is an object of `InputIterator2's` `value_type`,
   then `x + y * z` is defined and is convertible to
   `OutputType`.

**Function Parameters**:

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **init** Initial value of the result.

**Returns**: The inner product of sequences `[first1, last1)`
and `[first2, last2)` plus `init`.

**See**:
https://en.cppreference.com/w/cpp/algorithm/inner_product

**thrust::inner_product**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputType,
     typename BinaryFunction1,
     typename BinaryFunction2>
   __host__ __device__ OutputType
   inner_product(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init,
     BinaryFunction1 binary_op1,
     BinaryFunction2 binary_op2);

`inner_product` calculates an inner product of the ranges
`[first1, last1)` and
`[first2, first2 + (last1 - first1))`.

This version of `inner_product` is identical to the first,
except that is uses two user-supplied function objects instead
of `operator+` and `operator*`.

Specifically, this version of `inner_product` computes the
sum `binary_op1( init, binary_op2(*first1, *first2) ), ...`

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/inner_product.h>
   #include <thrust/execution_policy.h>
   ...
   float vec1[3] = {1.0f, 2.0f, 5.0f};
   float vec2[3] = {4.0f, 1.0f, 5.0f};

   float init = 0.0f;
   thrust::plus<float>       binary_op1;
   thrust::multiplies<float> binary_op2;

   float result = thrust::inner_product(thrust::host, vec1, vec1 + 3, vec2, init, binary_op1, binary_op2);

   // result == 31.0f

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator1's` `value_type` is convertible to
   `BinaryFunction2's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`.
   and `InputIterator2's` `value_type` is convertible to
   `BinaryFunction2's` `second_argument_type`.

-  **OutputType** is a model of
   `Assignable`,
   and `OutputType` is convertible to
   `BinaryFunction1's` `first_argument_type`.

-  **BinaryFunction1** is a model of `Binary Function`,
   and `BinaryFunction1's` `return_type` is convertible to
   `OutputType`.

-  **BinaryFunction2** is a model of `Binary Function`,
   and `BinaryFunction2's` `return_type` is convertible to
   `BinaryFunction1's` `second_argument_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **init** Initial value of the result.

-  **binary_op1** Generalized addition operation.

-  **binary_op2** Generalized multiplication operation.

**Returns**: The inner product of sequences `[first1, last1)`
and `[first2, last2)`.

**See**:
https://en.cppreference.com/w/cpp/algorithm/inner_product

**thrust::inner_product**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputType,
     typename BinaryFunction1,
     typename BinaryFunction2>
   OutputType
   inner_product(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputType init,
     BinaryFunction1 binary_op1,
     BinaryFunction2 binary_op2);

`inner_product` calculates an inner product of the ranges
`[first1, last1)` and
`[first2, first2 + (last1 - first1))`.

This version of `inner_product` is identical to the first,
except that is uses two user-supplied function objects instead
of `operator+` and `operator*`.

Specifically, this version of `inner_product` computes the
sum `binary_op1( init, binary_op2(*first1, *first2) ), ...`

Unlike the C++ Standard Template Library function
`std::inner_product`, this version offers no guarantee on
order of execution.

::

   #include <thrust/inner_product.h>
   ...
   float vec1[3] = {1.0f, 2.0f, 5.0f};
   float vec2[3] = {4.0f, 1.0f, 5.0f};

   float init = 0.0f;
   thrust::plus<float>       binary_op1;
   thrust::multiplies<float> binary_op2;

   float result = thrust::inner_product(vec1, vec1 + 3, vec2, init, binary_op1, binary_op2);

   // result == 31.0f

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator1's` `value_type` is convertible to
   `BinaryFunction2's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`.
   and `InputIterator2's` `value_type` is convertible to
   `BinaryFunction2's` `second_argument_type`.

-  **OutputType** is a model of
   `Assignable`,
   and `OutputType` is convertible to
   `BinaryFunction1's` `first_argument_type`.

-  **BinaryFunction1** is a model of `Binary Function`,
   and `BinaryFunction1's` `return_type` is convertible to
   `OutputType`.

-  **BinaryFunction2** is a model of `Binary Function`,
   and `BinaryFunction2's` `return_type` is convertible to
   `BinaryFunction1's` `second_argument_type`.

**Function Parameters**:

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **init** Initial value of the result.

-  **binary_op1** Generalized addition operation.

-  **binary_op2** Generalized multiplication operation.

**Returns**: The inner product of sequences `[first1, last1)`
and `[first2, last2)`.

**See**:
https://en.cppreference.com/w/cpp/algorithm/inner_product

**thrust::transform_reduce**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename UnaryFunction,
     typename OutputType,
     typename BinaryFunction>
   __host__ __device__ OutputType
   transform_reduce(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     UnaryFunction unary_op,
     OutputType init,
     BinaryFunction binary_op);

`transform_reduce` fuses the `transform` and `reduce`
operations. `transform_reduce` is equivalent to performing a
transformation defined by `unary_op` into a temporary
sequence and then performing `reduce` on the transformed
sequence. In most cases, fusing these two operations together
is more efficient, since fewer memory reads and writes are
required.

`transform_reduce` performs a reduction on the transformation
of the sequence `[first, last)` according to `unary_op`.
Specifically, `unary_op` is applied to each element of the
sequence and then the result is reduced to a single value with
`binary_op` using the initial value `init`. Note that the
transformation `unary_op` is not applied to the initial value
`init`. The order of reduction is not specified, so
`binary_op` must be both commutative and associative.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform_reduce` to compute the maximum value of the
absolute value of the elements of a range using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/transform_reduce.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>

   template<typename T>
   struct absolute_value : public unary_function<T,T>
   {
   __host__ __device__ T operator()(const T &x) const
   {
      return x < T(0) ? -x : x;
   }
   };

   ...

   int data[6] = {-1, 0, -2, -2, 1, -3};
   int result = thrust::transform_reduce(thrust::host,
   data, data + 6,
   absolute_value<int>(),
   0,
   thrust::maximum<int>());
   // result == 3

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **UnaryFunction** is a model of `Unary Function`,
   and `UnaryFunction's` `result_type` is convertible to
   `OutputType`.

-  **OutputType** is a model of
   `Assignable`,
   and is convertible to
   `BinaryFunction's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryFunction** is a model of `Binary Function`,
   and `BinaryFunction's` `result_type` is convertible to
   `OutputType`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **unary_op** The function to apply to each element of
   the input sequence.

-  **init** The result is initialized to this value.

-  **binary_op** The reduction operation.

**Returns**: The result of the transformed reduction.

**See**:

-  `transform`

-  `reduce`

**thrust::transform_reduce**

::

   template <typename InputIterator,
     typename UnaryFunction,
     typename OutputType,
     typename BinaryFunction>
   OutputType
   transform_reduce(InputIterator first,
     InputIterator last,
     UnaryFunction unary_op,
     OutputType init,
     BinaryFunction binary_op);

`transform_reduce` fuses the `transform` and `reduce`
operations. `transform_reduce` is equivalent to performing a
transformation defined by `unary_op` into a temporary
sequence and then performing `reduce` on the transformed
sequence. In most cases, fusing these two operations together
is more efficient, since fewer memory reads and writes are
required.

`transform_reduce` performs a reduction on the transformation
of the sequence `[first, last)` according to `unary_op`.
Specifically, `unary_op` is applied to each element of the
sequence and then the result is reduced to a single value with
`binary_op` using the initial value `init`. Note that the
transformation `unary_op` is not applied to the initial value
`init`. The order of reduction is not specified, so
`binary_op` must be both commutative and associative.

The following code snippet demonstrates how to use
`transform_reduce` to compute the maximum value of the
absolute value of the elements of a range.

::

   #include <thrust/transform_reduce.h>
   #include <thrust/functional.h>

   template<typename T>
   struct absolute_value : public unary_function<T,T>
   {
   __host__ __device__ T operator()(const T &x) const
   {
      return x < T(0) ? -x : x;
   }
   };

   ...

   int data[6] = {-1, 0, -2, -2, 1, -3};
   int result = thrust::transform_reduce(data, data + 6,
   absolute_value<int>(),
   0,
   thrust::maximum<int>());
   // result == 3

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **UnaryFunction** is a model of `Unary Function`,
   and `UnaryFunction's` `result_type` is convertible to
   `OutputType`.

-  **OutputType** is a model of
   `Assignable`,
   and is convertible to
   `BinaryFunction's` `first_argument_type` and
   `second_argument_type`.

-  **BinaryFunction** is a model of `Binary Function`,
   and `BinaryFunction's` `result_type` is convertible to
   `OutputType`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **unary_op** The function to apply to each element of
   the input sequence.

-  **init** The result is initialized to this value.

-  **binary_op** The reduction operation.

**Returns**: The result of the transformed reduction.

**See**:

-  `transform`

-  `reduce`

Reordering
----------
Partitioning
************
**Functions**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   thrust::partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,  
    ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

   template <typename ForwardIterator,
     typename Predicate>
   ForwardIterator
   thrust::partition(ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   thrust::partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

   template <typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   ForwardIterator
   thrust::partition(ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

   template <typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::partition_copy(InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,  
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::partition_copy(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   thrust::stable_partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

   template <typename ForwardIterator,
     typename Predicate>
   ForwardIterator
   thrust::stable_partition(ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   thrust::stable_partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

   template <typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   ForwardIterator
   thrust::stable_partition(ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::stable_partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

   template <typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::stable_partition_copy(InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::stable_partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

   template <typename InputIterator1,
     typename InputIterator2,  
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::stable_partition_copy(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

**thrust::partition**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`partition` reorders the elements `[first, last)` based on
the function object `pred`, such that all of the elements
that satisfy `pred` precede the elements that fail to satisfy
it. The postcondition is that, for some iterator `middle` in
the range `[first, last)`, `pred(*i)` is `true` for every
iterator `i` in the range `[first,middle)` and `false`
for every iterator `i` in the range `[middle, last)`. The
return value of `partition` is `middle`.

Note that the relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition`, does
guarantee to preserve the relative order.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`partition` to reorder a sequence so that even numbers
precede odd numbers using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::partition(thrust::host,
   A, A + N,
   is_even());
   // A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`, and `ForwardIterator`
   is mutable.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements which
do not satisfy `pred`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/partition

-  `stable_partition`

-  `partition_copy`

**thrust::partition**

::

   template <typename ForwardIterator,
     typename Predicate>
   ForwardIterator
   partition(ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`partition` reorders the elements `[first, last)` based on
the function object `pred`, such that all of the elements
that satisfy `pred` precede the elements that fail to satisfy
it. The postcondition is that, for some iterator `middle` in
the range `[first, last)`, `pred(*i)` is `true` for every
iterator `i` in the range `[first,middle)` and `false`
for every iterator `i` in the range `[middle, last)`. The
return value of `partition` is `middle`.

Note that the relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition`, does
guarantee to preserve the relative order.

The following code snippet demonstrates how to use
`partition` to reorder a sequence so that even numbers
precede odd numbers.

::

   #include <thrust/partition.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::partition(A, A + N,
   is_even());
   // A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`, and `ForwardIterator`
   is mutable.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements which
do not satisfy `pred`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/partition

-  `stable_partition`

-  `partition_copy`

**thrust::partition**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

`partition` reorders the elements `[first, last)` based on
the function object `pred` applied to a stencil range
`[stencil, stencil + (last - first))`, such that all of the
elements whose corresponding stencil element satisfies `pred`
precede all of the elements whose corresponding stencil element
fails to satisfy it. The postcondition is that, for some
iterator `middle` in the range `[first, last)`,
`pred(*stencil_i)` is `true` for every iterator
`stencil_i` in the range
`[stencil,stencil + (middle - first))` and `false` for
every iterator `stencil_i` in the range
`[stencil + (middle - first), stencil + (last - first))`. The
return value of `stable_partition` is `middle`.

Note that the relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition`, does
guarantee to preserve the relative order.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`partition` to reorder a sequence so that even numbers
precede odd numbers using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::partition(thrust::host, A, A + N, S, is_even());
   // A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
   // S is unmodified

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The ranges `[first,last)` and
`[stencil, stencil + (last - first))` shall not overlap.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements whose
stencil elements do not satisfy `pred`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/partition

-  `stable_partition`

-  `partition_copy`

**thrust::partition**

::

   template <typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   ForwardIterator
   partition(ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

`partition` reorders the elements `[first, last)` based on
the function object `pred` applied to a stencil range
`[stencil, stencil + (last - first))`, such that all of the
elements whose corresponding stencil element satisfies `pred`
precede all of the elements whose corresponding stencil element
fails to satisfy it. The postcondition is that, for some
iterator `middle` in the range `[first, last)`,
`pred(*stencil_i)` is `true` for every iterator
`stencil_i` in the range
`[stencil,stencil + (middle - first))` and `false` for
every iterator `stencil_i` in the range
`[stencil + (middle - first), stencil + (last - first))`. The
return value of `stable_partition` is `middle`.

Note that the relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition`, does
guarantee to preserve the relative order.

The following code snippet demonstrates how to use
`partition` to reorder a sequence so that even numbers
precede odd numbers.

::

   #include <thrust/partition.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::partition(A, A + N, S, is_even());
   // A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
   // S is unmodified

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The ranges `[first,last)` and
`[stencil, stencil + (last - first))` shall not overlap.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements whose
stencil elements do not satisfy `pred`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/partition

-  `stable_partition`

-  `partition_copy`

**thrust::partition_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`partition_copy` differs from `partition` only in that the
reordered sequence is written to difference output sequences,
rather than in place.

`partition_copy` copies the elements `[first, last)` based
on the function object `pred`. All of the elements that
satisfy `pred` are copied to the range beginning at
`out_true` and all the elements that fail to satisfy it are
copied to the range beginning at `out_false`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`partition_copy` to separate a sequence into two output
sequences of even and odd numbers using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::partition_copy(thrust::host, A, A + N, evens, odds, is_even());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Note**: The relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition_copy`,
does guarantee to preserve the relative order.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type` and
   `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input range shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `stable_partition_copy`

-  `partition`

**thrust::partition_copy**

::

   template <typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   partition_copy(InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`partition_copy` differs from `partition` only in that the
reordered sequence is written to difference output sequences,
rather than in place.

`partition_copy` copies the elements `[first, last)` based
on the function object `pred`. All of the elements that
satisfy `pred` are copied to the range beginning at
`out_true` and all the elements that fail to satisfy it are
copied to the range beginning at `out_false`.

The following code snippet demonstrates how to use
`partition_copy` to separate a sequence into two output
sequences of even and odd numbers.

::

   #include <thrust/partition.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::partition_copy(A, A + N, evens, odds, is_even());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Note**: The relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition_copy`,
does guarantee to preserve the relative order.

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type` and
   `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input range shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `stable_partition_copy`

-  `partition`

**thrust::partition_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`partition_copy` differs from `partition` only in that the
reordered sequence is written to difference output sequences,
rather than in place.

`partition_copy` copies the elements `[first, last)` based
on the function object `pred` which is applied to a range of
stencil elements. All of the elements whose corresponding
stencil element satisfies `pred` are copied to the range
beginning at `out_true` and all the elements whose stencil
element fails to satisfy it are copied to the range beginning
at `out_false`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`partition_copy` to separate a sequence into two output
sequences of even and odd numbers using the `thrust::host`
execution policy for parallelization.

::

   #include <thrust/partition.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::stable_partition_copy(thrust::host, A, A + N, S, evens, odds, thrust::identity<int>());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Note**: The relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition_copy`,
does guarantee to preserve the relative order.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input ranges shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `stable_partition_copy`

-  `partition`

**thrust::partition_copy**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   partition_copy(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`partition_copy` differs from `partition` only in that the
reordered sequence is written to difference output sequences,
rather than in place.

`partition_copy` copies the elements `[first, last)` based
on the function object `pred` which is applied to a range of
stencil elements. All of the elements whose corresponding
stencil element satisfies `pred` are copied to the range
beginning at `out_true` and all the elements whose stencil
element fails to satisfy it are copied to the range beginning
at `out_false`.

The following code snippet demonstrates how to use
`partition_copy` to separate a sequence into two output
sequences of even and odd numbers.

::

   #include <thrust/partition.h>
   #include <thrust/functional.h>
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::stable_partition_copy(A, A + N, S, evens, odds, thrust::identity<int>());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Note**: The relative order of elements in the two reordered
sequences is not necessarily the same as it was in the original
sequence. A different algorithm, `stable_partition_copy`,
does guarantee to preserve the relative order.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence to reorder.

-  **last** The end of the sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input ranges shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `stable_partition_copy`

-  `partition`

**thrust::stable_partition**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   stable_partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`stable_partition` is much like `partition` : it reorders
the elements in the range `[first, last)` based on the
function object `pred`, such that all of the elements that
satisfy `pred` precede all of the elements that fail to
satisfy it. The postcondition is that, for some iterator
`middle` in the range `[first, last)`, `pred(*i)` is
`true` for every iterator `i` in the range
`[first,middle)` and `false` for every iterator `i` in
the range `[middle, last)`. The return value of
`stable_partition` is `middle`.

`stable_partition` differs from `partition` in that
`stable_partition` is guaranteed to preserve relative order.
That is, if `x` and `y` are elements in `[first, last)`,
and `stencil_x` and `stencil_y` are the stencil elements in
corresponding positions within
`[stencil, stencil + (last - first))`, and
`pred(stencil_x) == pred(stencil_y)`, and if `x` precedes
`y`, then it will still be true after `stable_partition`
that `x` precedes `y`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`stable_partition` to reorder a sequence so that even numbers
precede odd numbers using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::stable_partition(thrust::host,
      A, A + N,
      is_even());
   // A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`, and `ForwardIterator`
   is mutable.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements which
do not satisfy pred.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_partition

-  `partition`

-  `stable_partition_copy`

**thrust::stable_partition**

::

   template <typename ForwardIterator,
     typename Predicate>
   ForwardIterator
   stable_partition(ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`stable_partition` is much like `partition` : it reorders
the elements in the range `[first, last)` based on the
function object `pred`, such that all of the elements that
satisfy `pred` precede all of the elements that fail to
satisfy it. The postcondition is that, for some iterator
`middle` in the range `[first, last)`, `pred(*i)` is
`true` for every iterator `i` in the range
`[first,middle)` and `false` for every iterator `i` in
the range `[middle, last)`. The return value of
`stable_partition` is `middle`.

`stable_partition` differs from `partition` in that
`stable_partition` is guaranteed to preserve relative order.
That is, if `x` and `y` are elements in `[first, last)`,
and `stencil_x` and `stencil_y` are the stencil elements in
corresponding positions within
`[stencil, stencil + (last - first))`, and
`pred(stencil_x) == pred(stencil_y)`, and if `x` precedes
`y`, then it will still be true after `stable_partition`
that `x` precedes `y`.

The following code snippet demonstrates how to use
`stable_partition` to reorder a sequence so that even numbers
precede odd numbers.

::

   #include <thrust/partition.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::stable_partition(A, A + N,
      is_even());
   // A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`, and `ForwardIterator`
   is mutable.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements which
do not satisfy pred.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_partition

-  `partition`

-  `stable_partition_copy`

**thrust::stable_partition**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   stable_partition(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

`stable_partition` is much like `partition:` it reorders
the elements in the range `[first, last)` based on the
function object `pred` applied to a stencil range
`[stencil, stencil + (last - first))`, such that all of the
elements whose corresponding stencil element satisfies `pred`
precede all of the elements whose corresponding stencil element
fails to satisfy it. The postcondition is that, for some
iterator `middle` in the range `[first, last)`,
`pred(*stencil_i)` is `true` for every iterator
`stencil_i` in the range
`[stencil,stencil + (middle - first))` and `false` for
every iterator `stencil_i` in the range
`[stencil + (middle - first), stencil + (last - first))`. The
return value of `stable_partition` is `middle`.

`stable_partition` differs from `partition` in that
`stable_partition` is guaranteed to preserve relative order.
That is, if `x` and `y` are elements in `[first, last)`,
such that `pred(x) == pred(y)`, and if `x` precedes `y`,
then it will still be true after `stable_partition` that
`x` precedes `y`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`stable_partition` to reorder a sequence so that even numbers
precede odd numbers using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::stable_partition(thrust::host, A, A + N, S, is_even());
   // A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
   // S is unmodified

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The range `[first, last)` shall not
overlap with the range `[stencil, stencil + (last - first))`.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements whose
stencil elements do not satisfy `pred`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_partition

-  `partition`

-  `stable_partition_copy`

**thrust::stable_partition**

::

   template <typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   ForwardIterator
   stable_partition(ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

`stable_partition` is much like `partition:` it reorders
the elements in the range `[first, last)` based on the
function object `pred` applied to a stencil range
`[stencil, stencil + (last - first))`, such that all of the
elements whose corresponding stencil element satisfies `pred`
precede all of the elements whose corresponding stencil element
fails to satisfy it. The postcondition is that, for some
iterator `middle` in the range `[first, last)`,
`pred(*stencil_i)` is `true` for every iterator
`stencil_i` in the range
`[stencil,stencil + (middle - first))` and `false` for
every iterator `stencil_i` in the range
`[stencil + (middle - first), stencil + (last - first))`. The
return value of `stable_partition` is `middle`.

`stable_partition` differs from `partition` in that
`stable_partition` is guaranteed to preserve relative order.
That is, if `x` and `y` are elements in `[first, last)`,
such that `pred(x) == pred(y)`, and if `x` precedes `y`,
then it will still be true after `stable_partition` that
`x` precedes `y`.

The following code snippet demonstrates how to use
`stable_partition` to reorder a sequence so that even numbers
precede odd numbers.

::

   #include <thrust/partition.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int S[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::stable_partition(A, A + N, S, is_even());
   // A is now {1, 1, 1, 1, 1, 0, 0, 0, 0, 0}
   // S is unmodified

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The range `[first, last)` shall not
overlap with the range `[stencil, stencil + (last - first))`.

**Returns**: An iterator referring to the first element of the
second partition, that is, the sequence of the elements whose
stencil elements do not satisfy `pred`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_partition

-  `partition`

-  `stable_partition_copy`

**thrust::stable_partition_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   stable_partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`stable_partition_copy` differs from `stable_partition`
only in that the reordered sequence is written to different
output sequences, rather than in place.

`stable_partition_copy` copies the elements `[first, last)`
based on the function object `pred`. All of the elements that
satisfy `pred` are copied to the range beginning at
`out_true` and all the elements that fail to satisfy it are
copied to the range beginning at `out_false`.

`stable_partition_copy` differs from `partition_copy` in
that `stable_partition_copy` is guaranteed to preserve
relative order. That is, if `x` and `y` are elements in
`[first, last)`, such that `pred(x) == pred(y)`, and if
`x` precedes `y`, then it will still be true after
`stable_partition_copy` that `x` precedes `y` in the
output.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`stable_partition_copy` to reorder a sequence so that even
numbers precede odd numbers using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::stable_partition_copy(thrust::host, A, A + N, evens, odds, is_even());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type` and
   `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input ranges shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `partition_copy`

-  `stable_partition`

**thrust::stable_partition_copy**

::

   template <typename InputIterator,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   stable_partition_copy(InputIterator first,
     InputIterator last,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`stable_partition_copy` differs from `stable_partition`
only in that the reordered sequence is written to different
output sequences, rather than in place.

`stable_partition_copy` copies the elements `[first, last)`
based on the function object `pred`. All of the elements that
satisfy `pred` are copied to the range beginning at
`out_true` and all the elements that fail to satisfy it are
copied to the range beginning at `out_false`.

`stable_partition_copy` differs from `partition_copy` in
that `stable_partition_copy` is guaranteed to preserve
relative order. That is, if `x` and `y` are elements in
`[first, last)`, such that `pred(x) == pred(y)`, and if
`x` precedes `y`, then it will still be true after
`stable_partition_copy` that `x` precedes `y` in the
output.

The following code snippet demonstrates how to use
`stable_partition_copy` to reorder a sequence so that even
numbers precede odd numbers.

::

   #include <thrust/partition.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::stable_partition_copy(A, A + N, evens, odds, is_even());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type` and
   `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input ranges shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `partition_copy`

-  `stable_partition`

**thrust::stable_partition_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   stable_partition_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`stable_partition_copy` differs from `stable_partition`
only in that the reordered sequence is written to different
output sequences, rather than in place.

`stable_partition_copy` copies the elements `[first, last)`
based on the function object `pred` which is applied to a
range of stencil elements. All of the elements whose
corresponding stencil element satisfies `pred` are copied to
the range beginning at `out_true` and all the elements whose
stencil element fails to satisfy it are copied to the range
beginning at `out_false`.

`stable_partition_copy` differs from `partition_copy` in
that `stable_partition_copy` is guaranteed to preserve
relative order. That is, if `x` and `y` are elements in
`[first, last)`, such that `pred(x) == pred(y)`, and if
`x` precedes `y`, then it will still be true after
`stable_partition_copy` that `x` precedes `y` in the
output.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`stable_partition_copy` to reorder a sequence so that even
numbers precede odd numbers using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/partition.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::stable_partition_copy(thrust::host, A, A + N, S, evens, odds, thrust::identity<int>());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input ranges shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `partition_copy`

-  `stable_partition`

**thrust::stable_partition_copy**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename Predicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   stable_partition_copy(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator1 out_true,
     OutputIterator2 out_false,
     Predicate pred);

`stable_partition_copy` differs from `stable_partition`
only in that the reordered sequence is written to different
output sequences, rather than in place.

`stable_partition_copy` copies the elements `[first, last)`
based on the function object `pred` which is applied to a
range of stencil elements. All of the elements whose
corresponding stencil element satisfies `pred` are copied to
the range beginning at `out_true` and all the elements whose
stencil element fails to satisfy it are copied to the range
beginning at `out_false`.

`stable_partition_copy` differs from `partition_copy` in
that `stable_partition_copy` is guaranteed to preserve
relative order. That is, if `x` and `y` are elements in
`[first, last)`, such that `pred(x) == pred(y)`, and if
`x` precedes `y`, then it will still be true after
`stable_partition_copy` that `x` precedes `y` in the
output.

The following code snippet demonstrates how to use
`stable_partition_copy` to reorder a sequence so that even
numbers precede odd numbers.

::

   #include <thrust/partition.h>
   #include <thrust/functional.h>
   ...
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int S[] = {0, 1, 0, 1, 0, 1, 0, 1, 0,  1};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   int *evens = result;
   int *odds  = result + 5;
   thrust::stable_partition_copy(A, A + N, S, evens, odds, thrust::identity<int>());
   // A remains {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   // S remains {0, 1, 0, 1, 0, 1, 0, 1, 0,  1}
   // result is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}
   // evens points to {2, 4, 6, 8, 10}
   // odds points to {1, 3, 5, 7, 9}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `OutputIterator1` and
   `OutputIterator2's` `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The first element of the sequence to reorder.

-  **last** One position past the last element of the
   sequence to reorder.

-  **stencil** The beginning of the stencil sequence.

-  **out_true** The destination of the resulting sequence
   of elements which satisfy `pred`.

-  **out_false** The destination of the resulting sequence
   of elements which fail to satisfy `pred`.

-  **pred** A function object which decides to which
   partition each element of the sequence `[first, last)`
   belongs.

**Preconditions**: The input ranges shall not overlap with
either output range.

**Returns**: A `pair` p such that `p.first` is the end of
the output range beginning at `out_true` and `p.second` is
the end of the output range beginning at `out_false`.

**See**:

-  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2569.pdf

-  `partition_copy`

-  `stable_partition`

Shuffling
*********
**Shuffling**

::

   template <typename DerivedPolicy,
     typename RandomIterator,
     typename URBG>
   __host__ __device__ void
   thrust::shuffle(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomIterator first,
     RandomIterator last,
     URBG && g);

   template <typename RandomIterator,
     typename URBG>
   __host__ __device__ void
   thrust::shuffle(RandomIterator first,
     RandomIterator last,
     URBG && g);

   template <typename DerivedPolicy,
     typename RandomIterator,
     typename OutputIterator,
     typename URBG>
   __host__ __device__ void
   thrust::shuffle_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomIterator first,
     RandomIterator last,
     OutputIterator result,
     URBG && g);

   template <typename RandomIterator,
     typename OutputIterator,
     typename URBG>
   __host__ __device__ void
   thrust::shuffle_copy(RandomIterator first,
     RandomIterator last,
     OutputIterator result,
     URBG && g);

**thrust::shuffle**

::

   template <typename DerivedPolicy,
     typename RandomIterator,
     typename URBG>
   __host__ __device__ void
   shuffle(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomIterator first,
     RandomIterator last,
     URBG && g);

`shuffle` reorders the elements `[first, last)` by a
uniform pseudorandom permutation, defined by random engine
`g`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `shuffle`
to create a random permutation using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/shuffle.h>
   #include <thrust/random.h>
   #include <thrust/execution_policy.h>
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::default_random_engine g;
   thrust::shuffle(thrust::host, A, A + N, g);
   // A is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomIterator** is a random access iterator

-  **URBG** is a uniform random bit generator

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to shuffle.

-  **last** The end of the sequence to shuffle.

-  **g** A UniformRandomBitGenerator

**See**: `shuffle_copy`

**thrust::shuffle**

::

   template <typename RandomIterator,
     typename URBG>
   __host__ __device__ void
   shuffle(RandomIterator first,
     RandomIterator last,
     URBG && g);

`shuffle` reorders the elements `[first, last)` by a
uniform pseudorandom permutation, defined by random engine
`g`.

The following code snippet demonstrates how to use `shuffle`
to create a random permutation.

::

   #include <thrust/shuffle.h>
   #include <thrust/random.h>
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   const int N = sizeof(A)/sizeof(int);
   thrust::default_random_engine g;
   thrust::shuffle(A, A + N, g);
   // A is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}

**Template Parameters**:

-  **RandomIterator** is a random access iterator

-  **URBG** is a uniform random bit generator

**Function Parameters**:

-  **first** The beginning of the sequence to shuffle.

-  **last** The end of the sequence to shuffle.

-  **g** A UniformRandomBitGenerator

**See**: `shuffle_copy`

**thrust::shuffle_copy**

::

   template <typename DerivedPolicy,
     typename RandomIterator,
     typename OutputIterator,
     typename URBG>
   __host__ __device__ void
   shuffle_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomIterator first,
     RandomIterator last,
     OutputIterator result,
     URBG && g);

shuffle_copy differs from shuffle only in that the reordered
sequence is written to different output sequences, rather than
in place. `shuffle_copy` reorders the elements
`[first, last)` by a uniform pseudorandom permutation,
defined by random engine `g`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`shuffle_copy` to create a random permutation.

::

   #include <thrust/shuffle.h>
   #include <thrust/random.h>
   #include <thrust/execution_policy.h>
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   thrust::default_random_engine g;
   thrust::shuffle_copy(thrust::host, A, A + N, result, g);
   // result is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomIterator** is a random access iterator

-  **OutputIterator** is a model of `Output Iterator`.

-  **URBG** is a uniform random bit generator

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to shuffle.

-  **last** The end of the sequence to shuffle.

-  **result** Destination of shuffled sequence

-  **g** A UniformRandomBitGenerator

**See**: `shuffle`

**thrust::shuffle_copy**

::

   template <typename RandomIterator,
     typename OutputIterator,
     typename URBG>
   __host__ __device__ void
   shuffle_copy(RandomIterator first,
     RandomIterator last,
     OutputIterator result,
     URBG && g);

shuffle_copy differs from shuffle only in that the reordered
sequence is written to different output sequences, rather than
in place. `shuffle_copy` reorders the elements
`[first, last)` by a uniform pseudorandom permutation,
defined by random engine `g`.

The following code snippet demonstrates how to use
`shuffle_copy` to create a random permutation.

::

   #include <thrust/shuffle.h>
   #include <thrust/random.h>
   int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   int result[10];
   const int N = sizeof(A)/sizeof(int);
   thrust::default_random_engine g;
   thrust::shuffle_copy(A, A + N, result, g);
   // result is now {6, 5, 8, 7, 2, 1, 4, 3, 10, 9}

**Template Parameters**:

-  **RandomIterator** is a random access iterator

-  **OutputIterator** is a model of `Output Iterator`.

-  **URBG** is a uniform random bit generator

**Function Parameters**:

-  **first** The beginning of the sequence to shuffle.

-  **last** The end of the sequence to shuffle.

-  **result** Destination of shuffled sequence

-  **g** A UniformRandomBitGenerator

**See**: `shuffle`

Stream Compaction
*****************
**Stream Compaction**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   thrust::copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred);

   template <typename InputIterator,
     typename OutputIterator,
     typename Predicate>
   OutputIterator
   thrust::copy_if(InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   thrust::copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
      Predicate pred);

    template <typename InputIterator1,
      typename InputIterator2,
      typename OutputIterator,
      typename Predicate>
    OutputIterator
    thrust::copy_if(InputIterator1 first,
      InputIterator1 last,
      InputIterator2 stencil,
      OutputIterator result,
      Predicate pred);

    template <typename DerivedPolicy,
      typename ForwardIterator,
      typename T>
    __host__ __device__ ForwardIterator
    thrust::remove(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
      ForwardIterator first,
      ForwardIterator last,
      const T & value);

    template <typename ForwardIterator,
       typename T>
     ForwardIterator
     thrust::remove(ForwardIterator first,
       ForwardIterator last,
       const T & value);

     template <typename DerivedPolicy,
       typename InputIterator,
       typename OutputIterator,
       typename T>
     __host__ __device__ OutputIterator
     thrust::remove_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
       InputIterator first,
       InputIterator last,
       OutputIterator result,
       const T & value);

     template <typename InputIterator,
       typename OutputIterator,
       typename T>
     OutputIterator
     thrust::remove_copy(InputIterator first,
       InputIterator last,
       OutputIterator result,
       const T & value);

     template <typename DerivedPolicy,
       typename ForwardIterator,
       typename Predicate>
     __host__ __device__ ForwardIterator
     thrust::remove_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
       ForwardIterator first,
       ForwardIterator last,
       Predicate pred);

     template <typename ForwardIterator,
       typename Predicate>
     ForwardIterator
     thrust::remove_if(ForwardIterator first,
       ForwardIterator last,
       Predicate pred);

     template <typename DerivedPolicy,
       typename InputIterator,
       typename OutputIterator,
       typename Predicate>
     __host__ __device__ OutputIterator
     thrust::remove_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
       InputIterator first,
       InputIterator last,
       OutputIterator result,
       Predicate pred);

     template <typename InputIterator,
       typename OutputIterator,
       typename Predicate>
     OutputIterator
     thrust::remove_copy_if(InputIterator first,
       InputIterator last,
       OutputIterator result,
       Predicate pred);

     template <typename DerivedPolicy,
       typename ForwardIterator,
       typename InputIterator,
       typename Predicate>
     __host__ __device__ ForwardIterator
     thrust::remove_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
       ForwardIterator first,
       ForwardIterator last,
       InputIterator stencil,
       Predicate pred);

     template <typename ForwardIterator,
       typename InputIterator,
       typename Predicate>
     ForwardIterator
     thrust::remove_if(ForwardIterator first,
       ForwardIterator last,
       InputIterator stencil,
       Predicate pred);

     template <typename DerivedPolicy,
       typename InputIterator1,
       typename InputIterator2,
       typename OutputIterator,
       typename Predicate>
     __host__ __device__ OutputIterator
     thrust::remove_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
       InputIterator1 first,
       InputIterator1 last,
       InputIterator2 stencil,
       OutputIterator result,
       Predicate pred);

     template <typename InputIterator1,
       typename InputIterator2,
       typename OutputIterator,
       typename Predicate>
   OutputIterator
   thrust::remove_copy_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred);

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   thrust::unique(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator>
   ForwardIterator thrust::unique(ForwardIterator first,
     ForwardIterator last);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ ForwardIterator
   thrust::unique(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

   template <typename ForwardIterator,
     typename BinaryPredicate>
   ForwardIterator
   thrust::unique(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::unique_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   thrust::unique_copy(InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename BinaryPredicate>
   __host__ __device__ OutputIterator
   thrust::unique_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryPredicate binary_pred);

   template <typename InputIterator,
     typename OutputIterator,
     typename BinaryPredicate>
   OutputIterator
   thrust::unique_copy(InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename ForwardIterator1,
     typename ForwardIterator2>
   __host__ __device__ thrust::pair< ForwardIterator1, ForwardIterator2 >
   thrust::unique_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first);

   template <typename ForwardIterator1,
     typename ForwardIterator2>
   thrust::pair< ForwardIterator1, ForwardIterator2 >
   thrust::unique_by_key(ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first);

   template <typename DerivedPolicy,
     typename ForwardIterator1,
     typename ForwardIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< ForwardIterator1, ForwardIterator2 >
   thrust::unique_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first,
     BinaryPredicate binary_pred);

   template <typename ForwardIterator1,
     typename ForwardIterator2,
     typename BinaryPredicate>
   thrust::pair< ForwardIterator1, ForwardIterator2 >
   thrust::unique_by_key(ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::unique_by_key_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::unique_by_key_copy(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,  
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::unique_by_key_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     BinaryPredicate binary_pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::unique_by_key_copy(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   thrust::unique_count(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   thrust::unique_count(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   thrust::unique_count(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

   template <typename ForwardIterator>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   thrust::unique_count(ForwardIterator first,
     ForwardIterator last);

**thrust::copy_if**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred);

This version of `copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that any element which causes `pred` to be `false` is not
copied. `copy_if` is stable, meaning that the relative order
of elements that are copied is unchanged.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `copy_if` performs the assignment
`*result = *(first+n)` and `result` is advanced one
position if `pred(*(first+n))`. Otherwise, no assignment
occurs and `result` is not advanced.

The algorithm’s execution is parallelized as determined by
`system`.

The following code snippet demonstrates how to use `copy_if`
to perform stream compaction to copy even numbers to an output
range using the `thrust::host` parallelization policy:

::

   #include <thrust/copy.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int result[4];

   thrust::copy_if(thrust::host, V, V + N, result, is_even());

   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-2, 0, 0, 2}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence from which to
   copy.

-  **last** The end of the sequence from which to copy.

-  **result** The beginning of the sequence into which to
   copy.

-  **pred** The predicate to test on every value of the
   range `[first, last)`.

**Preconditions**: The ranges `[first, last)` and
`[result, result + (last - first))` shall not overlap.

**Returns**: `result + n`, where `n` is equal to the number
of times `pred` evaluated to `true` in the range
`[first, last)`.

**See**: `remove_copy_if`

**thrust::copy_if**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename Predicate>
   OutputIterator
   copy_if(InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred);

This version of `copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that any element which causes `pred` to `false` is not
copied. `copy_if` is stable, meaning that the relative order
of elements that are copied is unchanged.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `copy_if` performs the assignment
`*result = *(first+n)` and `result` is advanced one
position if `pred(*(first+n))`. Otherwise, no assignment
occurs and `result` is not advanced.

The following code snippet demonstrates how to use `copy_if`
to perform stream compaction to copy even numbers to an output
range.

::

   #include <thrust/copy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int result[4];

   thrust::copy_if(V, V + N, result, is_even());

   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-2, 0, 0, 2}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence from which to
   copy.

-  **last** The end of the sequence from which to copy.

-  **result** The beginning of the sequence into which to
   copy.

-  **pred** The predicate to test on every value of the
   range `[first, last)`.

**Preconditions**: The ranges `[first, last)` and
`[result, result + (last - first))` shall not overlap.

**Returns**: `result + n`, where `n` is equal to the number
of times `pred` evaluated to `true` in the range
`[first, last)`.

**See**: `remove_copy_if`

**thrust::copy_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred);

This version of `copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that any element whose corresponding stencil element causes
`pred` to be `false` is not copied. `copy_if` is stable,
meaning that the relative order of elements that are copied is
unchanged.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `copy_if` performs the assignment
`*result = *(first+n)` and `result` is advanced one
position if `pred(*(stencil+n))`. Otherwise, no assignment
occurs and `result` is not advanced.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `copy_if`
to perform stream compaction to copy numbers to an output range
when corresponding stencil elements are even using the
`thrust::host` execution policy:

::

   #include <thrust/copy.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int N = 6;
   int data[N]    = { 0, 1,  2, 3, 4, 5};
   int stencil[N] = {-2, 0, -1, 0, 1, 2};
   int result[4];

   thrust::copy_if(thrust::host, data, data + N, stencil, result, is_even());

   // data remains    = { 0, 1,  2, 3, 4, 5};
   // stencil remains = {-2, 0, -1, 0, 1, 2};
   // result is now     { 0, 1,  3, 5}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence from which to
   copy.

-  **last** The end of the sequence from which to copy.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the sequence into which to
   copy.

-  **pred** The predicate to test on every value of the
   range `[stencil, stencil + (last-first))`.

**Preconditions**:

-  The ranges `[first, last)` and
   `[result, result + (last - first))` shall not overlap.

-  The ranges `[stencil, stencil + (last - first))` and
   `[result, result + (last - first))` shall not overlap.

**Returns**: `result + n`, where `n` is equal to the number
of times `pred` evaluated to `true` in the range
`[stencil, stencil + (last-first))`.

**See**: `remove_copy_if`

**thrust::copy_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate>
   OutputIterator
   copy_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred);

This version of `copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that any element whose corresponding stencil element causes
`pred` to be `false` is not copied. `copy_if` is stable,
meaning that the relative order of elements that are copied is
unchanged.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `copy_if` performs the assignment
`*result = *(first+n)` and `result` is advanced one
position if `pred(*(stencil+n))`. Otherwise, no assignment
occurs and `result` is not advanced.

The following code snippet demonstrates how to use `copy_if`
to perform stream compaction to copy numbers to an output range
when corresponding stencil elements are even:

::

   #include <thrust/copy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   int N = 6;
   int data[N]    = { 0, 1,  2, 3, 4, 5};
   int stencil[N] = {-2, 0, -1, 0, 1, 2};
   int result[4];

   thrust::copy_if(data, data + N, stencil, result, is_even());

   // data remains    = { 0, 1,  2, 3, 4, 5};
   // stencil remains = {-2, 0, -1, 0, 1, 2};
   // result is now     { 0, 1,  3, 5}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the sequence from which to
   copy.

-  **last** The end of the sequence from which to copy.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the sequence into which to
   copy.

-  **pred** The predicate to test on every value of the
   range `[stencil, stencil + (last-first))`.

**Preconditions**:

-  The ranges `[first, last)` and
   `[result, result + (last - first))` shall not overlap.

-  The ranges `[stencil, stencil + (last - first))` and
   `[result, result + (last - first))` shall not overlap.

**Returns**: `result + n`, where `n` is equal to the number
of times `pred` evaluated to `true` in the range
`[stencil, stencil + (last-first))`.

**See**: `remove_copy_if`

**thrust::remove**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ ForwardIterator
   remove(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,  
     ForwardIterator last,
     const T & value);

`remove` removes from the range `[first, last)` all
elements that are equal to `value`. That is, `remove`
returns an iterator `new_last` such that the range
`[first, new_last)` contains no elements equal to `value`.
The iterators in the range `[new_first,last)` are all still
dereferenceable, but the elements that they point to are
unspecified. `remove` is stable, meaning that the relative
order of elements that are not equal to `value` is unchanged.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `remove`
to remove a number of interest from a range using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/remove.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int A[N] = {3, 1, 4, 1, 5, 9};
   int *new_end = thrust::remove(A, A + N, 1);
   // The first four values of A are now {3, 4, 5, 9}
   // Values beyond new_end are unspecified

**Note**: The meaning of “removal” is somewhat subtle.
`remove` does not destroy any iterators, and does not change
the distance between `first` and `last`. (There’s no way
that it could do anything of the sort.) So, for example, if
`V` is a
`device_vector`,
`remove(V.begin(), V.end(), 0)` does not change `V.size()`:
`V` will contain just as many elements as it did before.
`remove` returns an iterator that points to the end of the
resulting range after elements have been removed from it; it
follows that the elements after that iterator are of no
interest, and may be discarded. If you are removing elements
from a
`Sequence`, you
may simply erase them. That is, a reasonable way of removing
elements from a
`Sequence` is
`S.erase(remove(S.begin(), S.end(), x), S.end())`.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **T** is a model of `Equality Comparable`,
   and objects of type `T` can be compared for equality with
   objects of `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **value** The value to remove from the range
   `[first, last)`. Elements which are equal to value are
   removed from the sequence.

**Returns**: A `ForwardIterator` pointing to the end of the
resulting range of elements which are not equal to `value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove

-  remove_if

-  remove_copy

-  remove_copy_if

**thrust::remove**

::

   template <typename ForwardIterator,
     typename T>
   ForwardIterator
   remove(ForwardIterator first,
     ForwardIterator last,
     const T & value);

`remove` removes from the range `[first, last)` all
elements that are equal to `value`. That is, `remove`
returns an iterator `new_last` such that the range
`[first, new_last)` contains no elements equal to `value`.
The iterators in the range `[new_first,last)` are all still
dereferenceable, but the elements that they point to are
unspecified. `remove` is stable, meaning that the relative
order of elements that are not equal to `value` is unchanged.

The following code snippet demonstrates how to use `remove`
to remove a number of interest from a range.

::

   #include <thrust/remove.h>
   ...
   const int N = 6;
   int A[N] = {3, 1, 4, 1, 5, 9};
   int *new_end = thrust::remove(A, A + N, 1);
   // The first four values of A are now {3, 4, 5, 9}
   // Values beyond new_end are unspecified

**Note**: The meaning of “removal” is somewhat subtle.
`remove` does not destroy any iterators, and does not change
the distance between `first` and `last`. (There’s no way
that it could do anything of the sort.) So, for example, if
`V` is a
`device_vector`,
`remove(V.begin(), V.end(), 0)` does not change `V.size()`:
`V` will contain just as many elements as it did before.
`remove` returns an iterator that points to the end of the
resulting range after elements have been removed from it; it
follows that the elements after that iterator are of no
interest, and may be discarded. If you are removing elements
from a
`Sequence`, you
may simply erase them. That is, a reasonable way of removing
elements from a
`Sequence` is
`S.erase(remove(S.begin(), S.end(), x), S.end())`.

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **T** is a model of `Equality Comparable`,
   and objects of type `T` can be compared for equality with
   objects of `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **value** The value to remove from the range
   `[first, last)`. Elements which are equal to value are
   removed from the sequence.

**Returns**: A `ForwardIterator` pointing to the end of the
resulting range of elements which are not equal to `value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove

-  remove_if

-  remove_copy

-  remove_copy_if

**thrust::remove_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename T>
   __host__ __device__ OutputIterator
   remove_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     const T & value);

`remove_copy` copies elements that are not equal to `value`
from the range `[first, last)` to a range beginning at
`result`. The return value is the end of the resulting range.
This operation is stable, meaning that the relative order of
the elements that are copied is the same as in the range
`[first, last)`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`remove_copy` to copy a sequence of numbers to an output
range while omitting a value of interest using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/remove.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int result[N-2];
   thrust::remove_copy(thrust::host, V, V + N, result, 0);
   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-2, -1, 1, 2}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **T** is a model of `Equality Comparable`,
   and objects of type `T` can be compared for equality with
   objects of `InputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **result** The resulting range is copied to the sequence
   beginning at this location.

-  **value** The value to omit from the copied range.

**Preconditions**: The range `[first, last)` shall not
overlap the range `[result, result + (last - first))`.

**Returns**: An OutputIterator pointing to the end of the
resulting range of elements which are not equal to `value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove_copy

-  remove

-  remove_if

-  remove_copy_if

**thrust::remove_copy**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename T>
   OutputIterator
   remove_copy(InputIterator first,
     InputIterator last,
     OutputIterator result,
     const T & value);

`remove_copy` copies elements that are not equal to `value`
from the range `[first, last)` to a range beginning at
`result`. The return value is the end of the resulting range.
This operation is stable, meaning that the relative order of
the elements that are copied is the same as in the range
`[first, last)`.

The following code snippet demonstrates how to use
`remove_copy` to copy a sequence of numbers to an output
range while omitting a value of interest.

::

   #include <thrust/remove.h>
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int result[N-2];
   thrust::remove_copy(V, V + N, result, 0);
   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-2, -1, 1, 2}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **T** is a model of `Equality Comparable`,
   and objects of type `T` can be compared for equality with
   objects of `InputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **result** The resulting range is copied to the sequence
   beginning at this location.

-  **value** The value to omit from the copied range.

**Preconditions**: The range `[first, last)` shall not
overlap the range `[result, result + (last - first))`.

**Returns**: An OutputIterator pointing to the end of the
resulting range of elements which are not equal to `value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove_copy

-  remove

-  remove_if

-  remove_copy_if

**thrust::remove_if**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   remove_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`remove_if` removes from the range `[first, last)` every
element `x` such that `pred(x)` is `true`. That is,
`remove_if` returns an iterator `new_last` such that the
range `[first,new_last)` contains no elements for which
`pred` is `true`. The iterators in the range
`[new_last,last)` are all still dereferenceable, but the
elements that they point to are unspecified. `remove_if` is
stable, meaning that the relative order of elements that are
not removed is unchanged.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`remove_if` to remove all even numbers from an array of
integers using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/remove.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   int *new_end = thrust::remove_if(thrust::host, A, A + N, is_even());
   // The first three values of A are now {1, 5, 7}
   // Values beyond new_end are unspecified

**Note**: The meaning of “removal” is somewhat subtle.
`remove_if` does not destroy any iterators, and does not
change the distance between `first` and `last`. (There’s no
way that it could do anything of the sort.) So, for example, if
`V` is a
`device_vector`,
`remove_if(V.begin(), V.end(), pred)` does not change
`V.size()`: `V` will contain just as many elements as it
did before. `remove_if` returns an iterator that points to
the end of the resulting range after elements have been removed
from it; it follows that the elements after that iterator are
of no interest, and may be discarded. If you are removing
elements from a
`Sequence`, you
may simply erase them. That is, a reasonable way of removing
elements from a
`Sequence` is
`S.erase(remove_if(S.begin(), S.end(), pred), S.end())`.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **pred** A predicate to evaluate for each element of the
   range `[first,last)`. Elements for which `pred`
   evaluates to `true` are removed from the sequence.

**Returns**: A ForwardIterator pointing to the end of the
resulting range of elements for which `pred` evaluated to
`true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove

-  remove

-  remove_copy

-  remove_copy_if

**thrust::remove_if**

::

   template <typename ForwardIterator,
     typename Predicate>
   ForwardIterator
   remove_if(ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`remove_if` removes from the range `[first, last)` every
element `x` such that `pred(x)` is `true`. That is,
`remove_if` returns an iterator `new_last` such that the
range `[first,new_last)` contains no elements for which
`pred` is `true`. The iterators in the range
`[new_last,last)` are all still dereferenceable, but the
elements that they point to are unspecified. `remove_if` is
stable, meaning that the relative order of elements that are
not removed is unchanged.

The following code snippet demonstrates how to use
`remove_if` to remove all even numbers from an array of
integers.

::

   #include <thrust/remove.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   int *new_end = thrust::remove_if(A, A + N, is_even());
   // The first three values of A are now {1, 5, 7}
   // Values beyond new_end are unspecified

**Note**: The meaning of “removal” is somewhat subtle.
`remove_if` does not destroy any iterators, and does not
change the distance between `first` and `last`. (There’s no
way that it could do anything of the sort.) So, for example, if
`V` is a
`device_vector`,
`remove_if(V.begin(), V.end(), pred)` does not change
`V.size()`: `V` will contain just as many elements as it
did before. `remove_if` returns an iterator that points to
the end of the resulting range after elements have been removed
from it; it follows that the elements after that iterator are
of no interest, and may be discarded. If you are removing
elements from a
`Sequence`, you
may simply erase them. That is, a reasonable way of removing
elements from a
`Sequence` is
`S.erase(remove_if(S.begin(), S.end(), pred), S.end())`.

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **pred** A predicate to evaluate for each element of the
   range `[first,last)`. Elements for which `pred`
   evaluates to `true` are removed from the sequence.

**Returns**: A ForwardIterator pointing to the end of the
resulting range of elements for which `pred` evaluated to
`true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove

-  remove

-  remove_copy

-  remove_copy_if

**thrust::remove_copy_if**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   remove_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred);

`remove_copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that elements for which `pred` is `true` are not copied.
The return value is the end of the resulting range. This
operation is stable, meaning that the relative order of the
elements that are copied is the same as the range
`[first,last)`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`remove_copy_if` to copy a sequence of numbers to an output
range while omitting even numbers using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/remove.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int result[2];
   thrust::remove_copy_if(thrust::host, V, V + N, result, is_even());
   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-1, 1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   `InputIterator's` `value_type` is convertible to a type
   in `OutputIterator's` set of `value_types`, and
   `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **result** The resulting range is copied to the sequence
   beginning at this location.

-  **pred** A predicate to evaluate for each element of the
   range `[first,last)`. Elements for which `pred`
   evaluates to `false` are not copied to the resulting
   sequence.

**Preconditions**: The range `[first, last)` shall not
overlap the range `[result, result + (last - first))`.

**Returns**: An OutputIterator pointing to the end of the
resulting range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove_copy

-  remove

-  remove_copy

-  remove_if

**thrust::remove_copy_if**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename Predicate>
   OutputIterator
   remove_copy_if(InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred);

`remove_copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that elements for which `pred` is `true` are not copied.
The return value is the end of the resulting range. This
operation is stable, meaning that the relative order of the
elements that are copied is the same as the range
`[first,last)`.

The following code snippet demonstrates how to use
`remove_copy_if` to copy a sequence of numbers to an output
range while omitting even numbers.

::

   #include <thrust/remove.h>
   ...
   struct is_even
   {
   __host__ __device__
   bool operator()(const int x)
   {
      return (x % 2) == 0;
   }
   };
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int result[2];
   thrust::remove_copy_if(V, V + N, result, is_even());
   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-1, 1}

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   `InputIterator's` `value_type` is convertible to a type
   in `OutputIterator's` set of `value_types`, and
   `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **result** The resulting range is copied to the sequence
   beginning at this location.

-  **pred** A predicate to evaluate for each element of the
   range `[first,last)`. Elements for which `pred`
   evaluates to `false` are not copied to the resulting
   sequence.

**Preconditions**: The range `[first, last)` shall not
overlap the range `[result, result + (last - first))`.

**Returns**: An OutputIterator pointing to the end of the
resulting range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove_copy

-  remove

-  remove_copy

-  remove_if

**thrust::remove_if**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   remove_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

`remove_if` removes from the range `[first, last)` every
element `x` such that `pred(x)` is `true`. That is,
`remove_if` returns an iterator `new_last` such that the
range `[first, new_last)` contains no elements for which
`pred` of the corresponding stencil value is `true`. The
iterators in the range `[new_last,last)` are all still
dereferenceable, but the elements that they point to are
unspecified. `remove_if` is stable, meaning that the relative
order of elements that are not removed is unchanged.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`remove_if` to remove specific elements from an array of
integers using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/remove.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   int S[N] = {0, 1, 1, 1, 0, 0};

   int *new_end = thrust::remove_if(thrust::host, A, A + N, S, thrust::identity<int>());
   // The first three values of A are now {1, 5, 7}
   // Values beyond new_end are unspecified

**Note**: The range `[first, last)` is not permitted to
overlap with the range `[stencil, stencil + (last - first))`.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **stencil** The beginning of the stencil sequence.

-  **pred** A predicate to evaluate for each element of the
   range `[stencil, stencil + (last - first))`. Elements for
   which `pred` evaluates to `true` are removed from the
   sequence `[first, last)`

**Preconditions**:

-  The range `[first, last)` shall not overlap the range
   `[result, result + (last - first))`.

-  The range `[stencil, stencil + (last - first))` shall not
   overlap the range `[result, result + (last - first))`.

**Returns**: A ForwardIterator pointing to the end of the
resulting range of elements for which `pred` evaluated to
`true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove

-  remove

-  remove_copy

-  remove_copy_if

**thrust::remove_if**

::

   template <typename ForwardIterator,
     typename InputIterator,
     typename Predicate>
   ForwardIterator
   remove_if(ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred);

`remove_if` removes from the range `[first, last)` every
element `x` such that `pred(x)` is `true`. That is,
`remove_if` returns an iterator `new_last` such that the
range `[first, new_last)` contains no elements for which
`pred` of the corresponding stencil value is `true`. The
iterators in the range `[new_last,last)` are all still
dereferenceable, but the elements that they point to are
unspecified. `remove_if` is stable, meaning that the relative
order of elements that are not removed is unchanged.

The following code snippet demonstrates how to use
`remove_if` to remove specific elements from an array of
integers.

::

   #include <thrust/remove.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   int S[N] = {0, 1, 1, 1, 0, 0};

   int *new_end = thrust::remove_if(A, A + N, S, thrust::identity<int>());
   // The first three values of A are now {1, 5, 7}
   // Values beyond new_end are unspecified

**Note**: The range `[first, last)` is not permitted to
overlap with the range `[stencil, stencil + (last - first))`.

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **stencil** The beginning of the stencil sequence.

-  **pred** A predicate to evaluate for each element of the
   range `[stencil, stencil + (last - first))`. Elements for
   which `pred` evaluates to `true` are removed from the
   sequence `[first, last)`

**Preconditions**:

-  The range `[first, last)` shall not overlap the range
   `[result, result + (last - first))`.

-  The range `[stencil, stencil + (last - first))` shall not
   overlap the range `[result, result + (last - first))`.

**Returns**: A ForwardIterator pointing to the end of the
resulting range of elements for which `pred` evaluated to
`true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove

-  remove

-  remove_copy

-  remove_copy_if

**thrust::remove_copy_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate>
   __host__ __device__ OutputIterator
   remove_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred);

`remove_copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that elements for which `pred` of the corresponding stencil
value is `true` are not copied. The return value is the end
of the resulting range. This operation is stable, meaning that
the relative order of the elements that are copied is the same
as the range `[first,last)`.

The algorithm’s execution policy is parallelized as determined
by `exec`.

The following code snippet demonstrates how to use
`remove_copy_if` to copy a sequence of numbers to an output
range while omitting specific elements using the
`thrust::host` execution policy for parallelization.

::

   #include <thrust/remove.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int S[N] = { 1, 1,  0, 1, 0, 1};
   int result[2];
   thrust::remove_copy_if(thrust::host, V, V + N, S, result, thrust::identity<int>());
   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-1, 1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **stencil** The beginning of the stencil sequence.

-  **result** The resulting range is copied to the sequence
   beginning at this location.

-  **pred** A predicate to evaluate for each element of the
   range `[first,last)`. Elements for which `pred`
   evaluates to `false` are not copied to the resulting
   sequence.

**Preconditions**: The range
`[stencil, stencil + (last - first))` shall not overlap the
range `[result, result + (last - first))`.

**Returns**: An OutputIterator pointing to the end of the
resulting range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove_copy

-  remove

-  remove_copy

-  remove_if

-  copy_if

**thrust::remove_copy_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate>
   OutputIterator
   remove_copy_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred);

`remove_copy_if` copies elements from the range
`[first,last)` to a range beginning at `result`, except
that elements for which `pred` of the corresponding stencil
value is `true` are not copied. The return value is the end
of the resulting range. This operation is stable, meaning that
the relative order of the elements that are copied is the same
as the range `[first,last)`.

The following code snippet demonstrates how to use
`remove_copy_if` to copy a sequence of numbers to an output
range while omitting specific elements.

::

   #include <thrust/remove.h>
   ...
   const int N = 6;
   int V[N] = {-2, 0, -1, 0, 1, 2};
   int S[N] = { 1, 1,  0, 1, 0, 1};
   int result[2];
   thrust::remove_copy_if(V, V + N, S, result, thrust::identity<int>());
   // V remains {-2, 0, -1, 0, 1, 2}
   // result is now {-1, 1}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the range of interest.

-  **last** The end of the range of interest.

-  **stencil** The beginning of the stencil sequence.

-  **result** The resulting range is copied to the sequence
   beginning at this location.

-  **pred** A predicate to evaluate for each element of the
   range `[first,last)`. Elements for which `pred`
   evaluates to `false` are not copied to the resulting
   sequence.

**Preconditions**: The range
`[stencil, stencil + (last - first))` shall not overlap the
range `[result, result + (last - first))`.

**Returns**: An OutputIterator pointing to the end of the
resulting range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/remove_copy

-  remove

-  remove_copy

-  remove_if

-  copy_if

**thrust::unique**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ ForwardIterator
   unique(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

For each group of consecutive elements in the range
`[first, last)` with the same value, `unique` removes all
but the first element of the group. The return value is an
iterator `new_last` such that no two consecutive elements in
the range `[first, new_last)` are equal. The iterators in the
range `[new_last, last)` are all still dereferenceable, but
the elements that they point to are unspecified. `unique` is
stable, meaning that the relative order of elements that are
not removed is unchanged.

This version of `unique` uses `operator==` to test for
equality.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `unique`
to compact a sequence of numbers to remove consecutive
duplicates using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int *new_end = thrust::unique(thrust::host, A, A + N);
   // The first four values of A are now {1, 3, 2, 1}
   // Values beyond new_end are unspecified.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` is a model of
   `Equality Comparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

**Returns**: The end of the unique range `[first, new_last)`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/unique

-  unique_copy

**thrust::unique**

::

   template <typename ForwardIterator>
   ForwardIterator
   unique(ForwardIterator first,
     ForwardIterator last);

For each group of consecutive elements in the range
`[first, last)` with the same value, `unique` removes all
but the first element of the group. The return value is an
iterator `new_last` such that no two consecutive elements in
the range `[first, new_last)` are equal. The iterators in the
range `[new_last, last)` are all still dereferenceable, but
the elements that they point to are unspecified. `unique` is
stable, meaning that the relative order of elements that are
not removed is unchanged.

This version of `unique` uses `operator==` to test for
equality.

The following code snippet demonstrates how to use `unique`
to compact a sequence of numbers to remove consecutive
duplicates.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int *new_end = thrust::unique(A, A + N);
   // The first four values of A are now {1, 3, 2, 1}
   // Values beyond new_end are unspecified.

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
and `ForwardIterator` is mutable, and
`ForwardIterator's` `value_type` is a model of `Equality Comparable`.

**Function Parameters**:

-  **first** The beginning of the input range.

-  **last** The end of the input range.

**Returns**: The end of the unique range `[first, new_last)`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/unique

-  unique_copy

**thrust::unique**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ ForwardIterator
   unique(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

For each group of consecutive elements in the range
`[first, last)` with the same value, `unique` removes all
but the first element of the group. The return value is an
iterator `new_last` such that no two consecutive elements in
the range `[first, new_last)` are equal. The iterators in the
range `[new_last, last)` are all still dereferenceable, but
the elements that they point to are unspecified. `unique` is
stable, meaning that the relative order of elements that are
not removed is unchanged.

This version of `unique` uses the function object
`binary_pred` to test for equality.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `unique`
to compact a sequence of numbers to remove consecutive
duplicates using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int *new_end = thrust::unique(thrust::host, A, A + N, thrust::equal_to<int>());
   // The first four values of A are now {1, 3, 2, 1}
   // Values beyond new_end are unspecified.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type` and to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Returns**: The end of the unique range `[first, new_last)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/unique

-  unique_copy

**thrust::unique**

::

   template <typename ForwardIterator,
   typename BinaryPredicate>
   ForwardIterator
   unique(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

For each group of consecutive elements in the range
`[first, last)` with the same value, `unique` removes all
but the first element of the group. The return value is an
iterator `new_last` such that no two consecutive elements in
the range `[first, new_last)` are equal. The iterators in the
range `[new_last, last)` are all still dereferenceable, but
the elements that they point to are unspecified. `unique` is
stable, meaning that the relative order of elements that are
not removed is unchanged.

This version of `unique` uses the function object
`binary_pred` to test for equality.

The following code snippet demonstrates how to use `unique`
to compact a sequence of numbers to remove consecutive
duplicates.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int *new_end = thrust::unique(A, A + N, thrust::equal_to<int>());
   // The first four values of A are now {1, 3, 2, 1}
   // Values beyond new_end are unspecified.

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type` and to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Returns**: The end of the unique range `[first, new_last)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/unique

-  unique_copy

**thrust::unique_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   unique_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

`unique_copy` copies elements from the range
`[first, last)` to a range beginning with `result`, except
that in a consecutive group of duplicate elements only the
first one is copied. The return value is the end of the range
to which the elements are copied.

The reason there are two different versions of unique_copy is
that there are two different definitions of what it means for a
consecutive group of elements to be duplicates. In the first
version, the test is simple equality: the elements in a range
`[f, l)` are duplicates if, for every iterator `i` in the
range, either `i == f` or else `*i == *(i-1)`. In the
second, the test is an arbitrary
`BinaryPredicate` `binary_pred:` the elements in
`[f, l)` are duplicates if, for every iterator `i` in the
range, either `i == f` or else `binary_pred(*i, *(i-1))` is
`true`.

This version of `unique_copy` uses `operator==` to test for
equality.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_copy` to compact a sequence of numbers to remove
consecutive duplicates using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int B[N];
   int *result_end = thrust::unique_copy(thrust::host, A, A + N, B);
   // The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
   // Values beyond result_end are unspecified

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **OutputIterator** is a model of `Output Iterator`
   and and `InputIterator's` `value_type` is convertible
   to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

**Preconditions**: The range `[first,last)` and the range
`[result, result + (last - first))` shall not overlap.

**Returns**: The end of the unique range
`[result, result_end)`.

**See**:

-  unique

-  https://en.cppreference.com/w/cpp/algorithm/unique_copy

**thrust::unique_copy**

::

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   unique_copy(InputIterator first,
     InputIterator last,
     OutputIterator result);

`unique_copy` copies elements from the range
`[first, last)` to a range beginning with `result`, except
that in a consecutive group of duplicate elements only the
first one is copied. The return value is the end of the range
to which the elements are copied.

The reason there are two different versions of unique_copy is
that there are two different definitions of what it means for a
consecutive group of elements to be duplicates. In the first
version, the test is simple equality: the elements in a range
`[f, l)` are duplicates if, for every iterator `i` in the
range, either `i == f` or else `*i == *(i-1)`. In the
second, the test is an arbitrary
`BinaryPredicate` `binary_pred:` the elements in
`[f, l)` are duplicates if, for every iterator `i` in the
range, either `i == f` or else `binary_pred(*i, *(i-1))` is
`true`.

This version of `unique_copy` uses `operator==` to test for
equality.

The following code snippet demonstrates how to use
`unique_copy` to compact a sequence of numbers to remove
consecutive duplicates.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int B[N];
   int *result_end = thrust::unique_copy(A, A + N, B);
   // The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
   // Values beyond result_end are unspecified

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **OutputIterator** is a model of `Output Iterator`
   and and `InputIterator's` `value_type` is convertible
   to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

**Preconditions**: The range `[first,last)` and the range
`[result, result + (last - first))` shall not overlap.

**Returns**: The end of the unique range
`[result, result_end)`.

**See**:

-  unique

-  https://en.cppreference.com/w/cpp/algorithm/unique_copy

**thrust::unique_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename BinaryPredicate>
   __host__ __device__ OutputIterator
   unique_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryPredicate binary_pred);

`unique_copy` copies elements from the range
`[first, last)` to a range beginning with `result`, except
that in a consecutive group of duplicate elements only the
first one is copied. The return value is the end of the range
to which the elements are copied.

This version of `unique_copy` uses the function object
`binary_pred` to test for equality.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_copy` to compact a sequence of numbers to remove
consecutive duplicates using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int B[N];
   int *result_end = thrust::unique_copy(thrust::host, A, A + N, B, thrust::equal_to<int>());
   // The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
   // Values beyond result_end are unspecified.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **OutputIterator** is a model of `Output Iterator`
   and and `InputIterator's` `value_type` is convertible
   to `OutputIterator's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The range `[first,last)` and the range
`[result, result + (last - first))` shall not overlap.

**Returns**: The end of the unique range
`[result, result_end)`.

**See**:

-  unique

-  https://en.cppreference.com/w/cpp/algorithm/unique_copy

**thrust::unique_copy**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename BinaryPredicate>
   OutputIterator
   unique_copy(InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryPredicate binary_pred);

`unique_copy` copies elements from the range
`[first, last)` to a range beginning with `result`, except
that in a consecutive group of duplicate elements only the
first one is copied. The return value is the end of the range
to which the elements are copied.

This version of `unique_copy` uses the function object
`binary_pred` to test for equality.

The following code snippet demonstrates how to use
`unique_copy` to compact a sequence of numbers to remove
consecutive duplicates.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int B[N];
   int *result_end = thrust::unique_copy(A, A + N, B, thrust::equal_to<int>());
   // The first four values of B are now {1, 3, 2, 1} and (result_end - B) is 4
   // Values beyond result_end are unspecified.

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **OutputIterator** is a model of `Output Iterator`
   and and `InputIterator's` `value_type` is convertible
   to `OutputIterator's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The range `[first,last)` and the range
`[result, result + (last - first))` shall not overlap.

**Returns**: The end of the unique range
`[result, result_end)`.

**See**:

-  unique

-  https://en.cppreference.com/w/cpp/algorithm/unique_copy

**thrust::unique_by_key**

::

   template <typename DerivedPolicy,
     typename ForwardIterator1,
     typename ForwardIterator2>
   __host__ __device__ thrust::pair< ForwardIterator1, ForwardIterator2 >
   unique_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first);

`unique_by_key` is a generalization of `unique` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key` removes all but the first element of the
group. Similarly, the corresponding values in the range
`[values_first, values_first + (keys_last - keys_first))` are
also removed.

The return value is a `pair` of iterators
`(new_keys_last,new_values_last)` such that no two
consecutive elements in the range
`[keys_first, new_keys_last)` are equal.

This version of `unique_by_key` uses `operator==` to test
for equality and `project1st` to reduce values with equal
keys.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_by_key` to compact a sequence of key/value pairs to
remove consecutive duplicates using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

   thrust::pair<int*,int*> new_end;
   new_end = thrust::unique_by_key(thrust::host, A, A + N, B);

   // The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
   // The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator1** is a model of `Forward Iterator`,
   and `ForwardIterator1` is mutable, and
   `ForwardIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **ForwardIterator2** is a model of `Forward Iterator`,
   and `ForwardIterator2` is mutable.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the key range.

-  **keys_last** The end of the key range.

-  **values_first** The beginning of the value range.

**Preconditions**: The range `[keys_first, keys_last)` and
the range
`[values_first, values_first + (keys_last - keys_first))`
shall not overlap.

**Returns**: A pair of iterators at end of the ranges
`[key_first, keys_new_last)` and
`[values_first, values_new_last)`.

**See**:

-  unique

-  unique_by_key_copy

-  reduce_by_key

**thrust::unique_by_key**

::

   template <typename ForwardIterator1,
   typename ForwardIterator2>
   thrust::pair< ForwardIterator1, ForwardIterator2 >
   unique_by_key(ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first);

`unique_by_key` is a generalization of `unique` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key` removes all but the first element of the
group. Similarly, the corresponding values in the range
`[values_first, values_first + (keys_last - keys_first))` are
also removed.

The return value is a `pair` of iterators
`(new_keys_last,new_values_last)` such that no two
consecutive elements in the range
`[keys_first, new_keys_last)` are equal.

This version of `unique_by_key` uses `operator==` to test
for equality and `project1st` to reduce values with equal
keys.

The following code snippet demonstrates how to use
`unique_by_key` to compact a sequence of key/value pairs to
remove consecutive duplicates.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

   thrust::pair<int*,int*> new_end;
   new_end = thrust::unique_by_key(A, A + N, B);

   // The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
   // The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.

**Template Parameters**:

-  **ForwardIterator1** is a model of `Forward Iterator`,
   and `ForwardIterator1` is mutable, and
   `ForwardIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **ForwardIterator2** is a model of `Forward Iterator`,
   and `ForwardIterator2` is mutable.

**Function Parameters**:

-  **keys_first** The beginning of the key range.

-  **keys_last** The end of the key range.

-  **values_first** The beginning of the value range.

**Preconditions**: The range `[keys_first, keys_last)` and
the range
`[values_first, values_first + (keys_last - keys_first))`
shall not overlap.

**Returns**: A pair of iterators at end of the ranges
`[key_first, keys_new_last)` and
`[values_first, values_new_last)`.

**See**:

-  unique

-  unique_by_key_copy

-  reduce_by_key

**thrust::unique_by_key**

::

   template <typename DerivedPolicy,
     typename ForwardIterator1,
     typename ForwardIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< ForwardIterator1, ForwardIterator2 >
   unique_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first,
     BinaryPredicate binary_pred);

`unique_by_key` is a generalization of `unique` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key` removes all but the first element of the
group. Similarly, the corresponding values in the range
`[values_first, values_first + (keys_last - keys_first))` are
also removed.

This version of `unique_by_key` uses the function object
`binary_pred` to test for equality and `project1st` to
reduce values with equal keys.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_by_key` to compact a sequence of key/value pairs to
remove consecutive duplicates using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   new_end = thrust::unique_by_key(thrust::host, keys, keys + N, values, binary_pred);

   // The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
   // The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator1** is a model of `Forward Iterator`,
   and `ForwardIterator1` is mutable, and
   `ForwardIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **ForwardIterator2** is a model of `Forward Iterator`,
   and `ForwardIterator2` is mutable.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the key range.

-  **keys_last** The end of the key range.

-  **values_first** The beginning of the value range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The range `[keys_first, keys_last)` and
the range
`[values_first, values_first + (keys_last - keys_first))`
shall not overlap.

**Returns**: The end of the unique range `[first, new_last)`.

**See**:

-  unique

-  unique_by_key_copy

-  reduce_by_key

**thrust::unique_by_key**

::

   template <typename ForwardIterator1,
     typename ForwardIterator2,
     typename BinaryPredicate>
   thrust::pair< ForwardIterator1, ForwardIterator2 >
   unique_by_key(ForwardIterator1 keys_first,
     ForwardIterator1 keys_last,
     ForwardIterator2 values_first,
     BinaryPredicate binary_pred);

`unique_by_key` is a generalization of `unique` to
key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key` removes all but the first element of the
group. Similarly, the corresponding values in the range
`[values_first, values_first + (keys_last - keys_first))` are
also removed.

This version of `unique_by_key` uses the function object
`binary_pred` to test for equality and `project1st` to
reduce values with equal keys.

The following code snippet demonstrates how to use
`unique_by_key` to compact a sequence of key/value pairs to
remove consecutive duplicates.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   new_end = thrust::unique_by_key(keys, keys + N, values, binary_pred);

   // The first four keys in A are now {1, 3, 2, 1} and new_end.first - A is 4.
   // The first four values in B are now {9, 8, 5, 3} and new_end.second - B is 4.

**Template Parameters**:

-  **ForwardIterator1** is a model of `Forward Iterator`,
   and `ForwardIterator1` is mutable, and
   `ForwardIterator's` `value_type` is a model of
   `Equality Comparable`.

-  **ForwardIterator2** is a model of `Forward Iterator`,
   and `ForwardIterator2` is mutable.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **keys_first** The beginning of the key range.

-  **keys_last** The end of the key range.

-  **values_first** The beginning of the value range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The range `[keys_first, keys_last)` and
the range
`[values_first, values_first + (keys_last - keys_first))`
shall not overlap.

**Returns**: The end of the unique range `[first, new_last)`.

**See**:

-  unique

-  unique_by_key_copy

-  reduce_by_key

**thrust::unique_by_key_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   unique_by_key_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`unique_by_key_copy` is a generalization of `unique_copy`
to key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key_copy` copies the first element of the group to
a range beginning with `keys_result` and the corresponding
values from the range
`[values_first, values_first + (keys_last - keys_first))` are
copied to a range beginning with `values_result`.

This version of `unique_by_key_copy` uses `operator==` to
test for equality and `project1st` to reduce values with
equal keys.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_by_key_copy` to compact a sequence of key/value pairs
and with equal keys using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   new_end = thrust::unique_by_key_copy(thrust::host, A, A + N, B, C, D);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_result** The beginning of the output key range.

-  **values_result** The beginning of the output value
   range.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_result, keys_result_last)` and
`[values_result, values_result_last)`.

**See**:

-  unique_copy

-  unique_by_key

-  reduce_by_key

**thrust::unique_by_key_copy**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   unique_by_key_copy(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`unique_by_key_copy` is a generalization of `unique_copy`
to key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key_copy` copies the first element of the group to
a range beginning with `keys_result` and the corresponding
values from the range
`[values_first, values_first + (keys_last - keys_first))` are
copied to a range beginning with `values_result`.

This version of `unique_by_key_copy` uses `operator==` to
test for equality and `project1st` to reduce values with
equal keys.

The following code snippet demonstrates how to use
`unique_by_key_copy` to compact a sequence of key/value pairs
and with equal keys.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   new_end = thrust::unique_by_key_copy(A, A + N, B, C, D);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

**Function Parameters**:

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_result** The beginning of the output key range.

-  **values_result** The beginning of the output value
   range.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_result, keys_result_last)` and
`[values_result, values_result_last)`.

**See**:

-  unique_copy

-  unique_by_key

-  reduce_by_key

**thrust::unique_by_key_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   unique_by_key_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     BinaryPredicate binary_pred);

`unique_by_key_copy` is a generalization of `unique_copy`
to key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key_copy` copies the first element of the group to
a range beginning with `keys_result` and the corresponding
values from the range
`[values_first, values_first + (keys_last - keys_first))` are
copied to a range beginning with `values_result`.

This version of `unique_by_key_copy` uses the function object
`binary_pred` to test for equality and `project1st` to
reduce values with equal keys.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_by_key_copy` to compact a sequence of key/value pairs
and with equal keys using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   new_end = thrust::unique_by_key_copy(thrust::host, A, A + N, B, C, D, binary_pred);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_result** The beginning of the output key range.

-  **values_result** The beginning of the output value
   range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_result, keys_result_last)` and
`[values_result, values_result_last)`.

**See**:

-  unique_copy

-  unique_by_key

-  reduce_by_key

**thrust::unique_by_key_copy**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator1,
     typename OutputIterator2,
     typename BinaryPredicate>
   thrust::pair< OutputIterator1, OutputIterator2 >
   unique_by_key_copy(InputIterator1 keys_first,
     InputIterator1 keys_last,
     InputIterator2 values_first,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     BinaryPredicate binary_pred);

`unique_by_key_copy` is a generalization of `unique_copy`
to key-value pairs. For each group of consecutive keys in the
range `[keys_first, keys_last)` that are equal,
`unique_by_key_copy` copies the first element of the group to
a range beginning with `keys_result` and the corresponding
values from the range
`[values_first, values_first + (keys_last - keys_first))` are
copied to a range beginning with `values_result`.

This version of `unique_by_key_copy` uses the function object
`binary_pred` to test for equality and `project1st` to
reduce values with equal keys.

The following code snippet demonstrates how to use
`unique_by_key_copy` to compact a sequence of key/value pairs
and with equal keys.

::

   #include <thrust/unique.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1}; // input keys
   int B[N] = {9, 8, 7, 6, 5, 4, 3}; // input values
   int C[N];    // output keys
   int D[N];    // output values

   thrust::pair<int*,int*> new_end;
   thrust::equal_to<int> binary_pred;
   new_end = thrust::unique_by_key_copy(A, A + N, B, C, D, binary_pred);

   // The first four keys in C are now {1, 3, 2, 1} and new_end.first - C is 4.
   // The first four values in D are now {9, 8, 5, 3} and new_end.second - D is 4.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,

-  **InputIterator2** is a model of `Input Iterator`,

-  **OutputIterator1** is a model of `Output Iterator`
   and and `InputIterator1's` `value_type` is convertible
   to `OutputIterator1's` `value_type`.

-  **OutputIterator2** is a model of `Output Iterator`
   and and `InputIterator2's` `value_type` is convertible
   to `OutputIterator2's` `value_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **keys_first** The beginning of the input key range.

-  **keys_last** The end of the input key range.

-  **values_first** The beginning of the input value range.

-  **keys_result** The beginning of the output key range.

-  **values_result** The beginning of the output value
   range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Preconditions**: The input ranges shall not overlap either
output range.

**Returns**: A pair of iterators at end of the ranges
`[keys_result, keys_result_last)` and
`[values_result, values_result_last)`.

**See**:

-  unique_copy

-  unique_by_key

-  reduce_by_key

**thrust::unique_count**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   unique_count(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

`unique_count` counts runs of equal elements in the range
`[first, last)` with the same value,

This version of `unique_count` uses the function object
`binary_pred` to test for equality.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_count` to determine a number of runs of equal
elements using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int count = thrust::unique_count(thrust::host, A, A + N, thrust::equal_to<int>());
   // count is now 4

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type` and to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Returns**: The number of runs of equal elements in
`[first, new_last)`

**See**:

-  unique_copy

-  unique_by_key_copy

-  reduce_by_key_copy

**thrust::unique_count**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   unique_count(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

`unique_count` counts runs of equal elements in the range
`[first, last)` with the same value,

This version of `unique_count` uses `operator==` to test
for equality.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`unique_count` to determine the number of runs of equal
elements using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int count = thrust::unique_count(thrust::host, A, A + N);
   // count is now 4

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type` and to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Returns**: The number of runs of equal elements in
`[first, new_last)`

**See**:

-  unique_copy

-  unique_by_key_copy

-  reduce_by_key_copy

**thrust::unique_count**

::

   template <typename ForwardIterator,
     typename BinaryPredicate>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   unique_count(ForwardIterator first,
     ForwardIterator last,
     BinaryPredicate binary_pred);

`unique_count` counts runs of equal elements in the range
`[first, last)` with the same value,

This version of `unique_count` uses the function object
`binary_pred` to test for equality.

The following code snippet demonstrates how to use
`unique_count` to determine the number of runs of equal
elements:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int count = thrust::unique_count(A, A + N, thrust::equal_to<int>());
   // count is now 4

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type` and to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Returns**: The number of runs of equal elements in
`[first, new_last)`

**See**:

-  unique_copy

-  unique_by_key_copy

-  reduce_by_key_copy

**thrust::unique_count**

::

   template <typename ForwardIterator>
   __host__ __device__ thrust::iterator_traits< ForwardIterator >::difference_type
   unique_count(ForwardIterator first,
     ForwardIterator last);

`unique_count` counts runs of equal elements in the range
`[first, last)` with the same value,

This version of `unique_count` uses `operator==` to test
for equality.

The following code snippet demonstrates how to use
`unique_count` to determine the number of runs of equal
elements:

::

   #include <thrust/unique.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 7;
   int A[N] = {1, 3, 3, 3, 2, 2, 1};
   int count = thrust::unique_count(thrust::host, A, A + N);
   // count is now 4

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `BinaryPredicate's` `first_argument_type` and to
   `BinaryPredicate's` `second_argument_type`.

-  **BinaryPredicate** is a model of `Binary Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **binary_pred** The binary predicate used to determine
   equality.

**Returns**: The number of runs of equal elements in
`[first, new_last)`

**See**:

-  unique_copy

-  unique_by_key_copy

-  reduce_by_key_copy

Searching
---------
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename T>
   __host__ __device__ InputIterator
   thrust::find(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     const T & value);

   template <typename InputIterator,
     typename T>
   InputIterator
   thrust::find(InputIterator first,
     InputIterator last,
     const T & value);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ InputIterator
   thrust::find_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename InputIterator,
     typename Predicate>
   InputIterator t
   hrust::find_if(InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ InputIterator
   thrust::find_if_not(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename InputIterator,
     typename Predicate>
   InputIterator
   thrust::find_if_not(InputIterator first,
     InputIterator last,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2>
   __host__ __device__ thrust::pair< InputIterator1, InputIterator2 >
   thrust::mismatch(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);

   template <typename InputIterator1,
     typename InputIterator2>
   thrust::pair< InputIterator1, InputIterator2 >
   thrust::mismatch(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);
   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< InputIterator1, InputIterator2 >
   thrust::mismatch(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     BinaryPredicate pred);

    template <typename InputIterator1,
      typename InputIterator2,
      typename BinaryPredicate>
    thrust::pair< InputIterator1, InputIterator2 >
    thrust::mismatch(InputIterator1 first1,
      InputIterator1 last1,
      InputIterator2 first2,
      BinaryPredicate pred);

    template <typename DerivedPolicy,
      typename ForwardIterator,
      typename Predicate>
    __host__ __device__ ForwardIterator
    thrust::partition_point(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
      ForwardIterator first,
      ForwardIterator last,
      Predicate pred);

    template <typename ForwardIterator,
      typename Predicate>
    ForwardIterator
    thrust::partition_point(ForwardIterator first,
      ForwardIterator last,
      Predicate pred);

**thrust::find**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename T>
   __host__ __device__ InputIterator
   find(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     const T & value);

`find` returns the first iterator `i` in the range
`[first, last)` such that `*i == value` or `last` if no
such iterator exists.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/find.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(4);

   input[0] = 0;
   input[1] = 5;
   input[2] = 3;
   input[3] = 7;

   thrust::device_vector<int>::iterator iter;

   iter = thrust::find(thrust::device, input.begin(), input.end(), 3); // returns input.first() + 2
   iter = thrust::find(thrust::device, input.begin(), input.end(), 5); // returns input.first() + 1
   iter = thrust::find(thrust::device, input.begin(), input.end(), 9); // returns input.end()

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is equality
   comparable to type `T`.

-  **T** is a model of
   `EqualityComparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** Beginning of the sequence to search.

-  **last** End of the sequence to search.

-  **value** The value to find.

**Returns**: The first iterator `i` such that `*i == value`
or `last`.

**See**:

-  find_if

-  mismatch

**thrust::find**

::

   template <typename InputIterator,
     typename T>
   InputIterator
   find(InputIterator first,
     InputIterator last,
     const T & value);

`find` returns the first iterator `i` in the range
`[first, last)` such that `*i == value` or `last` if no
such iterator exists.

::

   #include <thrust/find.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(4);

   input[0] = 0;
   input[1] = 5;
   input[2] = 3;
   input[3] = 7;

   thrust::device_vector<int>::iterator iter;

   iter = thrust::find(input.begin(), input.end(), 3); // returns input.first() + 2
   iter = thrust::find(input.begin(), input.end(), 5); // returns input.first() + 1
   iter = thrust::find(input.begin(), input.end(), 9); // returns input.end()

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is equality
   comparable to type `T`.

-  **T** is a model of
   `EqualityComparable`.

**Function Parameters**:

-  **first** Beginning of the sequence to search.

-  **last** End of the sequence to search.

-  **value** The value to find.

**Returns**: The first iterator `i` such that `*i == value`
or `last`.

**See**:

-  find_if

-  mismatch

**thrust::find_if**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ InputIterator
   find_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

`find_if` returns the first iterator `i` in the range
`[first, last)` such that `pred(*i)` is `true` or
`last` if no such iterator exists.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/find.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...

   struct greater_than_four
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 4;
   }
   };

   struct greater_than_ten
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 10;
   }
   };

   ...
   thrust::device_vector<int> input(4);

   input[0] = 0;
   input[1] = 5;
   input[2] = 3;
   input[3] = 7;

   thrust::device_vector<int>::iterator iter;

   iter = thrust::find_if(thrust::device, input.begin(), input.end(), greater_than_four()); // returns input.first() + 1

   iter = thrust::find_if(thrust::device, input.begin(), input.end(), greater_than_ten());  // returns input.end()

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** Beginning of the sequence to search.

-  **last** End of the sequence to search.

-  **pred** A predicate used to test range elements.

**Returns**: The first iterator `i` such that `pred(*i)` is
`true`, or `last`.

**See**:

-  find

-  find_if_not

-  mismatch

**thrust::find_if**

::

   template <typename InputIterator,
     typename Predicate>
   InputIterator
   find_if(InputIterator first,
     InputIterator last,
     Predicate pred);

`find_if` returns the first iterator `i` in the range
`[first, last)` such that `pred(*i)` is `true` or
`last` if no such iterator exists.

::

   #include <thrust/find.h>
   #include <thrust/device_vector.h>

   struct greater_than_four
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 4;
   }
   };

   struct greater_than_ten
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 10;
   }
   };

   ...
   thrust::device_vector<int> input(4);

   input[0] = 0;
   input[1] = 5;
   input[2] = 3;
   input[3] = 7;

   thrust::device_vector<int>::iterator iter;

   iter = thrust::find_if(input.begin(), input.end(), greater_than_four()); // returns input.first() + 1

   iter = thrust::find_if(input.begin(), input.end(), greater_than_ten());  // returns input.end()

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** Beginning of the sequence to search.

-  **last** End of the sequence to search.

-  **pred** A predicate used to test range elements.

**Returns**: The first iterator `i` such that `pred(*i)` is
`true`, or `last`.

**See**:

-  find

-  find_if_not

-  mismatch

**thrust::find_if_not**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Predicate>
   __host__ __device__ InputIterator
   find_if_not(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     Predicate pred);

`find_if_not` returns the first iterator `i` in the range
`[first, last)` such that `pred(*i)` is `false` or
`last` if no such iterator exists.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/find.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...

   struct greater_than_four
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 4;
   }
   };

   struct greater_than_ten
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 10;
   }
   };

   ...
   thrust::device_vector<int> input(4);

   input[0] = 0;
   input[1] = 5;
   input[2] = 3;
   input[3] = 7;

   thrust::device_vector<int>::iterator iter;

   iter = thrust::find_if_not(thrust::device, input.begin(), input.end(), greater_than_four()); // returns input.first()

   iter = thrust::find_if_not(thrust::device, input.begin(), input.end(), greater_than_ten());  // returns input.first()

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** Beginning of the sequence to search.

-  **last** End of the sequence to search.

-  **pred** A predicate used to test range elements.

**Returns**: The first iterator `i` such that `pred(*i)` is
`false`, or `last`.

**See**:

-  find

-  find_if

-  mismatch

**thrust::find_if_not**

::

   template <typename InputIterator,
     typename Predicate>
   InputIterator
   find_if_not(InputIterator first,
     InputIterator last,
     Predicate pred);

`find_if_not` returns the first iterator `i` in the range
`[first, last)` such that `pred(*i)` is `false` or
`last` if no such iterator exists.

::

   #include <thrust/find.h>
   #include <thrust/device_vector.h>

   struct greater_than_four
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 4;
   }
   };

   struct greater_than_ten
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x > 10;
   }
   };

   ...
   thrust::device_vector<int> input(4);

   input[0] = 0;
   input[1] = 5;
   input[2] = 3;
   input[3] = 7;

   thrust::device_vector<int>::iterator iter;

   iter = thrust::find_if_not(input.begin(), input.end(), greater_than_four()); // returns input.first()

   iter = thrust::find_if_not(input.begin(), input.end(), greater_than_ten());  // returns input.first()

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** Beginning of the sequence to search.

-  **last** End of the sequence to search.

-  **pred** A predicate used to test range elements.

**Returns**: The first iterator `i` such that `pred(*i)` is
`false`, or `last`.

**See**:

-  find

-  find_if

-  mismatch

**thrust::mismatch**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2>
   __host__ __device__ thrust::pair< InputIterator1, InputIterator2 >
   mismatch(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);

`mismatch` finds the first position where the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
differ. The two versions of `mismatch` use different tests
for whether elements differ.

This version of `mismatch` finds the first iterator `i` in
`[first1, last1)` such that
`*i == *(first2 + (i - first1))` is `false`. The return
value is a `pair` whose first element is `i` and whose
second element is `*(first2 + (i - first1))`. If no such
iterator `i` exists, the return value is a `pair` whose
first element is `last1` and whose second element is
`*(first2 + (last1 - first1))`.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/mismatch.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> vec1(4);
   thrust::device_vector<int> vec2(4);

   vec1[0] = 0;  vec2[0] = 0;
   vec1[1] = 5;  vec2[1] = 5;
   vec1[2] = 3;  vec2[2] = 8;
   vec1[3] = 7;  vec2[3] = 7;

   typedef thrust::device_vector<int>::iterator Iterator;
   thrust::pair<Iterator,Iterator> result;

   result = thrust::mismatch(thrust::device, vec1.begin(), vec1.end(), vec2.begin());

   // result.first  is vec1.begin() + 2
   // result.second is vec2.begin() + 2

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is equality
   comparable to `InputIterator2's` `value_type`.

-  **InputIterator2** is a model of `Input Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

**Returns**: The first position where the sequences differ.

**See**:

-  find

-  find_if

**thrust::mismatch**

::

   template <typename InputIterator1,
     typename InputIterator2>
   thrust::pair< InputIterator1, InputIterator2 >
   mismatch(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2);

`mismatch` finds the first position where the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
differ. The two versions of `mismatch` use different tests
for whether elements differ.

This version of `mismatch` finds the first iterator `i` in
`[first1, last1)` such that
`*i == *(first2 + (i - first1))` is `false`. The return
value is a `pair` whose first element is `i` and whose
second element is `*(first2 + (i - first1))`. If no such
iterator `i` exists, the return value is a `pair` whose
first element is `last1` and whose second element is
`*(first2 + (last1 - first1))`.

::

   #include <thrust/mismatch.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> vec1(4);
   thrust::device_vector<int> vec2(4);

   vec1[0] = 0;  vec2[0] = 0;
   vec1[1] = 5;  vec2[1] = 5;
   vec1[2] = 3;  vec2[2] = 8;
   vec1[3] = 7;  vec2[3] = 7;

   typedef thrust::device_vector<int>::iterator Iterator;
   thrust::pair<Iterator,Iterator> result;

   result = thrust::mismatch(vec1.begin(), vec1.end(), vec2.begin());

   // result.first  is vec1.begin() + 2
   // result.second is vec2.begin() + 2

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is equality
   comparable to `InputIterator2's` `value_type`.

-  **InputIterator2** is a model of `Input Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

**Returns**: The first position where the sequences differ.

**See**:

-  find

-  find_if

**thrust::mismatch**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename BinaryPredicate>
   __host__ __device__ thrust::pair< InputIterator1, InputIterator2 >
   mismatch(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     BinaryPredicate pred);

`mismatch` finds the first position where the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
differ. The two versions of `mismatch` use different tests
for whether elements differ.

This version of `mismatch` finds the first iterator `i` in
`[first1, last1)` such that
`pred(*i, *(first2 + (i - first1))` is `false`. The return
value is a `pair` whose first element is `i` and whose
second element is `*(first2 + (i - first1))`. If no such
iterator `i` exists, the return value is a `pair` whose
first element is `last1` and whose second element is
`*(first2 + (last1 - first1))`.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/mismatch.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> vec1(4);
   thrust::device_vector<int> vec2(4);

   vec1[0] = 0;  vec2[0] = 0;
   vec1[1] = 5;  vec2[1] = 5;
   vec1[2] = 3;  vec2[2] = 8;
   vec1[3] = 7;  vec2[3] = 7;

   typedef thrust::device_vector<int>::iterator Iterator;
   thrust::pair<Iterator,Iterator> result;

   result = thrust::mismatch(thrust::device, vec1.begin(), vec1.end(), vec2.begin(), thrust::equal_to<int>());

   // result.first  is vec1.begin() + 2
   // result.second is vec2.begin() + 2

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`.

-  **InputIterator2** is a model of `Input Iterator`.

-  **Predicate** is a model of `Input Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **pred** The binary predicate to compare elements.

**Returns**: The first position where the sequences differ.

**See**:

-  find

-  find_if

**thrust::mismatch**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename BinaryPredicate>
   thrust::pair< InputIterator1, InputIterator2 >
   mismatch(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     BinaryPredicate pred);

`mismatch` finds the first position where the two ranges
`[first1, last1)` and `[first2, first2 + (last1 - first1))`
differ. The two versions of `mismatch` use different tests
for whether elements differ.

This version of `mismatch` finds the first iterator `i` in
`[first1, last1)` such that
`pred(*i, *(first2 + (i - first1))` is `false`. The return
value is a `pair` whose first element is `i` and whose
second element is `*(first2 + (i - first1))`. If no such
iterator `i` exists, the return value is a `pair` whose
first element is `last1` and whose second element is
`*(first2 + (last1 - first1))`.

::

   #include <thrust/mismatch.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> vec1(4);
   thrust::device_vector<int> vec2(4);

   vec1[0] = 0;  vec2[0] = 0;
   vec1[1] = 5;  vec2[1] = 5;
   vec1[2] = 3;  vec2[2] = 8;
   vec1[3] = 7;  vec2[3] = 7;

   typedef thrust::device_vector<int>::iterator Iterator;
   thrust::pair<Iterator,Iterator> result;

   result = thrust::mismatch(vec1.begin(), vec1.end(), vec2.begin(), thrust::equal_to<int>());

   // result.first  is vec1.begin() + 2
   // result.second is vec2.begin() + 2

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`.

-  **InputIterator2** is a model of `Input Iterator`.

-  **Predicate** is a model of `Input Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first sequence.

-  **last1** The end of the first sequence.

-  **first2** The beginning of the second sequence.

-  **pred** The binary predicate to compare elements.

**Returns**: The first position where the sequences differ.

**See**:

-  find

-  find_if

**thrust::partition_point**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate>
   __host__ __device__ ForwardIterator
   partition_point(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`partition_point` returns an iterator pointing to the end of
the true partition of a partitioned range. `partition_point`
requires the input range `[first,last)` to be a partition;
that is, all elements which satisfy `pred` shall appear
before those that do not.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/partition.h>
   #include <thrust/execution_policy.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
   return (x % 2) == 0;
   }
   };

   ...

   int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
   int * B = thrust::partition_point(thrust::host, A, A + 10, is_even());
   // B - A is 5
   // [A, B) contains only even values

**Note**: Though similar, `partition_point` is not redundant
with `find_if_not`. `partition_point's` precondition
provides an opportunity for a faster implemention.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range to consider.

-  **last** The end of the range to consider.

-  **pred** A function object which decides to which
   partition each element of the range `[first, last)`
   belongs.

**Preconditions**: The range `[first, last)` shall be
partitioned by `pred`.

**Returns**: An iterator `mid` such that
`all_of(first, mid, pred)` and `none_of(mid, last, pred)`
are both true.

**See**:

-  `partition`

-  `find_if_not`

**thrust::partition_point**

::

   template <typename ForwardIterator,
     typename Predicate>
   ForwardIterator
   partition_point(ForwardIterator first,
     ForwardIterator last,
     Predicate pred);

`partition_point` returns an iterator pointing to the end of
the true partition of a partitioned range. `partition_point`
requires the input range `[first,last)` to be a partition;
that is, all elements which satisfy `pred` shall appear
before those that do not.

::

   #include <thrust/partition.h>

   struct is_even
   {
   __host__ __device__
   bool operator()(const int &x)
   {
   return (x % 2) == 0;
   }
   };

   ...

   int A[] = {2, 4, 6, 8, 10, 1, 3, 5, 7, 9};
   int * B = thrust::partition_point(A, A + 10, is_even());
   // B - A is 5
   // [A, B) contains only even values

**Note**: Though similar, `partition_point` is not redundant
with `find_if_not`. `partition_point's` precondition
provides an opportunity for a faster implemention.

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the range to consider.

-  **last** The end of the range to consider.

-  **pred** A function object which decides to which
   partition each element of the range `[first, last)`
   belongs.

**Preconditions**: The range `[first, last)` shall be
partitioned by `pred`.

**Returns**: An iterator `mid` such that
`all_of(first, mid, pred)` and `none_of(mid, last, pred)`
are both true.

**See**:

-  `partition`

-  `find_if_not`

Binary Search
*************
**Functions**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ ForwardIterator
   thrust::lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <class ForwardIterator,
     class LessThanComparable>
   ForwardIterator
   thrust::lower_bound(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ ForwardIterator
   thrust::lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   ForwardIterator
   thrust::lower_bound(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ ForwardIterator
   thrust::upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <class ForwardIterator,
     class LessThanComparable>
   ForwardIterator
   thrust::upper_bound(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ ForwardIterator
   thrust::upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   ForwardIterator
   thrust::upper_bound(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ bool
   thrust::binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <class ForwardIterator,
     class LessThanComparable>
   bool
   thrust::binary_search(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ bool
   thrust::binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   bool
   thrust::binary_search(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   thrust::equal_range(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <class ForwardIterator,
     class LessThanComparable>
   thrust::pair< ForwardIterator, ForwardIterator >
   thrust::equal_range(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   thrust::equal_range(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   thrust::pair< ForwardIterator, ForwardIterator >
   thrust::equal_range(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

**thrust::lower_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ ForwardIterator lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`lower_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the first position where value could
be inserted without violating the ordering. This version of
`lower_bound` uses `operator<` for comparison and returns
the furthermost iterator `i` in `[first, last)` such that,
for every iterator `j` in `[first, i)`, `*j < value`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`lower_bound` to search for values in a ordered range using
the `thrust::device` execution policy for parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::lower_bound(thrust::device, input.begin(), input.end(), 0); // returns input.begin()
   thrust::lower_bound(thrust::device, input.begin(), input.end(), 1); // returns input.begin() + 1
   thrust::lower_bound(thrust::device, input.begin(), input.end(), 2); // returns input.begin() + 1
   thrust::lower_bound(thrust::device, input.begin(), input.end(), 3); // returns input.begin() + 2
   thrust::lower_bound(thrust::device, input.begin(), input.end(), 8); // returns input.begin() + 4
   thrust::lower_bound(thrust::device, input.begin(), input.end(), 9); // returns input.end()

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: The furthermost iterator `i`, such that
`*i < value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::lower_bound**

::

   template <class ForwardIterator,
     class LessThanComparable>
   ForwardIterator
   lower_bound(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`lower_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the first position where value could
be inserted without violating the ordering. This version of
`lower_bound` uses `operator<` for comparison and returns
the furthermost iterator `i` in `[first, last)` such that,
for every iterator `j` in `[first, i)`, `*j < value`.

The following code snippet demonstrates how to use
`lower_bound` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::lower_bound(input.begin(), input.end(), 0); // returns input.begin()
   thrust::lower_bound(input.begin(), input.end(), 1); // returns input.begin() + 1
   thrust::lower_bound(input.begin(), input.end(), 2); // returns input.begin() + 1
   thrust::lower_bound(input.begin(), input.end(), 3); // returns input.begin() + 2
   thrust::lower_bound(input.begin(), input.end(), 8); // returns input.begin() + 4
   thrust::lower_bound(input.begin(), input.end(), 9); // returns input.end()

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: The furthermost iterator `i`, such that
`*i < value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::lower_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ ForwardIterator
   lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`lower_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the first position where value could
be inserted without violating the ordering. This version of
`lower_bound` uses function object `comp` for comparison
and returns the furthermost iterator `i` in `[first, last)`
such that, for every iterator `j` in `[first, i)`,
`comp(*j, value)` is `true`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`lower_bound` to search for values in a ordered range using
the `thrust::device` execution policy for parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::lower_bound(input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin()
   thrust::lower_bound(input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
   thrust::lower_bound(input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 1
   thrust::lower_bound(input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
   thrust::lower_bound(input.begin(), input.end(), 8, thrust::less<int>()); // returns input.begin() + 4
   thrust::lower_bound(input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: The furthermost iterator `i`, such that
`comp(*i, value)` is `true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::lower_bound**

::

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   ForwardIterator
   lower_bound(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`lower_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the first position where value could
be inserted without violating the ordering. This version of
`lower_bound` uses function object `comp` for comparison
and returns the furthermost iterator `i` in `[first, last)`
such that, for every iterator `j` in `[first, i)`,
`comp(*j, value)` is `true`.

The following code snippet demonstrates how to use
`lower_bound` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::lower_bound(input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin()
   thrust::lower_bound(input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
   thrust::lower_bound(input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 1
   thrust::lower_bound(input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
   thrust::lower_bound(input.begin(), input.end(), 8, thrust::less<int>()); // returns input.begin() + 4
   thrust::lower_bound(input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: The furthermost iterator `i`, such that
`comp(*i, value)` is `true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ ForwardIterator
   upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`upper_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the last position where value could be
inserted without violating the ordering. This version of
`upper_bound` uses `operator<` for comparison and returns
the furthermost iterator `i` in `[first, last)` such that,
for every iterator `j` in `[first, i)`, `value < *j` is
`false`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`upper_bound` to search for values in a ordered range using
the `thrust::device` execution policy for parallelism:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::upper_bound(thrust::device, input.begin(), input.end(), 0); // returns input.begin() + 1
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 1); // returns input.begin() + 1
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 2); // returns input.begin() + 2
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 3); // returns input.begin() + 2
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 8); // returns input.end()
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 9); // returns input.end()

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: The furthermost iterator `i`, such that
`value < *i` is `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `lower_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <class ForwardIterator,
     class LessThanComparable>
   ForwardIterator
   upper_bound(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`upper_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the last position where value could be
inserted without violating the ordering. This version of
`upper_bound` uses `operator<` for comparison and returns
the furthermost iterator `i` in `[first, last)` such that,
for every iterator `j` in `[first, i)`, `value < *j` is
`false`.

The following code snippet demonstrates how to use
`upper_bound` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::upper_bound(input.begin(), input.end(), 0); // returns input.begin() + 1
   thrust::upper_bound(input.begin(), input.end(), 1); // returns input.begin() + 1
   thrust::upper_bound(input.begin(), input.end(), 2); // returns input.begin() + 2
   thrust::upper_bound(input.begin(), input.end(), 3); // returns input.begin() + 2
   thrust::upper_bound(input.begin(), input.end(), 8); // returns input.end()
   thrust::upper_bound(input.begin(), input.end(), 9); // returns input.end()

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: The furthermost iterator `i`, such that
`value < *i` is `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `lower_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ ForwardIterator
   upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`upper_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the last position where value could be
inserted without violating the ordering. This version of
`upper_bound` uses function object `comp` for comparison
and returns the furthermost iterator `i` in `[first, last)`
such that, for every iterator `j` in `[first, i)`,
`comp(value, *j)` is `false`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`upper_bound` to search for values in a ordered range using
the `thrust::device` execution policy for parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::upper_bound(thrust::device, input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin() + 1
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 2
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 8, thrust::less<int>()); // returns input.end()
   thrust::upper_bound(thrust::device, input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: The furthermost iterator `i`, such that
`comp(value, *i)` is `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `lower_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   ForwardIterator
   upper_bound(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`upper_bound` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
Specifically, it returns the last position where value could be
inserted without violating the ordering. This version of
`upper_bound` uses function object `comp` for comparison
and returns the furthermost iterator `i` in `[first, last)`
such that, for every iterator `j` in `[first, i)`,
`comp(value, *j)` is `false`.

The following code snippet demonstrates how to use
`upper_bound` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::upper_bound(input.begin(), input.end(), 0, thrust::less<int>()); // returns input.begin() + 1
   thrust::upper_bound(input.begin(), input.end(), 1, thrust::less<int>()); // returns input.begin() + 1
   thrust::upper_bound(input.begin(), input.end(), 2, thrust::less<int>()); // returns input.begin() + 2
   thrust::upper_bound(input.begin(), input.end(), 3, thrust::less<int>()); // returns input.begin() + 2
   thrust::upper_bound(input.begin(), input.end(), 8, thrust::less<int>()); // returns input.end()
   thrust::upper_bound(input.begin(), input.end(), 9, thrust::less<int>()); // returns input.end()

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: The furthermost iterator `i`, such that
`comp(value, *i)` is `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `lower_bound`

-  `equal_range`

-  `Binary Search`

**thrust::binary_search**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ bool
   binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`binary_search` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
It returns `true` if an element that is equivalent to
`value` is present in `[first, last)` and `false` if no
such element exists. Specifically, this version returns
`true` if and only if there exists an iterator `i` in
`[first, last)` such that `*i < value` and `value < *i`
are both `false`.
The algorithm’s execution is parallelized as determined by
`exec`.
The following code snippet demonstrates how to use
`binary_search` to search for values in a ordered range using
the `thrust::device` execution policy for parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::binary_search(thrust::device, input.begin(), input.end(), 0); // returns true
   thrust::binary_search(thrust::device, input.begin(), input.end(), 1); // returns false
   thrust::binary_search(thrust::device, input.begin(), input.end(), 2); // returns true
   thrust::binary_search(thrust::device, input.begin(), input.end(), 3); // returns false
   thrust::binary_search(thrust::device, input.begin(), input.end(), 8); // returns true
   thrust::binary_search(thrust::device, input.begin(), input.end(), 9); // returns false

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: `true` if an equivalent element exists in
`[first, last)`, otherwise `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

**thrust::binary_search**

::

   template <class ForwardIterator,
     class LessThanComparable>
   bool
   binary_search(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`binary_search` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
It returns `true` if an element that is equivalent to
`value` is present in `[first, last)` and `false` if no
such element exists. Specifically, this version returns
`true` if and only if there exists an iterator `i` in
`[first, last)` such that `*i < value` and `value < *i`
are both `false`.

The following code snippet demonstrates how to use
`binary_search` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::binary_search(input.begin(), input.end(), 0); // returns true
   thrust::binary_search(input.begin(), input.end(), 1); // returns false
   thrust::binary_search(input.begin(), input.end(), 2); // returns true
   thrust::binary_search(input.begin(), input.end(), 3); // returns false
   thrust::binary_search(input.begin(), input.end(), 8); // returns true
   thrust::binary_search(input.begin(), input.end(), 9); // returns false

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: `true` if an equivalent element exists in
`[first, last)`, otherwise `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

**thrust::binary_search**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ bool
   binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`binary_search` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
It returns `true` if an element that is equivalent to
`value` is present in `[first, last)` and `false` if no
such element exists. Specifically, this version returns
`true` if and only if there exists an iterator `i` in
`[first, last)` such that `comp(*i, value)` and
`comp(value, *i)` are both `false`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`binary_search` to search for values in a ordered range using
the `thrust::device` execution policy for parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::binary_search(thrust::device, input.begin(), input.end(), 0, thrust::less<int>()); // returns true
   thrust::binary_search(thrust::device, input.begin(), input.end(), 1, thrust::less<int>()); // returns false
   thrust::binary_search(thrust::device, input.begin(), input.end(), 2, thrust::less<int>()); // returns true
   thrust::binary_search(thrust::device, input.begin(), input.end(), 3, thrust::less<int>()); // returns false
   thrust::binary_search(thrust::device, input.begin(), input.end(), 8, thrust::less<int>()); // returns true
   thrust::binary_search(thrust::device, input.begin(), input.end(), 9, thrust::less<int>()); // returns false

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: `true` if an equivalent element exists in
`[first, last)`, otherwise `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

**thrust::binary_search**

::

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   bool
   binary_search(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`binary_search` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
It returns `true` if an element that is equivalent to
`value` is present in `[first, last)` and `false` if no
such element exists. Specifically, this version returns
`true` if and only if there exists an iterator `i` in
`[first, last)` such that `comp(*i, value)` and
`comp(value, *i)` are both `false`.

The following code snippet demonstrates how to use
`binary_search` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::binary_search(input.begin(), input.end(), 0, thrust::less<int>()); // returns true
   thrust::binary_search(input.begin(), input.end(), 1, thrust::less<int>()); // returns false
   thrust::binary_search(input.begin(), input.end(), 2, thrust::less<int>()); // returns true
   thrust::binary_search(input.begin(), input.end(), 3, thrust::less<int>()); // returns false
   thrust::binary_search(input.begin(), input.end(), 8, thrust::less<int>()); // returns true
   thrust::binary_search(input.begin(), input.end(), 9, thrust::less<int>()); // returns false

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: `true` if an equivalent element exists in
`[first, last)`, otherwise `false`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

**thrust::equal_range**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename LessThanComparable>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   equal_range(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`equal_range` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
The value returned by `equal_range` is essentially a
combination of the values returned by `lower_bound` and
`upper_bound:` it returns a `pair` of iterators `i` and
`j` such that `i` is the first position where value could
be inserted without violating the ordering and `j` is the
last position where value could be inserted without violating
the ordering. It follows that every element in the range
`[i, j)` is equivalent to value, and that `[i, j)` is the
largest subrange of `[first, last)` that has this property.

This version of `equal_range` returns a `pair` of iterators
`[i, j)`, where `i` is the furthermost iterator in
`[first, last)` such that, for every iterator `k` in
`[first, i)`, `*k < value`. `j` is the furthermost
iterator in `[first, last)` such that, for every iterator
`k` in `[first, j)`, `value < *k` is `false`. For every
iterator `k` in `[i, j)`, neither `value < *k` nor
`*k < value` is `true`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`equal_range` to search for values in a ordered range using
the `thrust::device` execution policy for parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::equal_range(thrust::device, input.begin(), input.end(), 0); // returns [input.begin(), input.begin() + 1)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 1); // returns [input.begin() + 1, input.begin() + 1)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 2); // returns [input.begin() + 1, input.begin() + 2)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 3); // returns [input.begin() + 2, input.begin() + 2)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 8); // returns [input.begin() + 4, input.end)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 9); // returns [input.end(), input.end)

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: A `pair` of iterators `[i, j)` that define the
range of equivalent elements.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/equal_range

-  `lower_bound`

-  `upper_bound`

-  `Binary Search`

**thrust::equal_range**

::

   template <class ForwardIterator,
     class LessThanComparable>
   thrust::pair< ForwardIterator, ForwardIterator >
   equal_range(ForwardIterator first,
     ForwardIterator last,
     const LessThanComparable & value);

`equal_range` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
The value returned by `equal_range` is essentially a
combination of the values returned by `lower_bound` and
`upper_bound:` it returns a `pair` of iterators `i` and
`j` such that `i` is the first position where value could
be inserted without violating the ordering and `j` is the
last position where value could be inserted without violating
the ordering. It follows that every element in the range
`[i, j)` is equivalent to value, and that `[i, j)` is the
largest subrange of `[first, last)` that has this property.

This version of `equal_range` returns a `pair` of iterators
`[i, j)`, where `i` is the furthermost iterator in
`[first, last)` such that, for every iterator `k` in
`[first, i)`, `*k < value`. `j` is the furthermost
iterator in `[first, last)` such that, for every iterator
`k` in `[first, j)`, `value < *k` is `false`. For every
iterator `k` in `[i, j)`, neither `value < *k` nor
`*k < value` is `true`.

The following code snippet demonstrates how to use
`equal_range` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::equal_range(input.begin(), input.end(), 0); // returns [input.begin(), input.begin() + 1)
   thrust::equal_range(input.begin(), input.end(), 1); // returns [input.begin() + 1, input.begin() + 1)
   thrust::equal_range(input.begin(), input.end(), 2); // returns [input.begin() + 1, input.begin() + 2)
   thrust::equal_range(input.begin(), input.end(), 3); // returns [input.begin() + 2, input.begin() + 2)
   thrust::equal_range(input.begin(), input.end(), 8); // returns [input.begin() + 4, input.end)
   thrust::equal_range(input.begin(), input.end(), 9); // returns [input.end(), input.end)

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **LessThanComparable** is a model of
   `LessThanComparable`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

**Returns**: A `pair` of iterators `[i, j)` that define the
range of equivalent elements.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/equal_range

-  `lower_bound`

-  `upper_bound`

-  `Binary Search`

**thrust::equal_range**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T,
     typename StrictWeakOrdering>
   __host__ __device__ thrust::pair< ForwardIterator, ForwardIterator >
   equal_range(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`equal_range` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
The value returned by `equal_range` is essentially a
combination of the values returned by `lower_bound` and
`upper_bound:` it returns a `pair` of iterators `i` and
`j` such that `i` is the first position where value could
be inserted without violating the ordering and `j` is the
last position where value could be inserted without violating
the ordering. It follows that every element in the range
`[i, j)` is equivalent to value, and that `[i, j)` is the
largest subrange of `[first, last)` that has this property.

This version of `equal_range` returns a `pair` of iterators
`[i, j)`. `i` is the furthermost iterator in
`[first, last)` such that, for every iterator `k` in
`[first, i)`, `comp(*k, value)` is `true`. `j` is the
furthermost iterator in `[first, last)` such that, for every
iterator `k` in `[first, last)`, `comp(value, *k)` is
`false`. For every iterator `k` in `[i, j)`, neither
`comp(value, *k)` nor `comp(*k, value)` is `true`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`equal_range` to search for values in a ordered range using
the `thrust::device` execution policy for parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::equal_range(thrust::device, input.begin(), input.end(), 0, thrust::less<int>()); // returns [input.begin(), input.begin() + 1)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 1, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 1)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 2, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 2)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 3, thrust::less<int>()); // returns [input.begin() + 2, input.begin() + 2)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 8, thrust::less<int>()); // returns [input.begin() + 4, input.end)
   thrust::equal_range(thrust::device, input.begin(), input.end(), 9, thrust::less<int>()); // returns [input.end(), input.end)

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: A `pair` of iterators `[i, j)` that define the
range of equivalent elements.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/equal_range

-  `lower_bound`

-  `upper_bound`

-  `Binary Search`

**thrust::equal_range**

::

   template <class ForwardIterator,
     class T,
     class StrictWeakOrdering>
   thrust::pair< ForwardIterator, ForwardIterator >
   equal_range(ForwardIterator first,
     ForwardIterator last,
     const T & value,
     StrictWeakOrdering comp);

`equal_range` is a version of binary search: it attempts to
find the element value in an ordered range `[first, last)`.
The value returned by `equal_range` is essentially a
combination of the values returned by `lower_bound` and
`upper_bound:` it returns a `pair` of iterators `i` and
`j` such that `i` is the first position where value could
be inserted without violating the ordering and `j` is the
last position where value could be inserted without violating
the ordering. It follows that every element in the range
`[i, j)` is equivalent to value, and that `[i, j)` is the
largest subrange of `[first, last)` that has this property.

This version of `equal_range` returns a `pair` of iterators
`[i, j)`. `i` is the furthermost iterator in
`[first, last)` such that, for every iterator `k` in
`[first, i)`, `comp(*k, value)` is `true`. `j` is the
furthermost iterator in `[first, last)` such that, for every
iterator `k` in `[first, last)`, `comp(value, *k)` is
`false`. For every iterator `k` in `[i, j)`, neither
`comp(value, *k)` nor `comp(*k, value)` is `true`.

The following code snippet demonstrates how to use
`equal_range` to search for values in a ordered range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::equal_range(input.begin(), input.end(), 0, thrust::less<int>()); // returns [input.begin(), input.begin() + 1)
   thrust::equal_range(input.begin(), input.end(), 1, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 1)
   thrust::equal_range(input.begin(), input.end(), 2, thrust::less<int>()); // returns [input.begin() + 1, input.begin() + 2)
   thrust::equal_range(input.begin(), input.end(), 3, thrust::less<int>()); // returns [input.begin() + 2, input.begin() + 2)
   thrust::equal_range(input.begin(), input.end(), 8, thrust::less<int>()); // returns [input.begin() + 4, input.end)
   thrust::equal_range(input.begin(), input.end(), 9, thrust::less<int>()); // returns [input.end(), input.end)

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **T** is comparable to
   `ForwardIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **value** The value to be searched.

-  **comp** The comparison operator.

**Returns**: A `pair` of iterators `[i, j)` that define the
range of equivalent elements.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/equal_range

-  `lower_bound`

-  `upper_bound`

-  `Binary Search`

Vectorized Searches
###################
**Vectorized Searches**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator>
   OutputIterator
   thrust::lower_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator,
     typename StrictWeakOrdering>
   __host__ __device__ OutputIterator
   thrust::lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator,
     class StrictWeakOrdering>
   OutputIterator
   thrust::lower_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator>
   OutputIterator
   thrust::upper_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator,
     typename StrictWeakOrdering>
   __host__ __device__ OutputIterator
   thrust::upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator,
     class StrictWeakOrdering>
   OutputIterator
   thrust::upper_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator>
   OutputIterator
   thrust::binary_search(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator,
     typename StrictWeakOrdering>
    __host__ __device__ OutputIterator
    thrust::binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
      ForwardIterator first,
      ForwardIterator last,
      InputIterator values_first,
      InputIterator values_last,
      OutputIterator result,
      StrictWeakOrdering comp);

    template <class ForwardIterator,
      class InputIterator,
      class OutputIterator,
      class StrictWeakOrdering>
    OutputIterator
    thrust::binary_search(ForwardIterator first,
      ForwardIterator last,
      InputIterator values_first,
      InputIterator values_last,
      OutputIterator result,
      StrictWeakOrdering comp);

**thrust::lower_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

`lower_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of first
position where value could be inserted without violating the
ordering.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`lower_bound` to search for multiple values in a ordered
range using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::lower_bound(thrust::device,
   input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin());

   // output is now [0, 1, 1, 2, 4, 5]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::lower_bound**

::

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator>
   OutputIterator
   lower_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

`lower_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of first
position where value could be inserted without violating the
ordering.

The following code snippet demonstrates how to use
`lower_bound` to search for multiple values in a ordered
range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::lower_bound(input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin());

   // output is now [0, 1, 1, 2, 4, 5]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::lower_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
    typename OutputIterator,
     typename StrictWeakOrdering>
   __host__ __device__ OutputIterator
   lower_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

`lower_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of first
position where value could be inserted without violating the
ordering. This version of `lower_bound` uses function object
`comp` for comparison.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`lower_bound` to search for multiple values in a ordered
range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::lower_bound(input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin(),
   thrust::less<int>());

   // output is now [0, 1, 1, 2, 4, 5]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is comparable to
   `ForwardIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

-  **comp** The comparison operator.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::lower_bound**

::

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator,
     class StrictWeakOrdering>
   OutputIterator
   lower_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

`lower_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of first
position where value could be inserted without violating the
ordering. This version of `lower_bound` uses function object
`comp` for comparison.

The following code snippet demonstrates how to use
`lower_bound` to search for multiple values in a ordered
range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::lower_bound(input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin(),
   thrust::less<int>());

   // output is now [0, 1, 1, 2, 4, 5]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is comparable to
   `ForwardIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

-  **comp** The comparison operator.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/lower_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

`upper_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of last
position where value could be inserted without violating the
ordering.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`upper_bound` to search for multiple values in a ordered
range using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::upper_bound(thrust::device,
   input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin());

   // output is now [1, 1, 2, 2, 5, 5]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator>
   OutputIterator
   upper_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

`upper_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of last
position where value could be inserted without violating the
ordering.

The following code snippet demonstrates how to use
`upper_bound` to search for multiple values in a ordered
range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::upper_bound(input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin());

   // output is now [1, 1, 2, 2, 5, 5]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `upper_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator,
     typename StrictWeakOrdering>
   __host__ __device__ OutputIterator
   upper_bound(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

`upper_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of first
position where value could be inserted without violating the
ordering. This version of `upper_bound` uses function object
`comp` for comparison.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`upper_bound` to search for multiple values in a ordered
range using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::upper_bound(thrust::device,
   input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin(),
   thrust::less<int>());

   // output is now [1, 1, 2, 2, 5, 5]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is comparable to
   `ForwardIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

-  **comp** The comparison operator.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `lower_bound`

-  `equal_range`

-  `Binary Search`

**thrust::upper_bound**

::

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator,
     class StrictWeakOrdering>
   OutputIterator
   upper_bound(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

`upper_bound` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. Specifically, it returns the index of first
position where value could be inserted without violating the
ordering. This version of `upper_bound` uses function object
`comp` for comparison.

The following code snippet demonstrates how to use
`upper_bound` to search for multiple values in a ordered
range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<unsigned int> output(6);

   thrust::upper_bound(input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin(),
   thrust::less<int>());

   // output is now [1, 1, 2, 2, 5, 5]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is comparable to
   `ForwardIterator's` `value_type`.

-  **OutputIterator** is a model of `Output Iterator`.
   and `ForwardIterator's` difference_type is convertible to
   `OutputIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

-  **comp** The comparison operator.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/upper_bound

-  `lower_bound`

-  `equal_range`

-  `Binary Search`

**thrust::binary_search**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

`binary_search` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. It returns `true` if an element that is
equivalent to `value` is present in `[first, last)` and
`false` if no such element exists.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`binary_search` to search for multiple values in a ordered
range using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<bool> output(6);

   thrust::binary_search(thrust::device,
   input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin());

   // output is now [true, false, true, false, true, false]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and bool is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

**thrust::binary_search**

::

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator>
   OutputIterator
   binary_search(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result);

`binary_search` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. It returns `true` if an element that is
equivalent to `value` is present in `[first, last)` and
`false` if no such element exists.

The following code snippet demonstrates how to use
`binary_search` to search for multiple values in a ordered
range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<bool> output(6);

   thrust::binary_search(input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin());

   // output is now [true, false, true, false, true, false]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and bool is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

**thrust::binary_search**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename OutputIterator,
     typename StrictWeakOrdering>
   __host__ __device__ OutputIterator binary_search(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

`binary_search` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. It returns `true` if an element that is
equivalent to `value` is present in `[first, last)` and
`false` if no such element exists. This version of
`binary_search` uses function object `comp` for comparison.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`binary_search` to search for multiple values in a ordered
range using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<bool> output(6);

   thrust::binary_search(thrust::device,
   input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin(),
   thrust::less<T>());

   // output is now [true, false, true, false, true, false]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and bool is convertible to
   `OutputIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

-  **comp** The comparison operator.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

**thrust::binary_search**

::

   template <class ForwardIterator,
     class InputIterator,
     class OutputIterator,
     class StrictWeakOrdering>
   OutputIterator
   binary_search(ForwardIterator first,
     ForwardIterator last,
     InputIterator values_first,
     InputIterator values_last,
     OutputIterator result,
     StrictWeakOrdering comp);

`binary_search` is a vectorized version of binary search: for
each iterator `v` in `[values_first, values_last)` it
attempts to find the value `*v` in an ordered range
`[first, last)`. It returns `true` if an element that is
equivalent to `value` is present in `[first, last)` and
`false` if no such element exists. This version of
`binary_search` uses function object `comp` for comparison.

The following code snippet demonstrates how to use
`binary_search` to search for multiple values in a ordered
range.

::

   #include <thrust/binary_search.h>
   #include <thrust/device_vector.h>
   #include <thrust/functional.h>
   ...
   thrust::device_vector<int> input(5);

   input[0] = 0;
   input[1] = 2;
   input[2] = 5;
   input[3] = 7;
   input[4] = 8;

   thrust::device_vector<int> values(6);
   values[0] = 0;
   values[1] = 1;
   values[2] = 2;
   values[3] = 3;
   values[4] = 8;
   values[5] = 9;

   thrust::device_vector<bool> output(6);

   thrust::binary_search(input.begin(), input.end(),
   values.begin(), values.end(),
   output.begin(),
   thrust::less<T>());

   // output is now [true, false, true, false, true, false]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **InputIterator** is a model of `Input Iterator`.
   and `InputIterator's` `value_type` is
   `LessThanComparable`.

-  **OutputIterator** is a model of `Output Iterator`.
   and bool is convertible to
   `OutputIterator's` `value_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the ordered sequence.

-  **last** The end of the ordered sequence.

-  **values_first** The beginning of the search values
   sequence.

-  **values_last** The end of the search values sequence.

-  **result** The beginning of the output sequence.

-  **comp** The comparison operator.

**Preconditions**: The ranges `[first,last)` and
`[result, result + (last - first))` shall not overlap.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/binary_search

-  `lower_bound`

-  `upper_bound`

-  `equal_range`

Set Operations
--------------
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::set_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   thrust::set_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   thrust::set_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   thrust::set_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,  
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::set_intersection(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   thrust::set_intersection(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename DerivedPolicy,  
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   thrust::set_intersection(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   thrust::set_intersection(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::set_symmetric_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   thrust::set_symmetric_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   thrust::set_symmetric_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   thrust::set_symmetric_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::set_union(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   thrust::set_union(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   thrust::set_union(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   thrust::set_union(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_intersection_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_intersection_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_intersection_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_intersection_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_symmetric_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_symmetric_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_symmetric_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_symmetric_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_union_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_union_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_union_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   thrust::set_union_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

**thrust::set_difference**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   set_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_difference` constructs a sorted range that is the set
difference of the sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_difference` performs the
“difference” operation from set theory: the output range
contains a copy of every element that is contained in
`[first1, last1)` and not contained in `[first2, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and if `[first2, last2)` contains `n`
elements that are equivalent to them, the last `max(m-n,0)`
elements from `[first1, last1)` range shall be copied to the
output range.

This version of `set_difference` compares elements using
`operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_difference` to compute the set difference of two sets of
integers sorted in ascending order using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[7] = {0, 1, 3, 4, 5, 6, 9};
   int A2[5] = {1, 3, 5, 7, 9};

   int result[3];

   int *result_end = thrust::set_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
   // result is now {0, 4, 6}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_difference

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_difference**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   set_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_difference` constructs a sorted range that is the set
difference of the sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_difference` performs the
“difference” operation from set theory: the output range
contains a copy of every element that is contained in
`[first1, last1)` and not contained in `[first2, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and if `[first2, last2)` contains `n`
elements that are equivalent to them, the last `max(m-n,0)`
elements from `[first1, last1)` range shall be copied to the
output range.

This version of `set_difference` compares elements using
`operator<`.

The following code snippet demonstrates how to use
`set_difference` to compute the set difference of two sets of
integers sorted in ascending order.

::

   #include <thrust/set_operations.h>
   ...
   int A1[7] = {0, 1, 3, 4, 5, 6, 9};
   int A2[5] = {1, 3, 5, 7, 9};

   int result[3];

   int *result_end = thrust::set_difference(A1, A1 + 7, A2, A2 + 5, result);
   // result is now {0, 4, 6}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_difference

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_difference**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   set_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_difference` constructs a sorted range that is the set
difference of the sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_difference` performs the
“difference” operation from set theory: the output range
contains a copy of every element that is contained in
`[first1, last1)` and not contained in `[first2, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and if `[first2, last2)` contains `n`
elements that are equivalent to them, the last `max(m-n,0)`
elements from `[first1, last1)` range shall be copied to the
output range.

This version of `set_difference` compares elements using a
function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_difference` to compute the set difference of two sets of
integers sorted in descending order using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[7] = {9, 6, 5, 4, 3, 1, 0};
   int A2[5] = {9, 7, 5, 3, 1};

   int result[3];

   int *result_end = thrust::set_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
   // result is now {6, 4, 0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_difference

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_difference**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   set_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_difference` constructs a sorted range that is the set
difference of the sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_difference` performs the
“difference” operation from set theory: the output range
contains a copy of every element that is contained in
`[first1, last1)` and not contained in `[first2, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and if `[first2, last2)` contains `n`
elements that are equivalent to them, the last `max(m-n,0)`
elements from `[first1, last1)` range shall be copied to the
output range.

This version of `set_difference` compares elements using a
function object `comp`.

The following code snippet demonstrates how to use
`set_difference` to compute the set difference of two sets of
integers sorted in descending order.

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   ...
   int A1[7] = {9, 6, 5, 4, 3, 1, 0};
   int A2[5] = {9, 7, 5, 3, 1};

   int result[3];

   int *result_end = thrust::set_difference(A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
   // result is now {6, 4, 0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_difference

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_intersection**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   set_intersection(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_intersection` constructs a sorted range that is the
intersection of sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_intersection` performs the
“intersection” operation from set theory: the output range
contains a copy of every element that is contained in both
`[first1, last1)` and `[first2, last2)`. The general case
is more complicated, because the input ranges may contain
duplicate elements. The generalization is that if a value
appears `m` times in `[first1, last1)` and `n` times in
`[first2, last2)` (where `m` may be zero), then it appears
`min(m,n)` times in the output range. `set_intersection` is
stable, meaning that both elements are copied from the first
range rather than the second, and that the relative order of
elements in the output range is the same as in the first input
range.

This version of `set_intersection` compares objects using
`operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_intersection` to compute the set intersection of two
sets of integers sorted in ascending order using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[6] = {1, 3, 5, 7, 9, 11};
   int A2[7] = {1, 1, 2, 3, 5,  8, 13};

   int result[7];

   int *result_end = thrust::set_intersection(thrust::host, A1, A1 + 6, A2, A2 + 7, result);
   // result is now {1, 3, 5}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_intersection

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_intersection**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   set_intersection(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_intersection` constructs a sorted range that is the
intersection of sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_intersection` performs the
“intersection” operation from set theory: the output range
contains a copy of every element that is contained in both
`[first1, last1)` and `[first2, last2)`. The general case
is more complicated, because the input ranges may contain
duplicate elements. The generalization is that if a value
appears `m` times in `[first1, last1)` and `n` times in
`[first2, last2)` (where `m` may be zero), then it appears
`min(m,n)` times in the output range. `set_intersection` is
stable, meaning that both elements are copied from the first
range rather than the second, and that the relative order of
elements in the output range is the same as in the first input
range.

This version of `set_intersection` compares objects using
`operator<`.

The following code snippet demonstrates how to use
`set_intersection` to compute the set intersection of two
sets of integers sorted in ascending order.

::

   #include <thrust/set_operations.h>
   ...
   int A1[6] = {1, 3, 5, 7, 9, 11};
   int A2[7] = {1, 1, 2, 3, 5,  8, 13};

   int result[7];

   int *result_end = thrust::set_intersection(A1, A1 + 6, A2, A2 + 7, result);
   // result is now {1, 3, 5}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_intersection

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_intersection**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   set_intersection(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_intersection` constructs a sorted range that is the
intersection of sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_intersection` performs the
“intersection” operation from set theory: the output range
contains a copy of every element that is contained in both
`[first1, last1)` and `[first2, last2)`. The general case
is more complicated, because the input ranges may contain
duplicate elements. The generalization is that if a value
appears `m` times in `[first1, last1)` and `n` times in
`[first2, last2)` (where `m` may be zero), then it appears
`min(m,n)` times in the output range. `set_intersection` is
stable, meaning that both elements are copied from the first
range rather than the second, and that the relative order of
elements in the output range is the same as in the first input
range.

This version of `set_intersection` compares elements using a
function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_intersection` to compute the set intersection of sets of
integers sorted in descending order using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[6] = {11, 9, 7, 5, 3, 1};
   int A2[7] = {13, 8, 5, 3, 2,  1, 1};

   int result[3];

   int *result_end = thrust::set_intersection(thrust::host, A1, A1 + 6, A2, A2 + 7, result, thrust::greater<int>());
   // result is now {5, 3, 1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_intersection

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_intersection**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   set_intersection(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_intersection` constructs a sorted range that is the
intersection of sorted ranges `[first1, last1)` and
`[first2, last2)`. The return value is the end of the output
range.

In the simplest case, `set_intersection` performs the
“intersection” operation from set theory: the output range
contains a copy of every element that is contained in both
`[first1, last1)` and `[first2, last2)`. The general case
is more complicated, because the input ranges may contain
duplicate elements. The generalization is that if a value
appears `m` times in `[first1, last1)` and `n` times in
`[first2, last2)` (where `m` may be zero), then it appears
`min(m,n)` times in the output range. `set_intersection` is
stable, meaning that both elements are copied from the first
range rather than the second, and that the relative order of
elements in the output range is the same as in the first input
range.

This version of `set_intersection` compares elements using a
function object `comp`.

The following code snippet demonstrates how to use
`set_intersection` to compute the set intersection of sets of
integers sorted in descending order.

::

   #include <thrust/set_operations.h>
   ...
   int A1[6] = {11, 9, 7, 5, 3, 1};
   int A2[7] = {13, 8, 5, 3, 2,  1, 1};

   int result[3];

   int *result_end = thrust::set_intersection(A1, A1 + 6, A2, A2 + 7, result, thrust::greater<int>());
   // result is now {5, 3, 1}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_intersection

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_symmetric_difference**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   set_symmetric_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_symmetric_difference` constructs a sorted range that is
the set symmetric difference of the sorted ranges
`[first1, last1)` and `[first2, last2)`. The return value
is the end of the output range.

In the simplest case, `set_symmetric_difference` performs a
set theoretic calculation: it constructs the union of the two
sets A - B and B - A, where A and B are the two input ranges.
That is, the output range contains a copy of every element that
is contained in `[first1, last1)` but not
`[first2, last1)`, and a copy of every element that is
contained in `[first2, last2)` but not `[first1, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and `[first2, last1)` contains `n` elements
that are equivalent to them, then `|m - n|` of those elements
shall be copied to the output range: the last `m - n`
elements from `[first1, last1)` if `m > n`, and the last
`n - m` of these elements from `[first2, last2)` if
`m < n`.

This version of `set_union` compares elements using
`operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_symmetric_difference` to compute the symmetric
difference of two sets of integers sorted in ascending order
using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[7] = {0, 1, 2, 2, 4, 6, 7};
   int A2[5] = {1, 1, 2, 5, 8};

   int result[6];

   int *result_end = thrust::set_symmetric_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
   // result = {0, 4, 5, 6, 7, 8}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference

-  `merge`

-  `includes`

-  `set_difference`

-  `set_union`

-  `set_intersection`

-  `sort`

-  `is_sorted`

**thrust::set_symmetric_difference**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   set_symmetric_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_symmetric_difference` constructs a sorted range that is
the set symmetric difference of the sorted ranges
`[first1, last1)` and `[first2, last2)`. The return value
is the end of the output range.

In the simplest case, `set_symmetric_difference` performs a
set theoretic calculation: it constructs the union of the two
sets A - B and B - A, where A and B are the two input ranges.
That is, the output range contains a copy of every element that
is contained in `[first1, last1)` but not
`[first2, last1)`, and a copy of every element that is
contained in `[first2, last2)` but not `[first1, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and `[first2, last1)` contains `n` elements
that are equivalent to them, then `|m - n|` of those elements
shall be copied to the output range: the last `m - n`
elements from `[first1, last1)` if `m > n`, and the last
`n - m` of these elements from `[first2, last2)` if
`m < n`.

This version of `set_union` compares elements using
`operator<`.

The following code snippet demonstrates how to use
`set_symmetric_difference` to compute the symmetric
difference of two sets of integers sorted in ascending order.

::

   #include <thrust/set_operations.h>
   ...
   int A1[7] = {0, 1, 2, 2, 4, 6, 7};
   int A2[5] = {1, 1, 2, 5, 8};

   int result[6];

   int *result_end = thrust::set_symmetric_difference(A1, A1 + 7, A2, A2 + 5, result);
   // result = {0, 4, 5, 6, 7, 8}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference

-  `merge`

-  `includes`

-  `set_difference`

-  `set_union`

-  `set_intersection`

-  `sort`

-  `is_sorted`

**thrust::set_symmetric_difference**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   set_symmetric_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_symmetric_difference` constructs a sorted range that is
the set symmetric difference of the sorted ranges
`[first1, last1)` and `[first2, last2)`. The return value
is the end of the output range.

In the simplest case, `set_symmetric_difference` performs a
set theoretic calculation: it constructs the union of the two
sets A - B and B - A, where A and B are the two input ranges.
That is, the output range contains a copy of every element that
is contained in `[first1, last1)` but not
`[first2, last1)`, and a copy of every element that is
contained in `[first2, last2)` but not `[first1, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and `[first2, last1)` contains `n` elements
that are equivalent to them, then `|m - n|` of those elements
shall be copied to the output range: the last `m - n`
elements from `[first1, last1)` if `m > n`, and the last
`n - m` of these elements from `[first2, last2)` if
`m < n`.

This version of `set_union` compares elements using a
function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_symmetric_difference` to compute the symmetric
difference of two sets of integers sorted in descending order
using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[7] = {7, 6, 4, 2, 2, 1, 0};
   int A2[5] = {8, 5, 2, 1, 1};

   int result[6];

   int *result_end = thrust::set_symmetric_difference(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
   // result = {8, 7, 6, 5, 4, 0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference

-  `merge`

-  `includes`

-  `set_difference`

-  `set_union`

-  `set_intersection`

-  `sort`

-  `is_sorted`

**thrust::set_symmetric_difference**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   set_symmetric_difference(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_symmetric_difference` constructs a sorted range that is
the set symmetric difference of the sorted ranges
`[first1, last1)` and `[first2, last2)`. The return value
is the end of the output range.

In the simplest case, `set_symmetric_difference` performs a
set theoretic calculation: it constructs the union of the two
sets A - B and B - A, where A and B are the two input ranges.
That is, the output range contains a copy of every element that
is contained in `[first1, last1)` but not
`[first2, last1)`, and a copy of every element that is
contained in `[first2, last2)` but not `[first1, last1)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
`[first1, last1)` contains `m` elements that are equivalent
to each other and `[first2, last1)` contains `n` elements
that are equivalent to them, then `|m - n|` of those elements
shall be copied to the output range: the last `m - n`
elements from `[first1, last1)` if `m > n`, and the last
`n - m` of these elements from `[first2, last2)` if
`m < n`.

This version of `set_union` compares elements using a
function object `comp`.

The following code snippet demonstrates how to use
`set_symmetric_difference` to compute the symmetric
difference of two sets of integers sorted in descending order.

::

   #include <thrust/set_operations.h>
   ...
   int A1[7] = {7, 6, 4, 2, 2, 1, 0};
   int A2[5] = {8, 5, 2, 1, 1};

   int result[6];

   int *result_end = thrust::set_symmetric_difference(A1, A1 + 7, A2, A2 + 5, result);
   // result = {8, 7, 6, 5, 4, 0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_symmetric_difference

-  `merge`

-  `includes`

-  `set_difference`

-  `set_union`

-  `set_intersection`

-  `sort`

-  `is_sorted`

**thrust::set_union**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   set_union(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_union` constructs a sorted range that is the union of
the sorted ranges `[first1, last1)` and `[first2, last2)`.
The return value is the end of the output range.

In the simplest case, `set_union` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in `[first1, last1)`,
`[first2, last1)`, or both. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if `[first1, last1)`
contains `m` elements that are equivalent to each other and
if `[first2, last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

This version of `set_union` compares elements using
`operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_union` to compute the union of two sets of integers
sorted in ascending order using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[7] = {0, 2, 4, 6, 8, 10, 12};
   int A2[5] = {1, 3, 5, 7, 9};

   int result[11];

   int *result_end = thrust::set_union(thrust::host, A1, A1 + 7, A2, A2 + 5, result);
   // result = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_union

-  `merge`

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_union**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator>
   OutputIterator
   set_union(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result);

`set_union` constructs a sorted range that is the union of
the sorted ranges `[first1, last1)` and `[first2, last2)`.
The return value is the end of the output range.

In the simplest case, `set_union` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in `[first1, last1)`,
`[first2, last1)`, or both. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if `[first1, last1)`
contains `m` elements that are equivalent to each other and
if `[first2, last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

This version of `set_union` compares elements using
`operator<`.

The following code snippet demonstrates how to use
`set_union` to compute the union of two sets of integers
sorted in ascending order.

::

   #include <thrust/set_operations.h>
   ...
   int A1[7] = {0, 2, 4, 6, 8, 10, 12};
   int A2[5] = {1, 3, 5, 7, 9};

   int result[11];

   int *result_end = thrust::set_union(A1, A1 + 7, A2, A2 + 5, result);
   // result = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `operator<`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_union

-  `merge`

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_union**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   __host__ __device__ OutputIterator
   set_union(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_union` constructs a sorted range that is the union of
the sorted ranges `[first1, last1)` and `[first2, last2)`.
The return value is the end of the output range.

In the simplest case, `set_union` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in `[first1, last1)`,
`[first2, last1)`, or both. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if `[first1, last1)`
contains `m` elements that are equivalent to each other and
if `[first2, last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

This version of `set_union` compares elements using a
function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_union` to compute the union of two sets of integers
sorted in ascending order using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A1[7] = {12, 10, 8, 6, 4, 2, 0};
   int A2[5] = {9, 7, 5, 3, 1};

   int result[11];

   int *result_end = thrust::set_union(thrust::host, A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
   // result = {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_union

-  `merge`

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_union**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename StrictWeakCompare>
   OutputIterator
   set_union(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator2 last2,
     OutputIterator result,
     StrictWeakCompare comp);

`set_union` constructs a sorted range that is the union of
the sorted ranges `[first1, last1)` and `[first2, last2)`.
The return value is the end of the output range.

In the simplest case, `set_union` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in `[first1, last1)`,
`[first2, last1)`, or both. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if `[first1, last1)`
contains `m` elements that are equivalent to each other and
if `[first2, last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

This version of `set_union` compares elements using a
function object `comp`.

The following code snippet demonstrates how to use
`set_union` to compute the union of two sets of integers
sorted in ascending order.

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   ...
   int A1[7] = {12, 10, 8, 6, 4, 2, 0};
   int A2[5] = {9, 7, 5, 3, 1};

   int result[11];

   int *result_end = thrust::set_union(A1, A1 + 7, A2, A2 + 5, result, thrust::greater<int>());
   // result = {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1's` `value_type` is convertable to
   `StrictWeakCompare's` `first_argument_type`. and
   `InputIterator1's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2's` `value_type` is convertable to
   `StrictWeakCompare's` `second_argument_type`. and
   `InputIterator2's` `value_type` is convertable to a
   type in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first1** The beginning of the first input range.

-  **last1** The end of the first input range.

-  **first2** The beginning of the second input range.

-  **last2** The end of the second input range.

-  **result** The beginning of the output range.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[first1, last1)` and `[first2, last2)` shall
   be sorted with respect to `comp`.

-  The resulting range shall not overlap with either input
   range.

**Returns**: The end of the output range.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/set_union

-  `merge`

-  `includes`

-  `set_union`

-  `set_intersection`

-  `set_symmetric_difference`

-  `sort`

-  `is_sorted`

**thrust::set_difference_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_difference_by_key` performs a key-value difference
operation from set theory. `set_difference_by_key` constructs
a sorted range that is the difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_difference_by_key` performs the
“difference” operation from set theory: the keys output range
contains a copy of every element that is contained in
`[keys_first1, keys_last1)` and not contained in
`[keys_first2, keys_last2)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and if `[keys_first2, keys_last2)`
contains `n` elements that are equivalent to them, the last
`max(m-n,0)` elements from `[keys_first1, keys_last1)`
range shall be copied to the output range.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_difference_by_key` compares key elements
using `operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_difference_by_key` to compute the set difference of two
sets of integers sorted in ascending order with their values
using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {0, 1, 3, 4, 5, 6, 9};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {1, 3, 5, 7, 9};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[3];
   int vals_result[3];

   thrust::pair<int*,int*> end =
     thrust::set_difference_by_key(thrust::host,
               A_keys,
               A_keys + 6,
               B_keys,
               B_keys + 5,
               A_vals,
               B_vals,
               keys_result,
               vals_result);

   // keys_result is now {0, 4, 6}
   // vals_result is now {0, 0, 0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution policy.

-  **InputIterator1** is a model of `Input Iterator`, `InputIterator1` and `InputIterator2` have the same `value_type`, `InputIterator1's` `value_type` is a model of `LessThan Comparable`, the ordering on `InputIterator1's` `value_type` is a strict weak ordering, as defined in the `LessThan Comparable` requirements, and `InputIterator1's` `value_type` is convertable to a type in `OutputIterator's` set of `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_difference_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_difference_by_key` performs a key-value difference
operation from set theory. `set_difference_by_key` constructs
a sorted range that is the difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_difference_by_key` performs the
“difference” operation from set theory: the keys output range
contains a copy of every element that is contained in
`[keys_first1, keys_last1)` and not contained in
`[keys_first2, keys_last2)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and if `[keys_first2, keys_last2)`
contains `n` elements that are equivalent to them, the last
`max(m-n,0)` elements from `[keys_first1, keys_last1)`
range shall be copied to the output range.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_difference_by_key` compares key elements
using `operator<`.

The following code snippet demonstrates how to use
`set_difference_by_key` to compute the set difference of two
sets of integers sorted in ascending order with their values.

::

   #include <thrust/set_operations.h>
   ...
   int A_keys[6] = {0, 1, 3, 4, 5, 6, 9};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {1, 3, 5, 7, 9};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[3];
   int vals_result[3];

   thrust::pair<int*,int*> end = thrust::set_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
   // keys_result is now {0, 4, 6}
   // vals_result is now {0, 0, 0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_difference_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_difference_by_key` performs a key-value difference
operation from set theory. `set_difference_by_key` constructs
a sorted range that is the difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_difference_by_key` performs the
“difference” operation from set theory: the keys output range
contains a copy of every element that is contained in
`[keys_first1, keys_last1)` and not contained in
`[keys_first2, keys_last2)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and if `[keys_first2, keys_last2)`
contains `n` elements that are equivalent to them, the last
`max(m-n,0)` elements from `[keys_first1, keys_last1)`
range shall be copied to the output range.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_difference_by_key` compares key elements
using a function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_difference_by_key` to compute the set difference of two
sets of integers sorted in descending order with their values
using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {9, 6, 5, 4, 3, 1, 0};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {9, 7, 5, 3, 1};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[3];
   int vals_result[3];

   thrust::pair<int*,int*> end = thrust::set_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
   // keys_result is now {0, 4, 6}
   // vals_result is now {0, 0, 0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_difference_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_difference_by_key` performs a key-value difference
operation from set theory. `set_difference_by_key` constructs
a sorted range that is the difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_difference_by_key` performs the
“difference” operation from set theory: the keys output range
contains a copy of every element that is contained in
`[keys_first1, keys_last1)` and not contained in
`[keys_first2, keys_last2)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and if `[keys_first2, keys_last2)`
contains `n` elements that are equivalent to them, the last
`max(m-n,0)` elements from `[keys_first1, keys_last1)`
range shall be copied to the output range.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_difference_by_key` compares key elements
using a function object `comp`.

The following code snippet demonstrates how to use
`set_difference_by_key` to compute the set difference of two
sets of integers sorted in descending order with their values.

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   ...
   int A_keys[6] = {9, 6, 5, 4, 3, 1, 0};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {9, 7, 5, 3, 1};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[3];
   int vals_result[3];

   thrust::pair<int*,int*> end = thrust::set_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
   // keys_result is now {0, 4, 6}
   // vals_result is now {0, 0, 0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_intersection_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_intersection_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_intersection_by_key` performs a key-value intersection
operation from set theory. `set_intersection_by_key`
constructs a sorted range that is the intersection of the
sorted ranges `[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_intersection_by_key` performs the
“intersection” operation from set theory: the keys output range
contains a copy of every element that is contained in both
`[keys_first1, keys_last1)` `[keys_first2, keys_last2)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
an element appears `m` times in `[keys_first1, keys_last1)`
and `n` times in `[keys_first2, keys_last2)` (where `m`
may be zero), then it appears `min(m,n)` times in the keys
output range. `set_intersection_by_key` is stable, meaning
both that elements are copied from the first input range rather
than the second, and that the relative order of elements in the
output range is the same as the first input range.

Each time a key element is copied from
`[keys_first1, keys_last1)` to the keys output range, the
corresponding value element is copied from
`[values_first1, values_last1)` to the values output range.

This version of `set_intersection_by_key` compares objects
using `operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_intersection_by_key` to compute the set intersection of
two sets of integers sorted in ascending order with their
values using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {1, 3, 5, 7, 9, 11};
   int A_vals[6] = {0, 0, 0, 0, 0,  0};

   int B_keys[7] = {1, 1, 2, 3, 5,  8, 13};

   int keys_result[7];
   int vals_result[7];

   thrust::pair<int*,int*> end =
     thrust::set_intersection_by_key(thrust::host,
               A_keys,
               A_keys + 6,
               B_keys,
               B_keys + 7,
               A_vals,
               keys_result,
               vals_result);

   // keys_result is now {1, 3, 5}
   // vals_result is now {0, 0, 0}

**Note**: Unlike the other key-value set operations,
`set_intersection_by_key` is unique in that it has no
`values_first2` parameter because elements from the second
input range are never copied to the output range.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_difference_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_intersection_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_intersection_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_intersection_by_key` performs a key-value intersection
operation from set theory. `set_intersection_by_key`
constructs a sorted range that is the intersection of the
sorted ranges `[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_intersection_by_key` performs the
“intersection” operation from set theory: the keys output range
contains a copy of every element that is contained in both
`[keys_first1, keys_last1)` `[keys_first2, keys_last2)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
an element appears `m` times in `[keys_first1, keys_last1)`
and `n` times in `[keys_first2, keys_last2)` (where `m`
may be zero), then it appears `min(m,n)` times in the keys
output range. `set_intersection_by_key` is stable, meaning
both that elements are copied from the first input range rather
than the second, and that the relative order of elements in the
output range is the same as the first input range.

Each time a key element is copied from
`[keys_first1, keys_last1)` to the keys output range, the
corresponding value element is copied from
`[values_first1, values_last1)` to the values output range.

This version of `set_intersection_by_key` compares objects
using `operator<`.

The following code snippet demonstrates how to use
`set_intersection_by_key` to compute the set intersection of
two sets of integers sorted in ascending order with their
values.

::

   #include <thrust/set_operations.h>
   ...
   int A_keys[6] = {1, 3, 5, 7, 9, 11};
   int A_vals[6] = {0, 0, 0, 0, 0,  0};

   int B_keys[7] = {1, 1, 2, 3, 5,  8, 13};

   int keys_result[7];
   int vals_result[7];

   thrust::pair<int*,int*> end =
     thrust::set_intersection_by_key(A_keys,
               A_keys + 6,
               B_keys,
               B_keys + 7,
               A_vals,
               keys_result,
               vals_result);

   // keys_result is now {1, 3, 5}
   // vals_result is now {0, 0, 0}

**Note**: Unlike the other key-value set operations,
`set_intersection_by_key` is unique in that it has no
`values_first2` parameter because elements from the second
input range are never copied to the output range.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_difference_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_intersection_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_intersection_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_intersection_by_key` performs a key-value intersection
operation from set theory. `set_intersection_by_key`
constructs a sorted range that is the intersection of the
sorted ranges `[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_intersection_by_key` performs the
“intersection” operation from set theory: the keys output range
contains a copy of every element that is contained in both
`[keys_first1, keys_last1)` `[keys_first2, keys_last2)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
an element appears `m` times in `[keys_first1, keys_last1)`
and `n` times in `[keys_first2, keys_last2)` (where `m`
may be zero), then it appears `min(m,n)` times in the keys
output range. `set_intersection_by_key` is stable, meaning
both that elements are copied from the first input range rather
than the second, and that the relative order of elements in the
output range is the same as the first input range.

Each time a key element is copied from
`[keys_first1, keys_last1)` to the keys output range, the
corresponding value element is copied from
`[values_first1, values_last1)` to the values output range.

This version of `set_intersection_by_key` compares objects
using a function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_intersection_by_key` to compute the set intersection of
two sets of integers sorted in descending order with their
values using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {11, 9, 7, 5, 3, 1};
   int A_vals[6] = { 0, 0, 0, 0, 0, 0};

   int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};

   int keys_result[7];
   int vals_result[7];

   thrust::pair<int*,int*> end = thrust::set_intersection_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result, thrust::greater<int>());

   // keys_result is now {5, 3, 1}
   // vals_result is now {0, 0, 0}

**Note**: Unlike the other key-value set operations,
`set_intersection_by_key` is unique in that it has no
`values_first2` parameter because elements from the second
input range are never copied to the output range.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_difference_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_intersection_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_intersection_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_intersection_by_key` performs a key-value intersection
operation from set theory. `set_intersection_by_key`
constructs a sorted range that is the intersection of the
sorted ranges `[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_intersection_by_key` performs the
“intersection” operation from set theory: the keys output range
contains a copy of every element that is contained in both
`[keys_first1, keys_last1)` `[keys_first2, keys_last2)`.
The general case is more complicated, because the input ranges
may contain duplicate elements. The generalization is that if
an element appears `m` times in `[keys_first1, keys_last1)`
and `n` times in `[keys_first2, keys_last2)` (where `m`
may be zero), then it appears `min(m,n)` times in the keys
output range. `set_intersection_by_key` is stable, meaning
both that elements are copied from the first input range rather
than the second, and that the relative order of elements in the
output range is the same as the first input range.

Each time a key element is copied from
`[keys_first1, keys_last1)` to the keys output range, the
corresponding value element is copied from
`[values_first1, values_last1)` to the values output range.

This version of `set_intersection_by_key` compares objects
using a function object `comp`.

The following code snippet demonstrates how to use
`set_intersection_by_key` to compute the set intersection of
two sets of integers sorted in descending order with their
values.

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   ...
   int A_keys[6] = {11, 9, 7, 5, 3, 1};
   int A_vals[6] = { 0, 0, 0, 0, 0, 0};

   int B_keys[7] = {13, 8, 5, 3, 2, 1, 1};

   int keys_result[7];
   int vals_result[7];

   thrust::pair<int*,int*> end = thrust::set_intersection_by_key(A_keys, A_keys + 6, B_keys, B_keys + 7, A_vals, keys_result, vals_result, thrust::greater<int>());

   // keys_result is now {5, 3, 1}
   // vals_result is now {0, 0, 0}

**Note**: Unlike the other key-value set operations,
`set_intersection_by_key` is unique in that it has no
`values_first2` parameter because elements from the second
input range are never copied to the output range.

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_difference_by_key`

-  `set_symmetric_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_symmetric_difference_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_symmetric_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_symmetric_difference_by_key` performs a key-value
symmetric difference operation from set theory.
`set_difference_by_key` constructs a sorted range that is the
symmetric difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_symmetric_difference_by_key`
performs a set theoretic calculation: it constructs the union
of the two sets A - B and B - A, where A and B are the two
input ranges. That is, the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)` but not
`[keys_first2, keys_last1)`, and a copy of every element that
is contained in `[keys_first2, keys_last2)` but not
`[keys_first1, keys_last1)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and `[keys_first2, keys_last1)`
contains `n` elements that are equivalent to them, then
`|m - n|` of those elements shall be copied to the output
range: the last `m - n` elements from
`[keys_first1, keys_last1)` if `m > n`, and the last
`n - m` of these elements from `[keys_first2, keys_last2)`
if `m < n`.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_symmetric_difference_by_key` compares
key elements using `operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in ascending order
with their values using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {0, 1, 2, 2, 4, 6, 7};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {1, 1, 2, 5, 8};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[6];
   int vals_result[6];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
   // keys_result is now {0, 4, 5, 6, 7, 8}
   // vals_result is now {0, 0, 1, 0, 0, 1}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_symmetric_difference_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_symmetric_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_symmetric_difference_by_key` performs a key-value
symmetric difference operation from set theory.
`set_difference_by_key` constructs a sorted range that is the
symmetric difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_symmetric_difference_by_key`
performs a set theoretic calculation: it constructs the union
of the two sets A - B and B - A, where A and B are the two
input ranges. That is, the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)` but not
`[keys_first2, keys_last1)`, and a copy of every element that
is contained in `[keys_first2, keys_last2)` but not
`[keys_first1, keys_last1)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and `[keys_first2, keys_last1)`
contains `n` elements that are equivalent to them, then
`|m - n|` of those elements shall be copied to the output
range: the last `m - n` elements from
`[keys_first1, keys_last1)` if `m > n`, and the last
`n - m` of these elements from `[keys_first2, keys_last2)`
if `m < n`.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_symmetric_difference_by_key` compares
key elements using `operator<`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in ascending order
with their values.

::

   #include <thrust/set_operations.h>
   ...
   int A_keys[6] = {0, 1, 2, 2, 4, 6, 7};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {1, 1, 2, 5, 8};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[6];
   int vals_result[6];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
   // keys_result is now {0, 4, 5, 6, 7, 8}
   // vals_result is now {0, 0, 1, 0, 0, 1}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_symmetric_difference_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_symmetric_difference_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_symmetric_difference_by_key` performs a key-value
symmetric difference operation from set theory.
`set_difference_by_key` constructs a sorted range that is the
symmetric difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_symmetric_difference_by_key`
performs a set theoretic calculation: it constructs the union
of the two sets A - B and B - A, where A and B are the two
input ranges. That is, the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)` but not
`[keys_first2, keys_last1)`, and a copy of every element that
is contained in `[keys_first2, keys_last2)` but not
`[keys_first1, keys_last1)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and `[keys_first2, keys_last1)`
contains `n` elements that are equivalent to them, then
`|m - n|` of those elements shall be copied to the output
range: the last `m - n` elements from
`[keys_first1, keys_last1)` if `m > n`, and the last
`n - m` of these elements from `[keys_first2, keys_last2)`
if `m < n`.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_symmetric_difference_by_key` compares
key elements using a function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in descending order
with their values using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {7, 6, 4, 2, 2, 1, 0};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {8, 5, 2, 1, 1};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[6];
   int vals_result[6];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
   // keys_result is now {8, 7, 6, 5, 4, 0}
   // vals_result is now {1, 0, 0, 1, 0, 0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_symmetric_difference_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_symmetric_difference_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_symmetric_difference_by_key` performs a key-value
symmetric difference operation from set theory.
`set_difference_by_key` constructs a sorted range that is the
symmetric difference of the sorted ranges
`[keys_first1, keys_last1)` and
`[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_symmetric_difference_by_key`
performs a set theoretic calculation: it constructs the union
of the two sets A - B and B - A, where A and B are the two
input ranges. That is, the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)` but not
`[keys_first2, keys_last1)`, and a copy of every element that
is contained in `[keys_first2, keys_last2)` but not
`[keys_first1, keys_last1)`. The general case is more
complicated, because the input ranges may contain duplicate
elements. The generalization is that if
`[keys_first1, keys_last1)` contains `m` elements that are
equivalent to each other and `[keys_first2, keys_last1)`
contains `n` elements that are equivalent to them, then
`|m - n|` of those elements shall be copied to the output
range: the last `m - n` elements from
`[keys_first1, keys_last1)` if `m > n`, and the last
`n - m` of these elements from `[keys_first2, keys_last2)`
if `m < n`.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_symmetric_difference_by_key` compares
key elements using a function object `comp`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in descending order
with their values.

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   ...
   int A_keys[6] = {7, 6, 4, 2, 2, 1, 0};
   int A_vals[6] = {0, 0, 0, 0, 0, 0, 0};

   int B_keys[5] = {8, 5, 2, 1, 1};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[6];
   int vals_result[6];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
   // keys_result is now {8, 7, 6, 5, 4, 0}
   // vals_result is now {1, 0, 0, 1, 0, 0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_union_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_union_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_union_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_union_by_key` performs a key-value union operation from
set theory. `set_union_by_key` constructs a sorted range that
is the union of the sorted ranges `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_union_by_key` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)`, `[keys_first2, keys_last1)`,
or both. The general case is more complicated, because the
input ranges may contain duplicate elements. The generalization
is that if `[keys_first1, keys_last1)` contains `m`
elements that are equivalent to each other and if
`[keys_first2, keys_last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_union_by_key` compares key elements
using `operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in ascending order
with their values using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {0, 2, 4, 6, 8, 10, 12};
   int A_vals[6] = {0, 0, 0, 0, 0,  0,  0};

   int B_keys[5] = {1, 3, 5, 7, 9};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[11];
   int vals_result[11];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
   // keys_result is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}
   // vals_result is now {0, 1, 0, 1, 0, 1, 0, 1, 0, 1,  0,  0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_symmetric_difference_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_union_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_union_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result);

`set_union_by_key` performs a key-value union operation from
set theory. `set_union_by_key` constructs a sorted range that
is the union of the sorted ranges `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_union_by_key` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)`, `[keys_first2, keys_last1)`,
or both. The general case is more complicated, because the
input ranges may contain duplicate elements. The generalization
is that if `[keys_first1, keys_last1)` contains `m`
elements that are equivalent to each other and if
`[keys_first2, keys_last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_union_by_key` compares key elements
using `operator<`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in ascending order
with their values.

::

   #include <thrust/set_operations.h>
   ...
   int A_keys[6] = {0, 2, 4, 6, 8, 10, 12};
   int A_vals[6] = {0, 0, 0, 0, 0,  0,  0};

   int B_keys[5] = {1, 3, 5, 7, 9};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[11];
   int vals_result[11];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result);
   // keys_result is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12}
   // vals_result is now {0, 1, 0, 1, 0, 1, 0, 1, 0, 1,  0,  0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `operator<`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_symmetric_difference_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_union_by_key**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   __host__ __device__ thrust::pair< OutputIterator1, OutputIterator2 >
   set_union_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_union_by_key` performs a key-value union operation from
set theory. `set_union_by_key` constructs a sorted range that
is the union of the sorted ranges `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_union_by_key` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)`, `[keys_first2, keys_last1)`,
or both. The general case is more complicated, because the
input ranges may contain duplicate elements. The generalization
is that if `[keys_first1, keys_last1)` contains `m`
elements that are equivalent to each other and if
`[keys_first2, keys_last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_union_by_key` compares key elements
using a function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in descending order
with their values using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   int A_keys[6] = {12, 10, 8, 6, 4, 2, 0};
   int A_vals[6] = { 0,  0, 0, 0, 0, 0, 0};

   int B_keys[5] = {9, 7, 5, 3, 1};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[11];
   int vals_result[11];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(thrust::host, A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
   // keys_result is now {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
   // vals_result is now { 0,  1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_symmetric_difference_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

**thrust::set_union_by_key**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename InputIterator4,
     typename OutputIterator1,
     typename OutputIterator2,
     typename StrictWeakCompare>
   thrust::pair< OutputIterator1, OutputIterator2 >
   set_union_by_key(InputIterator1 keys_first1,
     InputIterator1 keys_last1,
     InputIterator2 keys_first2,
     InputIterator2 keys_last2,
     InputIterator3 values_first1,
     InputIterator4 values_first2,
     OutputIterator1 keys_result,
     OutputIterator2 values_result,
     StrictWeakCompare comp);

`set_union_by_key` performs a key-value union operation from
set theory. `set_union_by_key` constructs a sorted range that
is the union of the sorted ranges `[keys_first1, keys_last1)`
and `[keys_first2, keys_last2)`. Associated with each element
from the input and output key ranges is a value element. The
associated input value ranges need not be sorted.

In the simplest case, `set_union_by_key` performs the “union”
operation from set theory: the output range contains a copy of
every element that is contained in
`[keys_first1, keys_last1)`, `[keys_first2, keys_last1)`,
or both. The general case is more complicated, because the
input ranges may contain duplicate elements. The generalization
is that if `[keys_first1, keys_last1)` contains `m`
elements that are equivalent to each other and if
`[keys_first2, keys_last2)` contains `n` elements that are
equivalent to them, then all `m` elements from the first
range shall be copied to the output range, in order, and then
`max(n - m, 0)` elements from the second range shall be
copied to the output, in order.

Each time a key element is copied from
`[keys_first1, keys_last1)` or `[keys_first2, keys_last2)`
is copied to the keys output range, the corresponding value
element is copied from the corresponding values input range
(beginning at `values_first1` or `values_first2`) to the
values output range.

This version of `set_union_by_key` compares key elements
using a function object `comp`.

The following code snippet demonstrates how to use
`set_symmetric_difference_by_key` to compute the symmetric
difference of two sets of integers sorted in descending order
with their values.

::

   #include <thrust/set_operations.h>
   #include <thrust/functional.h>
   ...
   int A_keys[6] = {12, 10, 8, 6, 4, 2, 0};
   int A_vals[6] = { 0,  0, 0, 0, 0, 0, 0};

   int B_keys[5] = {9, 7, 5, 3, 1};
   int B_vals[5] = {1, 1, 1, 1, 1};

   int keys_result[11];
   int vals_result[11];

   thrust::pair<int*,int*> end = thrust::set_symmetric_difference_by_key(A_keys, A_keys + 6, B_keys, B_keys + 5, A_vals, B_vals, keys_result, vals_result, thrust::greater<int>());
   // keys_result is now {12, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}
   // vals_result is now { 0,  1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0}

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`,
   `InputIterator1` and `InputIterator2` have the same
   `value_type`, `InputIterator1's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator1's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator1's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator2** is a model of `Input Iterator`,
   `InputIterator2` and `InputIterator1` have the same
   `value_type`, `InputIterator2's` `value_type` is a
   model of `LessThan Comparable`,
   the ordering on `InputIterator2's` `value_type` is a
   strict weak ordering, as defined in the `LessThan Comparable`
   requirements, and `InputIterator2's` `value_type` is
   convertable to a type in `OutputIterator's` set of
   `value_types`.

-  **InputIterator3** is a model of `Input Iterator`,
   and `InputIterator3's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **InputIterator4** is a model of `Input Iterator`,
   and `InputIterator4's` `value_type` is convertible to a
   type in `OutputIterator2's` set of `value_types`.

-  **OutputIterator1** is a model of `Output Iterator`.

-  **OutputIterator2** is a model of `Output Iterator`.

-  **StrictWeakCompare** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **keys_first1** The beginning of the first input range
   of keys.

-  **keys_last1** The end of the first input range of keys.

-  **keys_first2** The beginning of the second input range
   of keys.

-  **keys_last2** The end of the second input range of
   keys.

-  **values_first1** The beginning of the first input range
   of values.

-  **values_first2** The beginning of the first input range
   of values.

-  **keys_result** The beginning of the output range of
   keys.

-  **values_result** The beginning of the output range of
   values.

-  **comp** Comparison operator.

**Preconditions**:

-  The ranges `[keys_first1, keys_last1)` and
   `[keys_first2, keys_last2)` shall be sorted with respect
   to `comp`.

-  The resulting ranges shall not overlap with any input range.

**Returns**: A `pair` `p` such that `p.first` is the end
of the output range of keys, and such that `p.second` is the
end of the output range of values.

**See**:

-  `set_symmetric_difference_by_key`

-  `set_intersection_by_key`

-  `set_difference_by_key`

-  `sort_by_key`

-  `is_sorted`

Sorting
-------
**Functions**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator>
   __host__ __device__ void
   thrust::sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last);

   template <typename RandomAccessIterator>
   void
   thrust::sort(RandomAccessIterator first,
     RandomAccessIterator last);

   template <typename DerivedPolicy,
     typename RandomAccessIterator,
     typename StrictWeakOrdering>
   __host__ __device__ void
   thrust::sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last,
     StrictWeakOrdering comp);

   template <typename RandomAccessIterator,
     typename StrictWeakOrdering>
   __host__ __device__ void
   thrust::sort(RandomAccessIterator first,
     RandomAccessIterator last,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename RandomAccessIterator>
   __host__ __device__ void
   thrust::stable_sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last);

   template <typename RandomAccessIterator>
   void
   thrust::stable_sort(RandomAccessIterator first,
     RandomAccessIterator last);

   template <typename DerivedPolicy,
     typename RandomAccessIterator,
     typename StrictWeakOrdering>
   __host__ __device__ void
   thrust::stable_sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last,  
     StrictWeakOrdering comp);

   template <typename RandomAccessIterator,
     typename StrictWeakOrdering>
   void
   thrust::stable_sort(RandomAccessIterator first,
     RandomAccessIterator last,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   __host__ __device__ void
   thrust::sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   void
   thrust::sort_by_key(RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   __host__ __device__ void
   thrust::sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   void
   thrust::sort_by_key(RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   __host__ __device__ void
   thrust::stable_sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   void
   thrust::stable_sort_by_key(RandomAccessIterator1 keys_first,
    RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   __host__ __device__ void
   thrust::stable_sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   void
   thrust::stable_sort_by_key(RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

**thrust::sort**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator>
   __host__ __device__ void
   sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last);

`sort` sorts the elements in `[first, last)` into ascending
order, meaning that if `i` and `j` are any two valid
iterators in `[first, last)` such that `i` precedes `j`,
then `*j` is not less than `*i`. Note: `sort` is not
guaranteed to be stable. That is, suppose that `*i` and
`*j` are equivalent: neither one is less than the other. It
is not guaranteed that the relative order of these two elements
will be preserved by `sort`.

This version of `sort` compares objects using `operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `sort` to
sort a sequence of integers using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::sort(thrust::host, A, A + N);
   // A is now {1, 2, 4, 5, 7, 8}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator** is a model of `Random Access Iterator`,
   `RandomAccessIterator` is mutable, and
   `RandomAccessIterator's` `value_type` is a model of
   `LessThan Comparable`,
   and the ordering relation on
   `RandomAccessIterator's` `value_type` is a *strict weak
   ordering*, as defined in the `LessThan Comparable`
   requirements.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort`

-  `sort_by_key`

**thrust::sort**

::

   template <typename RandomAccessIterator>
   void
   sort(RandomAccessIterator first,
     RandomAccessIterator last);

`sort` sorts the elements in `[first, last)` into ascending
order, meaning that if `i` and `j` are any two valid
iterators in `[first, last)` such that `i` precedes `j`,
then `*j` is not less than `*i`. Note: `sort` is not
guaranteed to be stable. That is, suppose that `*i` and
`*j` are equivalent: neither one is less than the other. It
is not guaranteed that the relative order of these two elements
will be preserved by `sort`.

This version of `sort` compares objects using `operator<`.

The following code snippet demonstrates how to use `sort` to
sort a sequence of integers.

::

   #include <thrust/sort.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::sort(A, A + N);
   // A is now {1, 2, 4, 5, 7, 8}

**Template Parameters**: **RandomAccessIterator**: is a
model of `Random Access Iterator`,
`RandomAccessIterator` is mutable, and
`RandomAccessIterator's` `value_type` is a model of
`LessThan Comparable`,
and the ordering relation on
`RandomAccessIterator's` `value_type` is a *strict weak
ordering*, as defined in the `LessThan Comparable`
requirements.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort`

-  `sort_by_key`

**thrust::sort**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator,
     typename StrictWeakOrdering>
   __host__ __device__ void
   sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last,
     StrictWeakOrdering comp);

`sort` sorts the elements in `[first, last)` into ascending
order, meaning that if `i` and `j` are any two valid
iterators in `[first, last)` such that `i` precedes `j`,
then `*j` is not less than `*i`. Note: `sort` is not
guaranteed to be stable. That is, suppose that `*i` and
`*j` are equivalent: neither one is less than the other. It
is not guaranteed that the relative order of these two elements
will be preserved by `sort`.

This version of `sort` compares objects using a function
object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code demonstrates how to sort integers in
descending order using the greater comparison operator using
the `thrust::host` execution policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::sort(thrust::host, A, A + N, thrust::greater<int>());
   // A is now {8, 7, 5, 4, 2, 1};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator** is a model of `Random Access Iterator`,
   `RandomAccessIterator` is mutable, and
   `RandomAccessIterator's` `value_type` is convertible to
   `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** Comparison operator.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort`

-  `sort_by_key`

**thrust::sort**

::

   template <typename RandomAccessIterator,
     typename StrictWeakOrdering>
   __host__ __device__ void
   sort(RandomAccessIterator first,
     RandomAccessIterator last,
     StrictWeakOrdering comp);

`sort` sorts the elements in `[first, last)` into ascending
order, meaning that if `i` and `j` are any two valid
iterators in `[first, last)` such that `i` precedes `j`,
then `*j` is not less than `*i`. Note: `sort` is not
guaranteed to be stable. That is, suppose that `*i` and
`*j` are equivalent: neither one is less than the other. It
is not guaranteed that the relative order of these two elements
will be preserved by `sort`.

This version of `sort` compares objects using a function
object `comp`.

The following code demonstrates how to sort integers in
descending order using the greater comparison operator.

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::sort(A, A + N, thrust::greater<int>());
   // A is now {8, 7, 5, 4, 2, 1};

**Template Parameters**:

-  **RandomAccessIterator** is a model of `Random Access Iterator`,
   `RandomAccessIterator` is mutable, and
   `RandomAccessIterator's` `value_type` is convertible to
   `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** Comparison operator.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort`

-  `sort_by_key`

**thrust::stable_sort**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator>
   __host__ __device__ void
   stable_sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last);

`stable_sort` is much like `sort:` it sorts the elements in
`[first, last)` into ascending order, meaning that if `i`
and `j` are any two valid iterators in `[first, last)` such
that `i` precedes `j`, then `*j` is not less than `*i`.

As the name suggests, `stable_sort` is stable: it preserves
the relative ordering of equivalent elements. That is, if `x`
and `y` are elements in `[first, last)` such that `x`
precedes `y`, and if the two elements are equivalent (neither
`x < y` nor `y < x`) then a postcondition of
`stable_sort` is that `x` still precedes `y`.

This version of `stable_sort` compares objects using
`operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `sort` to
sort a sequence of integers using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::stable_sort(thrust::host, A, A + N);
   // A is now {1, 2, 4, 5, 7, 8}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator** is a model of `Random Access Iterator`,
   `RandomAccessIterator` is mutable, and
   `RandomAccessIterator's` `value_type` is a model of
   `LessThan Comparable`,
   and the ordering relation on
   `RandomAccessIterator's` `value_type` is a *strict weak
   ordering*, as defined in the `LessThan Comparable`
   requirements.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_sort

-  `sort`

-  `stable_sort_by_key`

**thrust::stable_sort**

::

   template <typename RandomAccessIterator>
   void
   stable_sort(RandomAccessIterator first,
     RandomAccessIterator last);

`stable_sort` is much like `sort:` it sorts the elements in
`[first, last)` into ascending order, meaning that if `i`
and `j` are any two valid iterators in `[first, last)` such
that `i` precedes `j`, then `*j` is not less than `*i`.

As the name suggests, `stable_sort` is stable: it preserves
the relative ordering of equivalent elements. That is, if `x`
and `y` are elements in `[first, last)` such that `x`
precedes `y`, and if the two elements are equivalent (neither
`x < y` nor `y < x`) then a postcondition of
`stable_sort` is that `x` still precedes `y`.

This version of `stable_sort` compares objects using
`operator<`.

The following code snippet demonstrates how to use `sort` to
sort a sequence of integers.

::

   #include <thrust/sort.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::stable_sort(A, A + N);
   // A is now {1, 2, 4, 5, 7, 8}

**Template Parameters**: **RandomAccessIterator**: is a
model of `Random Access Iterator`,
`RandomAccessIterator` is mutable, and
`RandomAccessIterator's` `value_type` is a model of
`LessThan Comparable`,
and the ordering relation on
`RandomAccessIterator's` `value_type` is a *strict weak
ordering*, as defined in the `LessThan Comparable`
requirements.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_sort

-  `sort`

-  `stable_sort_by_key`

**thrust::stable_sort**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator,
     typename StrictWeakOrdering>
   __host__ __device__ void
   stable_sort(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator first,
     RandomAccessIterator last,
     StrictWeakOrdering comp);

`stable_sort` is much like `sort:` it sorts the elements in
`[first, last)` into ascending order, meaning that if `i`
and `j` are any two valid iterators in `[first, last)` such
that `i` precedes `j`, then `*j` is not less than `*i`.

As the name suggests, `stable_sort` is stable: it preserves
the relative ordering of equivalent elements. That is, if `x`
and `y` are elements in `[first, last)` such that `x`
precedes `y`, and if the two elements are equivalent (neither
`x < y` nor `y < x`) then a postcondition of
`stable_sort` is that `x` still precedes `y`.

This version of `stable_sort` compares objects using a
function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code demonstrates how to sort integers in
descending order using the greater comparison operator using
the `thrust::host` execution policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::sort(A, A + N, thrust::greater<int>());
   // A is now {8, 7, 5, 4, 2, 1};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator** is a model of `Random Access Iterator`,
   `RandomAccessIterator` is mutable, and
   `RandomAccessIterator's` `value_type` is convertible to
   `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** Comparison operator.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_sort

-  `sort`

-  `stable_sort_by_key`

**thrust::stable_sort**

::

   template <typename RandomAccessIterator,
     typename StrictWeakOrdering>
   void
   stable_sort(RandomAccessIterator first,
     RandomAccessIterator last,
     StrictWeakOrdering comp);

`stable_sort` is much like `sort:` it sorts the elements in
`[first, last)` into ascending order, meaning that if `i`
and `j` are any two valid iterators in `[first, last)` such
that `i` precedes `j`, then `*j` is not less than `*i`.

As the name suggests, `stable_sort` is stable: it preserves
the relative ordering of equivalent elements. That is, if `x`
and `y` are elements in `[first, last)` such that `x`
precedes `y`, and if the two elements are equivalent (neither
`x < y` nor `y < x`) then a postcondition of
`stable_sort` is that `x` still precedes `y`.

This version of `stable_sort` compares objects using a
function object `comp`.

The following code demonstrates how to sort integers in
descending order using the greater comparison operator.

::

   #include <thrust/sort.h>
   #include <thrust/functional.h>
   ...
   const int N = 6;
   int A[N] = {1, 4, 2, 8, 5, 7};
   thrust::sort(A, A + N, thrust::greater<int>());
   // A is now {8, 7, 5, 4, 2, 1};

**Template Parameters**:

-  **RandomAccessIterator** is a model of `Random Access Iterator`,
   `RandomAccessIterator` is mutable, and
   `RandomAccessIterator's` `value_type` is convertible to
   `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **comp** Comparison operator.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/stable_sort

-  `sort`

-  `stable_sort_by_key`

**thrust::sort_by_key**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   __host__ __device__ void
   sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

`sort_by_key` performs a key-value sort. That is,
`sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

Note: `sort_by_key` is not guaranteed to be stable. That is,
suppose that `*i` and `*j` are equivalent: neither one is
less than the other. It is not guaranteed that the relative
order of these two keys or the relative order of their
corresponding values will be preserved by `sort_by_key`.

This version of `sort_by_key` compares key objects using
`operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`sort_by_key` to sort an array of character values using
integers as sorting keys using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::sort_by_key(thrust::host, keys, keys + N, values);
   // keys is now   {  1,   2,   4,   5,   7,   8}
   // values is now {'a', 'c', 'b', 'e', 'f', 'd'}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   and the ordering relation on
   `RandomAccessIterator1's` `value_type` is a *strict
   weak ordering*, as defined in the `LessThan Comparable`
   requirements.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort_by_key`

-  `sort`

**thrust::sort_by_key**

::

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   void
   sort_by_key(RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

`sort_by_key` performs a key-value sort. That is,
`sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

Note: `sort_by_key` is not guaranteed to be stable. That is,
suppose that `*i` and `*j` are equivalent: neither one is
less than the other. It is not guaranteed that the relative
order of these two keys or the relative order of their
corresponding values will be preserved by `sort_by_key`.

This version of `sort_by_key` compares key objects using
`operator<`.

The following code snippet demonstrates how to use
`sort_by_key` to sort an array of character values using
integers as sorting keys.

::

   #include <thrust/sort.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::sort_by_key(keys, keys + N, values);
   // keys is now   {  1,   2,   4,   5,   7,   8}
   // values is now {'a', 'c', 'b', 'e', 'f', 'd'}

**Template Parameters**:

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   and the ordering relation on
   `RandomAccessIterator1's` `value_type` is a *strict
   weak ordering*, as defined in the `LessThan Comparable`
   requirements.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

**Function Parameters**:

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort_by_key`

-  `sort`

**thrust::sort_by_key**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   __host__ __device__ void
   sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

`sort_by_key` performs a key-value sort. That is,
`sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

Note: `sort_by_key` is not guaranteed to be stable. That is,
suppose that `*i` and `*j` are equivalent: neither one is
less than the other. It is not guaranteed that the relative
order of these two keys or the relative order of their
corresponding values will be preserved by `sort_by_key`.

This version of `sort_by_key` compares key objects using a
function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`sort_by_key` to sort an array of character values using
integers as sorting keys using the `thrust::host` execution
policy for parallelization.The keys are sorted in descending
order using the `greater<int>` comparison operator.

::

   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::sort_by_key(thrust::host, keys, keys + N, values, thrust::greater<int>());
   // keys is now   {  8,   7,   5,   4,   2,   1}
   // values is now {'d', 'f', 'e', 'b', 'c', 'a'}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is convertible
   to `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

-  **comp** Comparison operator.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort_by_key`

-  `sort`

**thrust::sort_by_key**

::

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   void
   sort_by_key(RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

`sort_by_key` performs a key-value sort. That is,
`sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

Note: `sort_by_key` is not guaranteed to be stable. That is,
suppose that `*i` and `*j` are equivalent: neither one is
less than the other. It is not guaranteed that the relative
order of these two keys or the relative order of their
corresponding values will be preserved by `sort_by_key`.

This version of `sort_by_key` compares key objects using a
function object `comp`.

The following code snippet demonstrates how to use
`sort_by_key` to sort an array of character values using
integers as sorting keys. The keys are sorted in descending
order using the greater comparison operator.

::

   #include <thrust/sort.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::sort_by_key(keys, keys + N, values, thrust::greater<int>());
   // keys is now   {  8,   7,   5,   4,   2,   1}
   // values is now {'d', 'f', 'e', 'b', 'c', 'a'}

**Template Parameters**:

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is convertible
   to `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

-  **comp** Comparison operator.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `stable_sort_by_key`

-  `sort`

**thrust::stable_sort_by_key**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   __host__ __device__ void
   stable_sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

`stable_sort_by_key` performs a key-value sort. That is,
`stable_sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

As the name suggests, `stable_sort_by_key` is stable: it
preserves the relative ordering of equivalent elements. That
is, if `x` and `y` are elements in
`[keys_first, keys_last)` such that `x` precedes `y`, and
if the two elements are equivalent (neither `x < y` nor
`y < x`) then a postcondition of `stable_sort_by_key` is
that `x` still precedes `y`.

This version of `stable_sort_by_key` compares key objects
using `operator<`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`stable_sort_by_key` to sort an array of characters using
integers as sorting keys using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::stable_sort_by_key(thrust::host, keys, keys + N, values);
   // keys is now   {  1,   2,   4,   5,   7,   8}
   // values is now {'a', 'c', 'b', 'e', 'f', 'd'}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   and the ordering relation on
   `RandomAccessIterator1's` `value_type` is a *strict
   weak ordering*, as defined in the `LessThan Comparable`
   requirements.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `sort_by_key`

-  `stable_sort`

**thrust::stable_sort_by_key**

::

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2>
   void
   stable_sort_by_key(RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first);

`stable_sort_by_key` performs a key-value sort. That is,
`stable_sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

As the name suggests, `stable_sort_by_key` is stable: it
preserves the relative ordering of equivalent elements. That
is, if `x` and `y` are elements in
`[keys_first, keys_last)` such that `x` precedes `y`, and
if the two elements are equivalent (neither `x < y` nor
`y < x`) then a postcondition of `stable_sort_by_key` is
that `x` still precedes `y`.

This version of `stable_sort_by_key` compares key objects
using `operator<`.

The following code snippet demonstrates how to use
`stable_sort_by_key` to sort an array of characters using
integers as sorting keys.

::

   #include <thrust/sort.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::stable_sort_by_key(keys, keys + N, values);
   // keys is now   {  1,   2,   4,   5,   7,   8}
   // values is now {'a', 'c', 'b', 'e', 'f', 'd'}

**Template Parameters**:

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is a model of
   `LessThan Comparable`,
   and the ordering relation on
   `RandomAccessIterator1's` `value_type` is a *strict
   weak ordering*, as defined in the `LessThan Comparable`
   requirements.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

**Function Parameters**:

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `sort_by_key`

-  `stable_sort`

**thrust::stable_sort_by_key**

::

   template <typename DerivedPolicy,
     typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   __host__ __device__ void
   stable_sort_by_key(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

`stable_sort_by_key` performs a key-value sort. That is,
`stable_sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

As the name suggests, `stable_sort_by_key` is stable: it
preserves the relative ordering of equivalent elements. That
is, if `x` and `y` are elements in
`[keys_first, keys_last)` such that `x` precedes `y`, and
if the two elements are equivalent (neither `x < y` nor
`y < x`) then a postcondition of `stable_sort_by_key` is
that `x` still precedes `y`.

This version of `stable_sort_by_key` compares key objects
using the function object `comp`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`sort_by_key` to sort an array of character values using
integers as sorting keys using the `thrust::host` execution
policy for parallelization. The keys are sorted in descending
order using the `greater<int>` comparison operator.

::

   #include <thrust/sort.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::stable_sort_by_key(thrust::host, keys, keys + N, values, thrust::greater<int>());
   // keys is now   {  8,   7,   5,   4,   2,   1}
   // values is now {'d', 'f', 'e', 'b', 'c', 'a'}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is convertible
   to `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

-  **comp** Comparison operator.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `sort_by_key`

-  `stable_sort`

**thrust::stable_sort_by_key**

::

   template <typename RandomAccessIterator1,
     typename RandomAccessIterator2,
     typename StrictWeakOrdering>
   void
   stable_sort_by_key(RandomAccessIterator1 keys_first,
     RandomAccessIterator1 keys_last,
     RandomAccessIterator2 values_first,
     StrictWeakOrdering comp);

`stable_sort_by_key` performs a key-value sort. That is,
`stable_sort_by_key` sorts the elements in
`[keys_first, keys_last)` and
`[values_first, values_first + (keys_last - keys_first))`
into ascending key order, meaning that if `i` and `j` are
any two valid iterators in `[keys_first, keys_last)` such
that `i` precedes `j`, and `p` and `q` are iterators in
`[values_first, values_first + (keys_last - keys_first))`
corresponding to `i` and `j` respectively, then `*j` is
not less than `*i`.

As the name suggests, `stable_sort_by_key` is stable: it
preserves the relative ordering of equivalent elements. That
is, if `x` and `y` are elements in
`[keys_first, keys_last)` such that `x` precedes `y`, and
if the two elements are equivalent (neither `x < y` nor
`y < x`) then a postcondition of `stable_sort_by_key` is
that `x` still precedes `y`.

This version of `stable_sort_by_key` compares key objects
using the function object `comp`.

The following code snippet demonstrates how to use
`sort_by_key` to sort an array of character values using
integers as sorting keys. The keys are sorted in descending
order using the greater comparison operator.

::

   #include <thrust/sort.h>
   ...
   const int N = 6;
   int    keys[N] = {  1,   4,   2,   8,   5,   7};
   char values[N] = {'a', 'b', 'c', 'd', 'e', 'f'};
   thrust::stable_sort_by_key(keys, keys + N, values, thrust::greater<int>());
   // keys is now   {  8,   7,   5,   4,   2,   1}
   // values is now {'d', 'f', 'e', 'b', 'c', 'a'}

**Template Parameters**:

-  **RandomAccessIterator1** is a model of `Random Access Iterator`,
   `RandomAccessIterator1` is mutable, and
   `RandomAccessIterator1's` `value_type` is convertible
   to `StrictWeakOrdering's` `first_argument_type` and
   `second_argument_type`.

-  **RandomAccessIterator2** is a model of `Random Access Iterator`,
   and `RandomAccessIterator2` is mutable.

-  **StrictWeakOrdering** is a model of `Strict Weak Ordering`.

**Function Parameters**:

-  **keys_first** The beginning of the key sequence.

-  **keys_last** The end of the key sequence.

-  **values_first** The beginning of the value sequence.

-  **comp** Comparison operator.

**Preconditions**: The range `[keys_first, keys_last))` shall
not overlap the range
`[values_first, values_first + (keys_last - keys_first))`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/sort

-  `sort_by_key`

-  `stable_sort`

Transformations
---------------
**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   thrust::adjacent_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename BinaryFunction>
   __host__ __device__ OutputIterator
   thrust::adjacent_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryFunction binary_op);

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   thrust::adjacent_difference(InputIterator first,
     InputIterator last,
     OutputIterator result);

   template <typename InputIterator,
     typename OutputIterator,
     typename BinaryFunction>
   OutputIterator
   thrust::adjacent_difference(InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryFunction binary_op);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Generator>
   __host__ __device__ void
   thrust::generate(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Generator gen);

   template <typename ForwardIterator,
     typename Generator>
   void
   thrust::generate(ForwardIterator first,
     ForwardIterator last,
     Generator gen);

   template <typename DerivedPolicy,
     typename OutputIterator,
     typename Size,
     typename Generator>
   __host__ __device__ OutputIterator
   thrust::generate_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     OutputIterator first,
     Size n,
     Generator gen);

   template <typename OutputIterator,
     typename Size,
     typename Generator>
   OutputIterator
   thrust::generate_n(OutputIterator first,
     Size n,
     Generator gen);

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ void
   thrust::sequence(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

   template <typename ForwardIterator>
   void
   thrust::sequence(ForwardIterator first,
     ForwardIterator last);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   thrust::sequence(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     T init);

   template <typename ForwardIterator,
     typename T>
   void
   thrust::sequence(ForwardIterator first,
     ForwardIterator last,
     T init);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   thrust::sequence(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     T init,
     T step);

   template <typename ForwardIterator,
     typename T>
   void
   thrust::sequence(ForwardIterator first,
     ForwardIterator last,
     T init,
     T step);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename UnaryOperation>
   __host__ __device__ void
   thrust::tabulate(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     UnaryOperation unary_op);

   template <typename ForwardIterator,
     typename UnaryOperation>
   void
   thrust::tabulate(ForwardIterator first,
     ForwardIterator last,
     UnaryOperation unary_op);

   template <typename DerivedPolicy,
     typename InputIterator,
    typename OutputIterator,
     typename UnaryFunction>
   __host__ __device__ OutputIterator
   thrust::transform(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction op);

   template <typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction>
   OutputIterator
   thrust::transform(InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction op);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryFunction>
   __host__ __device__ OutputIterator
   thrust::transform(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryFunction op);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryFunction>
   OutputIterator
   thrust::transform(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryFunction op);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   __host__ __device__ ForwardIterator
   thrust::transform_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     ForwardIterator result,
     UnaryFunction op,
     Predicate pred);

   template <typename InputIterator,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   ForwardIterator
   thrust::transform_if(InputIterator first,
     InputIterator last,
     ForwardIterator result,
     UnaryFunction op,
     Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   __host__ __device__ ForwardIterator
   thrust::transform_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     ForwardIterator result,
     UnaryFunction op,
     Predicate pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   ForwardIterator
   thrust::transform_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     ForwardIterator result,
     UnaryFunction op,  
    Predicate pred);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename ForwardIterator,
     typename BinaryFunction,
     typename Predicate>
   __host__ __device__ ForwardIterator
   thrust::transform_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator3 stencil,
     ForwardIterator result,
     BinaryFunction binary_op,
     Predicate pred);

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename ForwardIterator,
     typename BinaryFunction,
     typename Predicate>
   orwardIterator
   thrust::transform_if(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator3 stencil,
     ForwardIterator result,
     BinaryFunction binary_op,
     Predicate pred);

**thrust::adjacent_difference**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator>
   __host__ __device__ OutputIterator
   adjacent_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result);

`adjacent_difference` calculates the differences of adjacent
elements in the range `[first, last)`. That is, `*first` is
assigned to `*result`, and, for each iterator `i` in the
range `[first + 1, last)`, the difference of `*i` and
`*(i - 1)` is assigned to `*(result + (i - first))`.

This version of `adjacent_difference` uses `operator-` to
calculate differences.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`adjacent_difference` to compute the difference between
adjacent elements of a range using the `thrust::device`
execution policy:

::

   #include <thrust/adjacent_difference.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
   thrust::device_vector<int> d_data(h_data, h_data + 8);
   thrust::device_vector<int> d_result(8);

   thrust::adjacent_difference(thrust::device, d_data.begin(), d_data.end(), d_result.begin());

   // d_result is now [1, 1, -1, 1, -1, 1, -1, 1]

**Remark**: Note that `result` is permitted to be the same
iterator as `first`. This is useful for computing differences
“in place”.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `x` and `y` are objects of
   `InputIterator's` `value_type`, then `x` - `is`
   defined, and `InputIterator's` `value_type` is
   convertible to a type in `OutputIterator's` set of
   `value_types`, and the return type of `x - y` is
   convertible to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

**Returns**: The iterator `result + (last - first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/adjacent_difference

-  inclusive_scan

**thrust::adjacent_difference**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename BinaryFunction>
   __host__ __device__ OutputIterator
   adjacent_difference(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryFunction binary_op);

`adjacent_difference` calculates the differences of adjacent
elements in the range `[first, last)`. That is, `*first` is
assigned to `*result`, and, for each iterator `i` in the
range `[first + 1, last)`, `binary_op(*i, *(i - 1))` is
assigned to `*(result + (i - first))`.

This version of `adjacent_difference` uses the binary
function `binary_op` to calculate differences.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`adjacent_difference` to compute the sum between adjacent
elements of a range using the `thrust::device` execution
policy:

::

   #include <thrust/adjacent_difference.h>
   #include <thrust/functional.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
   thrust::device_vector<int> d_data(h_data, h_data + 8);
   thrust::device_vector<int> d_result(8);

   thrust::adjacent_difference(thrust::device, d_data.begin(), d_data.end(), d_result.begin(), thrust::plus<int>());

   // d_result is now [1, 3, 3, 3, 3, 3, 3, 3]

**Remark**: Note that `result` is permitted to be the same
iterator as `first`. This is useful for computing differences
“in place”.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `BinaryFunction's` `first_argument_type` and
   `second_argument_type`, and
   `InputIterator's` `value_type` is convertible to a type
   in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **BinaryFunction's** `result_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

-  **binary_op** The binary function used to compute
   differences.

**Returns**: The iterator `result + (last - first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/adjacent_difference

-  inclusive_scan

**thrust::adjacent_difference**

::

   template <typename InputIterator,
     typename OutputIterator>
   OutputIterator
   adjacent_difference(InputIterator first,
     InputIterator last,
     OutputIterator result);

`adjacent_difference` calculates the differences of adjacent
elements in the range `[first, last)`. That is, `*first` is
assigned to `*result`, and, for each iterator `i` in the
range `[first + 1, last)`, the difference of `*i` and
`*(i - 1)` is assigned to `*(result + (i - first))`.

This version of `adjacent_difference` uses `operator-` to
calculate differences.

The following code snippet demonstrates how to use
`adjacent_difference` to compute the difference between
adjacent elements of a range.

::

   #include <thrust/adjacent_difference.h>
   #include <thrust/device_vector.h>
   ...
   int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
   thrust::device_vector<int> d_data(h_data, h_data + 8);
   thrust::device_vector<int> d_result(8);

   thrust::adjacent_difference(d_data.begin(), d_data.end(), d_result.begin());

   // d_result is now [1, 1, -1, 1, -1, 1, -1, 1]

**Remark**: Note that `result` is permitted to be the same
iterator as `first`. This is useful for computing differences
“in place”.

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `x` and `y` are objects of
   `InputIterator's` `value_type`, then `x` - `is`
   defined, and `InputIterator's` `value_type` is
   convertible to a type in `OutputIterator's` set of
   `value_types`, and the return type of `x - y` is
   convertible to a type in `OutputIterator's` set of
   `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

**Function Parameters**:

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

**Returns**: The iterator `result + (last - first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/adjacent_difference

-  inclusive_scan

**thrust::adjacent_difference**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename BinaryFunction>
   OutputIterator
   adjacent_difference(InputIterator first,
     InputIterator last,
     OutputIterator result,
     BinaryFunction binary_op);

`adjacent_difference` calculates the differences of adjacent
elements in the range `[first, last)`. That is, `*first` is
assigned to `*result`, and, for each iterator `i` in the
range `[first + 1, last)`, `binary_op(*i, *(i - 1))` is
assigned to `*(result + (i - first))`.

This version of `adjacent_difference` uses the binary
function `binary_op` to calculate differences.

The following code snippet demonstrates how to use
`adjacent_difference` to compute the sum between adjacent
elements of a range.

::

   #include <thrust/adjacent_difference.h>
   #include <thrust/functional.h>
   #include <thrust/device_vector.h>
   ...
   int h_data[8] = {1, 2, 1, 2, 1, 2, 1, 2};
   thrust::device_vector<int> d_data(h_data, h_data + 8);
   thrust::device_vector<int> d_result(8);

   thrust::adjacent_difference(d_data.begin(), d_data.end(), d_result.begin(), thrust::plus<int>());

   // d_result is now [1, 3, 3, 3, 3, 3, 3, 3]

**Remark**: Note that `result` is permitted to be the same
iterator as `first`. This is useful for computing differences
“in place”.

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `BinaryFunction's` `first_argument_type` and
   `second_argument_type`, and
   `InputIterator's` `value_type` is convertible to a type
   in `OutputIterator's` set of `value_types`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **BinaryFunction's** `result_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

**Function Parameters**:

-  **first** The beginning of the input range.

-  **last** The end of the input range.

-  **result** The beginning of the output range.

-  **binary_op** The binary function used to compute
   differences.

**Returns**: The iterator `result + (last - first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/adjacent_difference

-  inclusive_scan

**thrust::generate**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Generator>
   __host__ __device__ void
   generate(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Generator gen);

`generate` assigns the result of invoking `gen`, a function
object that takes no arguments, to each element in the range
`[first,last)`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to fill a
`host_vector` with random numbers, using the standard C
library function `rand` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/generate.h>
   #include <thrust/host_vector.h>
   #include <thrust/execution_policy.h>
   #include <cstdlib>
   ...
   thrust::host_vector<int> v(10);
   srand(13);
   thrust::generate(thrust::host, v.begin(), v.end(), rand);

   // the elements of v are now pseudo-random numbers

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **Generator** is a model of
   `Generator`,
   and `Generator's` `result_type` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element in the range of interest.

-  **last** The last element in the range of interest.

-  **gen** A function argument, taking no parameters, used
   to generate values to assign to elements in the range
   `[first,last)`.

**See**:

-  generate_n

-  https://en.cppreference.com/w/cpp/algorithm/generate

**thrust::generate**

::

   template <typename ForwardIterator,
     typename Generator>
   void
   generate(ForwardIterator first,
     ForwardIterator last,
      Generator gen);

`generate` assigns the result of invoking `gen`, a function
object that takes no arguments, to each element in the range
`[first,last)`.

The following code snippet demonstrates how to fill a
`host_vector` with random numbers, using the standard C
library function `rand`.

::

   #include <thrust/generate.h>
   #include <thrust/host_vector.h>
   #include <thrust/execution_policy.h>
   #include <cstdlib>
   ...
   thrust::host_vector<int> v(10);
   srand(13);
   thrust::generate(v.begin(), v.end(), rand);

   // the elements of v are now pseudo-random numbers

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **Generator** is a model of
   `Generator`,
   and `Generator's` `result_type` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The first element in the range of interest.

-  **last** The last element in the range of interest.

-  **gen** A function argument, taking no parameters, used
   to generate values to assign to elements in the range
   `[first,last)`.

**See**:

-  generate_n

-  https://en.cppreference.com/w/cpp/algorithm/generate

**thrust::generate_n**

::

   template <typename DerivedPolicy,
     typename OutputIterator,
     typename Size,
     typename Generator>
   __host__ __device__ OutputIterator
   generate_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     OutputIterator first,
     Size n,
     Generator gen);

`generate_n` assigns the result of invoking `gen`, a
function object that takes no arguments, to each element in the
range `[first,first + n)`. The return value is `first + n`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to fill a
`host_vector` with random numbers, using the standard C
library function `rand` using the `thrust::host` execution
policy for parallelization:

::

   #include <thrust/generate.h>
   #include <thrust/host_vector.h>
   #include <thrust/execution_policy.h>
   #include <cstdlib>
   ...
   thrust::host_vector<int> v(10);
   srand(13);
   thrust::generate_n(thrust::host, v.begin(), 10, rand);

   // the elements of v are now pseudo-random numbers

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Size** is an integral type (either signed or
   unsigned).

-  **Generator** is a model of
   `Generator`,
   and `Generator's` `result_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element in the range of interest.

-  **n** The size of the range of interest.

-  **gen** A function argument, taking no parameters, used
   to generate values to assign to elements in the range
   `[first,first + n)`.

**See**:

-  generate

-  https://en.cppreference.com/w/cpp/algorithm/generate

**thrust::generate_n**

::

   template <typename OutputIterator,
     typename Size,
     typename Generator>
   OutputIterator
   generate_n(OutputIterator first,
     Size n,
     Generator gen);

`generate_n` assigns the result of invoking `gen`, a
function object that takes no arguments, to each element in the
range `[first,first + n)`. The return value is `first + n`.

The following code snippet demonstrates how to fill a
`host_vector` with random numbers, using the standard C
library function `rand`.

::

   #include <thrust/generate.h>
   #include <thrust/host_vector.h>
   #include <stdlib.h>
   ...
   thrust::host_vector<int> v(10);
   srand(13);
   thrust::generate_n(v.begin(), 10, rand);

   // the elements of v are now pseudo-random numbers

**Template Parameters**:

-  **OutputIterator** is a model of `Output Iterator`.

-  **Size** is an integral type (either signed or
   unsigned).

-  **Generator** is a model of
   `Generator`,
   and `Generator's` `result_type` is convertible to a
   type in `OutputIterator's` set of `value_types`.

**Function Parameters**:

-  **first** The first element in the range of interest.

-  **n** The size of the range of interest.

-  **gen** A function argument, taking no parameters, used
   to generate values to assign to elements in the range
   `[first,first + n)`.

**See**:

-  generate

-  https://en.cppreference.com/w/cpp/algorithm/generate

**thrust::sequence**

::

   template <typename DerivedPolicy,
     typename ForwardIterator>
   __host__ __device__ void
   sequence(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last);

`sequence` fills the range `[first, last)` with a sequence
of numbers.

For each iterator `i` in the range `[first, last)`, this
version of `sequence` performs the assignment
`*i = (i - first)`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `sequence`
to fill a range with a sequence of numbers using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/sequence.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 10;
   int A[N];
   thrust::sequence(thrust::host, A, A + 10);
   // A is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

**Note**: Unlike the similar C++ STL function `std::iota`,
`sequence` offers no guarantee on order of execution.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and if `x` and `y`
   are objects of `ForwardIterator's` `value_type`, then
   `x + y` is defined, and if `T` is
   `ForwardIterator's` `value_type`, then `T(0)` is
   defined.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**See**: https://en.cppreference.com/w/cpp/algorithm/iota

**thrust::sequence**

::

   template <typename ForwardIterator>
   void
   sequence(ForwardIterator first,
     ForwardIterator last);

`sequence` fills the range `[first, last)` with a sequence
of numbers.

For each iterator `i` in the range `[first, last)`, this
version of `sequence` performs the assignment
`*i = (i - first)`.

The following code snippet demonstrates how to use `sequence`
to fill a range with a sequence of numbers.

::

   #include <thrust/sequence.h>
   ...
   const int N = 10;
   int A[N];
   thrust::sequence(A, A + 10);
   // A is now {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

**Note**: Unlike the similar C++ STL function `std::iota`,
`sequence` offers no guarantee on order of execution.

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
and `ForwardIterator` is mutable, and if `x` and `y` are
objects of `ForwardIterator's` `value_type`, then
`x + y` is defined, and if `T` is
`ForwardIterator's` `value_type`, then `T(0)` is
defined.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

**See**: https://en.cppreference.com/w/cpp/algorithm/iota

**thrust::sequence**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   sequence(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     T init);

`sequence` fills the range `[first, last)` with a sequence
of numbers.

For each iterator `i` in the range `[first, last)`, this
version of `sequence` performs the assignment
`*i = init + (i - first)`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `sequence`
to fill a range with a sequence of numbers starting from the
value 1 using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/sequence.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 10;
   int A[N];
   thrust::sequence(thrust::host, A, A + 10, 1);
   // A is now {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

**Note**: Unlike the similar C++ STL function `std::iota`,
`sequence` offers no guarantee on order of execution.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and if `x` and `y`
   are objects of `ForwardIterator's` `value_type`, then
   `x + y` is defined, and if `T` is
   `ForwardIterator's` `value_type`, then `T(0)` is
   defined.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **init** The first value of the sequence of numbers.

**See**: https://en.cppreference.com/w/cpp/algorithm/iota

**thrust::sequence**

::

   template <typename ForwardIterator,
     typename T>
   void
   sequence(ForwardIterator first,
     ForwardIterator last,
     T init);

`sequence` fills the range `[first, last)` with a sequence
of numbers.

For each iterator `i` in the range `[first, last)`, this
version of `sequence` performs the assignment
`*i = init + (i - first)`.

The following code snippet demonstrates how to use `sequence`
to fill a range with a sequence of numbers starting from the
value 1.

::

   #include <thrust/sequence.h>
   ...
   const int N = 10;
   int A[N];
   thrust::sequence(A, A + 10, 1);
   // A is now {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

**Note**: Unlike the similar C++ STL function `std::iota`,
`sequence` offers no guarantee on order of execution.

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and if `x` and `y`
   are objects of `ForwardIterator's` `value_type`, then
   `x + y` is defined, and if `T` is
   `ForwardIterator's` `value_type`, then `T(0)` is
   defined.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **init** The first value of the sequence of numbers.

**See**: https://en.cppreference.com/w/cpp/algorithm/iota

**thrust::sequence**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   sequence(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     T init,
     T step);

`sequence` fills the range `[first, last)` with a sequence
of numbers.

For each iterator `i` in the range `[first, last)`, this
version of `sequence` performs the assignment
`*i = init + step * (i - first)`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `sequence`
to fill a range with a sequence of numbers starting from the
value 1 with a step size of 3 using the `thrust::host`
execution policy for parallelization:

::

   #include <thrust/sequence.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 10;
   int A[N];
   thrust::sequence(thrust::host, A, A + 10, 1, 3);
   // A is now {1, 4, 7, 10, 13, 16, 19, 22, 25, 28}

**Note**: Unlike the similar C++ STL function `std::iota`,
`sequence` offers no guarantee on order of execution.

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and if `x` and `y`
   are objects of `ForwardIterator's` `value_type`, then
   `x + y` is defined, and if `T` is
   `ForwardIterator's` `value_type`, then `T(0)` is
   defined.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **init** The first value of the sequence of numbers

-  **step** The difference between consecutive elements.

**See**: https://en.cppreference.com/w/cpp/algorithm/iota

**thrust::sequence**

::

   template <typename ForwardIterator,
     typename T>
   void
   sequence(ForwardIterator first,
     ForwardIterator last,
     T init,
     T step);

`sequence` fills the range `[first, last)` with a sequence
of numbers.

For each iterator `i` in the range `[first, last)`, this
version of `sequence` performs the assignment
`*i = init + step * (i - first)`.

The following code snippet demonstrates how to use `sequence`
to fill a range with a sequence of numbers starting from the
value 1 with a step size of 3.

::

   #include <thrust/sequence.h>
   ...
   const int N = 10;
   int A[N];
   thrust::sequence(A, A + 10, 1, 3);
   // A is now {1, 4, 7, 10, 13, 16, 19, 22, 25, 28}

**Note**: Unlike the similar C++ STL function `std::iota`,
`sequence` offers no guarantee on order of execution.

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and if `x` and `y`
   are objects of `ForwardIterator's` `value_type`, then
   `x + y` is defined, and if `T` is
   `ForwardIterator's` `value_type`, then `T(0)` is
   defined.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **init** The first value of the sequence of numbers

-  **step** The difference between consecutive elements.

**See**: https://en.cppreference.com/w/cpp/algorithm/iota

**thrust::tabulate**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename UnaryOperation>
   __host__ __device__ void
   tabulate(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     UnaryOperation unary_op);

`tabulate` fills the range `[first, last)` with the value
of a function applied to each element’s index.

For each iterator `i` in the range `[first, last)`,
`tabulate` performs the assignment
`*i = unary_op(i - first)`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `tabulate`
to generate the first `n` non-positive integers using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/tabulate.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...
   const int N = 10;
   int A[N];
   thrust::tabulate(thrust::host, A, A + 10, thrust::negate<int>());
   // A is now {0, -1, -2, -3, -4, -5, -6, -7, -8, -9}

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and if `x` and `y`
   are objects of `ForwardIterator's` `value_type`, then
   `x + y` is defined, and if `T` is
   `ForwardIterator's` `value_type`, then `T(0)` is
   defined.

-  **UnaryOperation** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the range.

-  **last** The end of the range.

-  **unary_op** The unary operation to apply.

**See**:

-  thrust::fill

-  thrust::generate

-  thrust::sequence

**thrust::tabulate**

::

   template <typename ForwardIterator,
     typename UnaryOperation>
   void
   tabulate(ForwardIterator first,
     ForwardIterator last,
     UnaryOperation unary_op);

`tabulate` fills the range `[first, last)` with the value
of a function applied to each element’s index.

For each iterator `i` in the range `[first, last)`,
`tabulate` performs the assignment
`*i = unary_op(i - first)`.

The following code snippet demonstrates how to use `tabulate`
to generate the first `n` non-positive integers:

::

   #include <thrust/tabulate.h>
   #include <thrust/functional.h>
   ...
   const int N = 10;
   int A[N];
   thrust::tabulate(A, A + 10, thrust::negate<int>());
   // A is now {0, -1, -2, -3, -4, -5, -6, -7, -8, -9}

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable, and if `x` and `y`
   are objects of `ForwardIterator's` `value_type`, then
   `x + y` is defined, and if `T` is
   `ForwardIterator's` `value_type`, then `T(0)` is
   defined.

-  **UnaryOperation** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the range.

-  **last** The end of the range.

-  **unary_op** The unary operation to apply.

**See**:

-  thrust::fill

-  thrust::generate

-  thrust::sequence

**thrust::transform**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction>
   __host__ __device__ OutputIterator
   transform(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction op);

This version of `transform` applies a unary function to each
element of an input sequence and stores the result in the
corresponding position in an output sequence. Specifically, for
each iterator `i` in the range [`first`, `last`) the
operation `op(*i)` is performed and the result is assigned to
`*o`, where `o` is the corresponding output iterator in the
range [`result`, `result` + (`last` - `first`) ). The
input and output sequences may coincide, resulting in an
in-place transformation.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform` to negate a range in-place using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   thrust::negate<int> op;

   thrust::transform(thrust::host, data, data + 10, data, op); // in-place transformation

   // data is now {5, 0, -2, 3, -2, -4, 0, 1, -2, -8};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **op** The transformation operation.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` shall not overlap the range
`[result, result + (last - first))` otherwise.

**Returns**: The end of the output sequence.

**See**: https://en.cppreference.com/w/cpp/algorithm/transform

**thrust::transform**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename UnaryFunction>
   OutputIterator
   transform(InputIterator first,
     InputIterator last,
     OutputIterator result,
     UnaryFunction op);

This version of `transform` applies a unary function to each
element of an input sequence and stores the result in the
corresponding position in an output sequence. Specifically, for
each iterator `i` in the range [`first`, `last`) the
operation `op(*i)` is performed and the result is assigned to
`*o`, where `o` is the corresponding output iterator in the
range [`result`, `result` + (`last` - `first`) ). The
input and output sequences may coincide, resulting in an
in-place transformation.

The following code snippet demonstrates how to use
`transform`

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>

   int data[10] = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   thrust::negate<int> op;

   thrust::transform(data, data + 10, data, op); // in-place transformation

   // data is now {5, 0, -2, 3, -2, -4, 0, 1, -2, -8};

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **op** The tranformation operation.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` shall not overlap the range
`[result, result + (last - first))` otherwise.

**Returns**: The end of the output sequence.

**See**: https://en.cppreference.com/w/cpp/algorithm/transform

**thrust::transform**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryFunction>
   __host__ __device__ OutputIterator
   transform(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryFunction op);

This version of `transform` applies a binary function to each
pair of elements from two input sequences and stores the result
in the corresponding position in an output sequence.
Specifically, for each iterator `i` in the range [`first1`,
`last1`) and `j = first + (i - first1)` in the range
[`first2`, `last2`) the operation `op(*i,*j)` is
performed and the result is assigned to `*o`, where `o` is
the corresponding output iterator in the range [`result`,
`result` + (`last` - `first`) ). The input and output
sequences may coincide, resulting in an in-place
transformation.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform` to compute the sum of two ranges using the
`thrust::host` execution policy for parallelization:

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int input1[6] = {-5,  0,  2,  3,  2,  4};
   int input2[6] = { 3,  6, -2,  1,  2,  3};
   int output[6];

   thrust::plus<int> op;

   thrust::transform(thrust::host, input1, input1 + 6, input2, output, op);

   // output is now {-2,  6,  0,  4,  4,  7};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is convertible to
   `BinaryFunction's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `BinaryFunction's` `second_argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **BinaryFunction** is a model of `Binary Function`
   and `BinaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input sequence.

-  **last1** The end of the first input sequence.

-  **first2** The beginning of the second input sequence.

-  **result** The beginning of the output sequence.

-  **op** The tranformation operation.

**Preconditions**:

-  `first1` may equal `result`, but the range
   `[first1, last1)` shall not overlap the range
   `[result, result + (last1 - first1))` otherwise.

-  `first2` may equal `result`, but the range
   `[first2, first2 + (last1 - first1))` shall not overlap
   the range `[result, result + (last1 - first1))` otherwise.

**Returns**: The end of the output sequence.

**See**: https://en.cppreference.com/w/cpp/algorithm/transform

**thrust::transform**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename BinaryFunction>
   OutputIterator
   transform(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     OutputIterator result,
     BinaryFunction op);

This version of `transform` applies a binary function to each
pair of elements from two input sequences and stores the result
in the corresponding position in an output sequence.
Specifically, for each iterator `i` in the range [`first1`,
`last1`) and `j = first + (i - first1)` in the range
[`first2`, `last2`) the operation `op(*i,*j)` is
performed and the result is assigned to `*o`, where `o` is
the corresponding output iterator in the range [`result`,
`result` + (`last` - `first`) ). The input and output
sequences may coincide, resulting in an in-place
transformation.

The following code snippet demonstrates how to use
`transform`

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>

   int input1[6] = {-5,  0,  2,  3,  2,  4};
   int input2[6] = { 3,  6, -2,  1,  2,  3};
   int output[6];

   thrust::plus<int> op;

   thrust::transform(input1, input1 + 6, input2, output, op);

   // output is now {-2,  6,  0,  4,  4,  7};

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is convertible to
   `BinaryFunction's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `BinaryFunction's` `second_argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **BinaryFunction** is a model of `Binary Function`
   and `BinaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first1** The beginning of the first input sequence.

-  **last1** The end of the first input sequence.

-  **first2** The beginning of the second input sequence.

-  **result** The beginning of the output sequence.

-  **op** The tranformation operation.

**Preconditions**:

-  `first1` may equal `result`, but the range
   `[first1, last1)` shall not overlap the range
   `[result, result + (last1 - first1))` otherwise.

-  `first2` may equal `result`, but the range
   `[first2, first2 + (last1 - first1))` shall not overlap
   the range `[result, result + (last1 - first1))` otherwise.

**Returns**: The end of the output sequence.

**See**: https://en.cppreference.com/w/cpp/algorithm/transform

**thrust::transform_if**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   __host__ __device__ ForwardIterator
   transform_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     ForwardIterator result,
     UnaryFunction op,
     Predicate pred);

This version of `transform_if` conditionally applies a unary
function to each element of an input sequence and stores the
result in the corresponding position in an output sequence if
the corresponding position in the input sequence satifies a
predicate. Otherwise, the corresponding position in the output
sequence is not modified.

Specifically, for each iterator `i` in the range
`[first, last)` the predicate `pred(*i)` is evaluated. If
this predicate evaluates to `true`, the result of `op(*i)`
is assigned to `*o`, where `o` is the corresponding output
iterator in the range `[result, result + (last - first) )`.
Otherwise, `op(*i)` is not evaluated and no assignment
occurs. The input and output sequences may coincide, resulting
in an in-place transformation.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform_if` to negate the odd-valued elements of a range
using the `thrust::host` execution policy for
parallelization:

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   struct is_odd
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x % 2;
   }
   };

   thrust::negate<int> op;
   thrust::identity<int> identity;

   // negate odd elements
   thrust::transform_if(thrust::host, data, data + 10, data, op, is_odd()); // in-place transformation

   // data is now {5, 0, 2, 3, 2, 4, 0, 1, 2, 8};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`, and
   `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **op** The tranformation operation.

-  **pred** The predicate operation.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` shall not overlap the range
`[result, result + (last - first))` otherwise.

**Returns**: The end of the output sequence.

**See**: thrust::transform

**thrust::transform_if**

::

   template <typename InputIterator,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   ForwardIterator
   transform_if(InputIterator first,
     InputIterator last,
     ForwardIterator result,
     UnaryFunction op,
     Predicate pred);

This version of `transform_if` conditionally applies a unary
function to each element of an input sequence and stores the
result in the corresponding position in an output sequence if
the corresponding position in the input sequence satifies a
predicate. Otherwise, the corresponding position in the output
sequence is not modified.

Specifically, for each iterator `i` in the range
`[first, last)` the predicate `pred(*i)` is evaluated. If
this predicate evaluates to `true`, the result of `op(*i)`
is assigned to `*o`, where `o` is the corresponding output
iterator in the range `[result, result + (last - first) )`.
Otherwise, `op(*i)` is not evaluated and no assignment
occurs. The input and output sequences may coincide, resulting
in an in-place transformation.

The following code snippet demonstrates how to use
`transform_if:`

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>

   int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};

   struct is_odd
   {
   __host__ __device__
   bool operator()(int x)
   {
   return x % 2;
   }
   };

   thrust::negate<int> op;
   thrust::identity<int> identity;

   // negate odd elements
   thrust::transform_if(data, data + 10, data, op, is_odd()); // in-place transformation

   // data is now {5, 0, 2, 3, 2, 4, 0, 1, 2, 8};

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`, and
   `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **result** The beginning of the output sequence.

-  **op** The tranformation operation.

-  **pred** The predicate operation.

**Preconditions**: `first` may equal `result`, but the
range `[first, last)` shall not overlap the range
`[result, result + (last - first))` otherwise.

**Returns**: The end of the output sequence.

**See**: thrust::transform

**thrust::transform_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   __host__ __device__ ForwardIterator
   transform_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     ForwardIterator result,
     UnaryFunction op,
     Predicate pred);

This version of `transform_if` conditionally applies a unary
function to each element of an input sequence and stores the
result in the corresponding position in an output sequence if
the corresponding position in a stencil sequence satisfies a
predicate. Otherwise, the corresponding position in the output
sequence is not modified.

Specifically, for each iterator `i` in the range
`[first, last)` the predicate `pred(*s)` is evaluated,
where `s` is the corresponding input iterator in the range
`[stencil, stencil + (last - first) )`. If this predicate
evaluates to `true`, the result of `op(*i)` is assigned to
`*o`, where `o` is the corresponding output iterator in the
range `[result, result + (last - first) )`. Otherwise,
`op(*i)` is not evaluated and no assignment occurs. The input
and output sequences may coincide, resulting in an in-place
transformation.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform_if` using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};
   int stencil[10] = { 1, 0, 1,  0, 1, 0, 1,  0, 1, 0};

   thrust::negate<int> op;
   thrust::identity<int> identity;

   thrust::transform_if(thrust::host, data, data + 10, stencil, data, op, identity); // in-place transformation

   // data is now {5, 0, -2, -3, -2,  4, 0, -1, -2,  8};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the output sequence.

-  **op** The tranformation operation.

-  **pred** The predicate operation.

**Preconditions**:

-  `first` may equal `result`, but the range
   `[first, last)` shall not overlap the range
   `[result, result + (last - first))` otherwise.

-  `stencil` may equal `result`, but the range
   `[stencil, stencil + (last - first))` shall not overlap
   the range `[result, result + (last - first))` otherwise.

**Returns**: The end of the output sequence.

**See**: thrust::transform

**thrust::transform_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename ForwardIterator,
     typename UnaryFunction,
     typename Predicate>
   ForwardIterator
   transform_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     ForwardIterator result,
     UnaryFunction op,
     Predicate pred);

This version of `transform_if` conditionally applies a unary
function to each element of an input sequence and stores the
result in the corresponding position in an output sequence if
the corresponding position in a stencil sequence satisfies a
predicate. Otherwise, the corresponding position in the output
sequence is not modified.

Specifically, for each iterator `i` in the range
`[first, last)` the predicate `pred(*s)` is evaluated,
where `s` is the corresponding input iterator in the range
`[stencil, stencil + (last - first) )`. If this predicate
evaluates to `true`, the result of `op(*i)` is assigned to
`*o`, where `o` is the corresponding output iterator in the
range `[result, result + (last - first) )`. Otherwise,
`op(*i)` is not evaluated and no assignment occurs. The input
and output sequences may coincide, resulting in an in-place
transformation.

The following code snippet demonstrates how to use
`transform_if:`

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>

   int data[10]    = {-5, 0, 2, -3, 2, 4, 0, -1, 2, 8};
   int stencil[10] = { 1, 0, 1,  0, 1, 0, 1,  0, 1, 0};

   thrust::negate<int> op;
   thrust::identity<int> identity;

   thrust::transform_if(data, data + 10, stencil, data, op, identity); // in-place transformation

   // data is now {5, 0, -2, -3, -2,  4, 0, -1, -2,  8};

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **UnaryFunction** is a model of `Unary Function`
   and `UnaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first** The beginning of the input sequence.

-  **last** The end of the input sequence.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the output sequence.

-  **op** The tranformation operation.

-  **pred** The predicate operation.

**Preconditions**:

-  `first` may equal `result`, but the range
   `[first, last)` shall not overlap the range
   `[result, result + (last - first))` otherwise.

-  `stencil` may equal `result`, but the range
   `[stencil, stencil + (last - first))` shall not overlap
   the range `[result, result + (last - first))` otherwise.

**Returns**: The end of the output sequence.

**See**: thrust::transform

**thrust::transform_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename ForwardIterator,
     typename BinaryFunction,
     typename Predicate>
   __host__ __device__ ForwardIterator
   transform_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator3 stencil,
     ForwardIterator result,
     BinaryFunction binary_op,
     Predicate pred);

This version of `transform_if` conditionally applies a binary
function to each pair of elements from two input sequences and
stores the result in the corresponding position in an output
sequence if the corresponding position in a stencil sequence
satifies a predicate. Otherwise, the corresponding position in
the output sequence is not modified.

Specifically, for each iterator `i` in the range
`[first1, last1)` and `j = first2 + (i - first1)` in the
range `[first2, first2 + (last1 - first1) )`, the predicate
`pred(*s)` is evaluated, where `s` is the corresponding
input iterator in the range
`[stencil, stencil + (last1 - first1) )`. If this predicate
evaluates to `true`, the result of `binary_op(*i,*j)` is
assigned to `*o`, where `o` is the corresponding output
iterator in the range `[result, result + (last1 - first1) )`.
Otherwise, `binary_op(*i,*j)` is not evaluated and no
assignment occurs. The input and output sequences may coincide,
resulting in an in-place transformation.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`transform_if` using the `thrust::host` execution policy
for parallelization:

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>
   #include <thrust/execution_policy.h>
   ...

   int input1[6]  = {-5,  0,  2,  3,  2,  4};
   int input2[6]  = { 3,  6, -2,  1,  2,  3};
   int stencil[8] = { 1,  0,  1,  0,  1,  0};
   int output[6];

   thrust::plus<int> op;
   thrust::identity<int> identity;

   thrust::transform_if(thrust::host, input1, input1 + 6, input2, stencil, output, op, identity);

   // output is now {-2,  0,  0,  3,  4,  4};

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is convertible to
   `BinaryFunction's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `BinaryFunction's` `second_argument_type`.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **BinaryFunction** is a model of `Binary Function`
   and `BinaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first1** The beginning of the first input sequence.

-  **last1** The end of the first input sequence.

-  **first2** The beginning of the second input sequence.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the output sequence.

-  **binary_op** The transformation operation.

-  **pred** The predicate operation.

**Preconditions**:

-  `first1` may equal `result`, but the range
   `[first1, last1)` shall not overlap the range
   `[result, result + (last1 - first1))` otherwise.

-  `first2` may equal `result`, but the range
   `[first2, first2 + (last1 - first1))` shall not overlap
   the range `[result, result + (last1 - first1))` otherwise.

-  `stencil` may equal `result`, but the range
   `[stencil, stencil + (last1 - first1))` shall not overlap
   the range `[result, result + (last1 - first1))` otherwise.

**Returns**: The end of the output sequence.

**See**: thrust::transform

**thrust::transform_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename InputIterator3,
     typename ForwardIterator,
     typename BinaryFunction,
     typename Predicate>
   ForwardIterator
   transform_if(InputIterator1 first1,
     InputIterator1 last1,
     InputIterator2 first2,
     InputIterator3 stencil,
     ForwardIterator result,
     BinaryFunction binary_op,
     Predicate pred);

This version of `transform_if` conditionally applies a binary
function to each pair of elements from two input sequences and
stores the result in the corresponding position in an output
sequence if the corresponding position in a stencil sequence
satifies a predicate. Otherwise, the corresponding position in
the output sequence is not modified.

Specifically, for each iterator `i` in the range
`[first1, last1)` and `j = first2 + (i - first1)` in the
range `[first2, first2 + (last1 - first1) )`, the predicate
`pred(*s)` is evaluated, where `s` is the corresponding
input iterator in the range
`[stencil, stencil + (last1 - first1) )`. If this predicate
evaluates to `true`, the result of `binary_op(*i,*j)` is
assigned to `*o`, where `o` is the corresponding output
iterator in the range `[result, result + (last1 - first1) )`.
Otherwise, `binary_op(*i,*j)` is not evaluated and no
assignment occurs. The input and output sequences may coincide,
resulting in an in-place transformation.

The following code snippet demonstrates how to use
`transform_if:`

::

   #include <thrust/transform.h>
   #include <thrust/functional.h>

   int input1[6]  = {-5,  0,  2,  3,  2,  4};
   int input2[6]  = { 3,  6, -2,  1,  2,  3};
   int stencil[8] = { 1,  0,  1,  0,  1,  0};
   int output[6];

   thrust::plus<int> op;
   thrust::identity<int> identity;

   thrust::transform_if(input1, input1 + 6, input2, stencil, output, op, identity);

   // output is now {-2,  0,  0,  3,  4,  4};

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`
   and `InputIterator1's` `value_type` is convertible to
   `BinaryFunction's` `first_argument_type`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `BinaryFunction's` `second_argument_type`.

-  **ForwardIterator** is a model of `Forward Iterator`.

-  **BinaryFunction** is a model of `Binary Function`
   and `BinaryFunction's` `result_type` is convertible to
   `OutputIterator's` `value_type`.

-  **Predicate** is a model of
   `Predicate`.

**Function Parameters**:

-  **first1** The beginning of the first input sequence.

-  **last1** The end of the first input sequence.

-  **first2** The beginning of the second input sequence.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the output sequence.

-  **binary_op** The transformation operation.

-  **pred** The predicate operation.

**Preconditions**:

-  `first1` may equal `result`, but the range
   `[first1, last1)` shall not overlap the range
   `[result, result + (last1 - first1))` otherwise.

-  `first2` may equal `result`, but the range
   `[first2, first2 + (last1 - first1))` shall not overlap
   the range `[result, result + (last1 - first1))` otherwise.

-  `stencil` may equal `result`, but the range
   `[stencil, stencil + (last1 - first1))` shall not overlap
   the range `[result, result + (last1 - first1))` otherwise.

**Returns**: The end of the output sequence.

**See**: thrust::transform

Filling
*******
**Functions**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   thrust::fill(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value);

   template <typename ForwardIterator,
     typename T>
   __host__ __device__ void
   thrust::fill(ForwardIterator first,
     ForwardIterator last,
     const T & value);

   template <typename DerivedPolicy,
     typename OutputIterator,
     typename Size,   typename T>
   __host__ __device__ OutputIterator
   thrust::fill_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     OutputIterator first,
     Size n,
     const T & value);

   template <typename OutputIterator,
     typename Size,
     typename T>
   __host__ __device__ OutputIterator
   thrust::fill_n(OutputIterator first,
     Size n,
     const T & value);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   thrust::uninitialized_fill(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & x);

   template <typename ForwardIterator,
     typename T>
   void
   thrust::uninitialized_fill(ForwardIterator first,
     ForwardIterator last,
     const T & x);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Size,
     typename T>
   __host__ __device__ ForwardIterator
   thrust::uninitialized_fill_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     Size n,
     const T & x);

   template <typename ForwardIterator,
     typename Size,
     typename T>
   ForwardIterator
   thrust::uninitialized_fill_n(ForwardIterator first,
     Size n,
     const T & x);

**thrust::fill**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   fill(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & value);

`fill` assigns the value `value` to every element in the
range `[first, last)`. That is, for every iterator `i` in
`[first, last)`, it performs the assignment `*i = value`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `fill` to
set a
`thrust::device_vector`\ ’s
elements to a given value using the `thrust::device`
execution policy for parallelization:

::

   #include <thrust/fill.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> v(4);
   thrust::fill(thrust::device, v.begin(), v.end(), 137);

   // v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **T** is a model of
   `Assignable`,
   and `T's` `value_type` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **value** The value to be copied.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/fill

-  `fill_n`

-  `uninitialized_fill`

**thrust::fill**

::

   template <typename ForwardIterator,
     typename T>
   __host__ __device__ void
   fill(ForwardIterator first,
     ForwardIterator last,
     const T & value);

`fill` assigns the value `value` to every element in the
range `[first, last)`. That is, for every iterator `i` in
`[first, last)`, it performs the assignment `*i = value`.

The following code snippet demonstrates how to use `fill` to
set a
`thrust::device_vector`\ ’s
elements to a given value.

::

   #include <thrust/fill.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> v(4);
   thrust::fill(v.begin(), v.end(), 137);

   // v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **T** is a model of
   `Assignable`,
   and `T's` `value_type` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **value** The value to be copied.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/fill

-  `fill_n`

-  `uninitialized_fill`

**thrust::fill_n**

::

   template <typename DerivedPolicy,
     typename OutputIterator,
     typename Size,
     typename T>
   __host__ __device__ OutputIterator
   fill_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     OutputIterator first,
     Size n,
     const T & value);

`fill_n` assigns the value `value` to every element in the
range `[first, first+n)`. That is, for every iterator `i`
in `[first, first+n)`, it performs the assignment
`*i = value`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `fill` to
set a
`thrust::device_vector`\ ’s
elements to a given value using the `thrust::device`
execution policy for parallelization:

::

   #include <thrust/fill.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> v(4);
   thrust::fill_n(thrust::device, v.begin(), v.size(), 137);

   // v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **OutputIterator** is a model of `Output Iterator`.

-  **T** is a model of
   `Assignable`,
   and `T's` `value_type` is convertible to a type in
   `OutputIterator's` set of `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **n** The size of the sequence.

-  **value** The value to be copied.

**Returns**: `first + n`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/fill_n

-  `fill`

-  `uninitialized_fill_n`

**thrust::fill_n**

::

   template <typename OutputIterator,
     typename Size,
     typename T>
   __host__ __device__ OutputIterator
   fill_n(OutputIterator first,
     Size n,
     const T & value);

`fill_n` assigns the value `value` to every element in the
range `[first, first+n)`. That is, for every iterator `i`
in `[first, first+n)`, it performs the assignment
`*i = value`.

The following code snippet demonstrates how to use `fill` to
set a
`thrust::device_vector`\ ’s
elements to a given value.

::

   #include <thrust/fill.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> v(4);
   thrust::fill_n(v.begin(), v.size(), 137);

   // v[0] == 137, v[1] == 137, v[2] == 137, v[3] == 137

**Template Parameters**:

-  **OutputIterator** is a model of `Output Iterator`.

-  **T** is a model of
   `Assignable`,
   and `T's` `value_type` is convertible to a type in
   `OutputIterator's` set of `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **n** The size of the sequence.

-  **value** The value to be copied.

**Returns**: `first + n`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/fill_n

-  `fill`

-  `uninitialized_fill_n`

**thrust::uninitialized_fill**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   uninitialized_fill(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & x);

In `thrust`, the function `thrust::device_new` allocates
memory for an object and then creates an object at that
location by calling a constructor. Occasionally, however, it is
useful to separate those two operations. If each iterator in
the range `[first, last)` points to uninitialized memory,
then `uninitialized_fill` creates copies of `x` in that
range. That is, for each iterator `i` in the range
`[first, last)`, `uninitialized_fill` creates a copy of
`x` in the location pointed to `i` by calling
`ForwardIterator's` `value_type's` copy constructor.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`uninitialized_fill` to initialize a range of uninitialized
memory using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/uninitialized_fill.h>
   #include <thrust/device_malloc.h>
   #include <thrust/execution_policy.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_fill(thrust::device, array, array + N, val);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` has a constructor that
   takes a single argument of type `T`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element of the range of interest.

-  **last** The last element of the range of interest.

-  **x** The value to use as the exemplar of the copy
   constructor.

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_fill

-  `uninitialized_fill_n`

-  `fill`

-  `uninitialized_copy`

-  `device_new`

-  `device_malloc`

**thrust::uninitialized_fill**

::

   template <typename ForwardIterator,
     typename T>
   void
   uninitialized_fill(ForwardIterator first,
     ForwardIterator last,
     const T & x);

In `thrust`, the function `thrust::device_new` allocates
memory for an object and then creates an object at that
location by calling a constructor. Occasionally, however, it is
useful to separate those two operations. If each iterator in
the range `[first, last)` points to uninitialized memory,
then `uninitialized_fill` creates copies of `x` in that
range. That is, for each iterator `i` in the range
`[first, last)`, `uninitialized_fill` creates a copy of
`x` in the location pointed to `i` by calling
`ForwardIterator's` `value_type's` copy constructor.

The following code snippet demonstrates how to use
`uninitialized_fill` to initialize a range of uninitialized
memory.

::

   #include <thrust/uninitialized_fill.h>
   #include <thrust/device_malloc.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_fill(array, array + N, val);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
`ForwardIterator` is mutable, and
`ForwardIterator's` `value_type` has a constructor that
takes a single argument of type `T`.

**Function Parameters**:

-  **first** The first element of the range of interest.

-  **last** The last element of the range of interest.

-  **x** The value to use as the exemplar of the copy
   constructor.

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_fill

-  `uninitialized_fill_n`

-  `fill`

-  `uninitialized_copy`

-  `device_new`

-  `device_malloc`

**thrust::uninitialized_fill_n**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Size,
     typename T>
   __host__ __device__ ForwardIterator
   uninitialized_fill_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     Size n,
     const T & x);

In `thrust`, the function `thrust::device_new` allocates
memory for an object and then creates an object at that
location by calling a constructor. Occasionally, however, it is
useful to separate those two operations. If each iterator in
the range `[first, first+n)` points to uninitialized memory,
then `uninitialized_fill` creates copies of `x` in that
range. That is, for each iterator `i` in the range
`[first, first+n)`, `uninitialized_fill` creates a copy of
`x` in the location pointed to `i` by calling
`ForwardIterator's` `value_type's` copy constructor.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`uninitialized_fill` to initialize a range of uninitialized
memory using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/uninitialized_fill.h>
   #include <thrust/device_malloc.h>
   #include <thrust/execution_policy.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_fill_n(thrust::device, array, N, val);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` has a constructor that
   takes a single argument of type `T`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The first element of the range of interest.

-  **n** The size of the range of interest.

-  **x** The value to use as the exemplar of the copy
   constructor.

**Returns**: `first+n`

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_fill

-  `uninitialized_fill`

-  `fill`

-  `uninitialized_copy_n`

-  `device_new`

-  `device_malloc`

**thrust::uninitialized_fill_n**

::

   template <typename ForwardIterator,
     typename Size,
     typename T>
   ForwardIterator
   uninitialized_fill_n(ForwardIterator first,
     Size n,
     const T & x);

In `thrust`, the function `thrust::device_new` allocates
memory for an object and then creates an object at that
location by calling a constructor. Occasionally, however, it is
useful to separate those two operations. If each iterator in
the range `[first, first+n)` points to uninitialized memory,
then `uninitialized_fill` creates copies of `x` in that
range. That is, for each iterator `i` in the range
`[first, first+n)`, `uninitialized_fill` creates a copy of
`x` in the location pointed to `i` by calling
`ForwardIterator's` `value_type's` copy constructor.

The following code snippet demonstrates how to use
`uninitialized_fill` to initialize a range of uninitialized
memory.

::

   #include <thrust/uninitialized_fill.h>
   #include <thrust/device_malloc.h>

   struct Int
   {
   __host__ __device__
   Int(int x) : val(x) {}
   int val;
   };
   ...
   const int N = 137;

   Int val(46);
   thrust::device_ptr<Int> array = thrust::device_malloc<Int>(N);
   thrust::uninitialized_fill_n(array, N, val);

   // Int x = array[i];
   // x.val == 46 for all 0 <= i < N

**Template Parameters**: **ForwardIterator**: is a model of
`Forward Iterator`,
`ForwardIterator` is mutable, and
`ForwardIterator's` `value_type` has a constructor that
takes a single argument of type `T`.

**Function Parameters**:

-  **first** The first element of the range of interest.

-  **n** The size of the range of interest.

-  **x** The value to use as the exemplar of the copy
   constructor.

**Returns**: `first+n`

**See**:

-  https://en.cppreference.com/w/cpp/memory/uninitialized_fill

-  `uninitialized_fill`

-  `fill`

-  `uninitialized_copy_n`

-  `device_new`

-  `device_malloc`

Modifying
*********

**Functions**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename UnaryFunction>
   __host__ __device__ InputIterator
   thrust::for_each(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     UnaryFunction f);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Size,
     typename UnaryFunction>
   __host__ __device__ InputIterator
   thrust::for_each_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     Size n,
     UnaryFunction f);

   template <typename InputIterator,
     typename UnaryFunction>
   InputIterator
   thrust::for_each(InputIterator first,
     InputIterator last,
     UnaryFunction f);

   template <typename InputIterator,
     typename Size,
     typename UnaryFunction>
   InputIterator
   thrust::for_each_n(InputIterator first,
     Size n,
     UnaryFunction f);

**thrust::for_each**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename UnaryFunction>
   __host__ __device__ InputIterator
   for_each(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     UnaryFunction f);

`for_each` applies the function object `f` to each element
in the range `[first, last)`; `f's` return value, if any,
is ignored. Unlike the C++ Standard Template Library function
`std::for_each`, this version offers no guarantee on order of
execution. For this reason, this version of `for_each` does
not return a copy of the function object.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `for_each`
to print the elements of a `thrust::device_vector` using the
`thrust::device` parallelization policy:

::

   #include <thrust/for_each.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   #include <cstdio>
   ...

   struct printf_functor
   {
   __host__ __device__
   void operator()(int x)
   {
      // note that using printf in a __device__ function requires
      // code compiled for a GPU with compute capability 2.0 or
      // higher (nvcc --arch=sm_20)
      printf("%d\n", x);
   }
   };
   ...
   thrust::device_vector<int> d_vec(3);
   d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

   thrust::for_each(thrust::device, d_vec.begin(), d_vec.end(), printf_functor());

   // 0 1 2 is printed to standard output in some unspecified order

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **UnaryFunction** is a model of `Unary Function`,
   and `UnaryFunction` does not apply any non-constant
   operation through its argument.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **f** The function object to apply to the range
   `[first, last)`.

**Returns**: last

**See**:

-  for_each_n

-  https://en.cppreference.com/w/cpp/algorithm/for_each

**thrust::for_each_n**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename Size,
     typename UnaryFunction>
   __host__ __device__ InputIterator
   for_each_n(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     Size n,
     UnaryFunction f);

`for_each_n` applies the function object `f` to each
element in the range `[first, first + n)`; `f's` return
value, if any, is ignored. Unlike the C++ Standard Template
Library function `std::for_each`, this version offers no
guarantee on order of execution.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`for_each_n` to print the elements of a `device_vector`
using the `thrust::device` parallelization policy.

::

   #include <thrust/for_each.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   #include <cstdio>

   struct printf_functor
   {
   __host__ __device__
   void operator()(int x)
   {
      // note that using printf in a __device__ function requires
      // code compiled for a GPU with compute capability 2.0 or
      // higher (nvcc --arch=sm_20)
      printf("%d\n", x);
   }
   };
   ...
   thrust::device_vector<int> d_vec(3);
   d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

   thrust::for_each_n(thrust::device, d_vec.begin(), d_vec.size(), printf_functor());

   // 0 1 2 is printed to standard output in some unspecified order

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **Size** is an integral type.

-  **UnaryFunction** is a model of `Unary Function`,
   and `UnaryFunction` does not apply any non-constant
   operation through its argument.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence.

-  **n** The size of the input sequence.

-  **f** The function object to apply to the range
   `[first, first + n)`.

**Returns**: `first + n`

**See**:

-  for_each

-  https://en.cppreference.com/w/cpp/algorithm/for_each

**thrust::for_each**

::

   template <typename InputIterator,
     typename UnaryFunction>
   InputIterator
   for_each(InputIterator first,
     InputIterator last,
     UnaryFunction f);

`for_each` applies the function object `f` to each element
in the range `[first, last)`; `f's` return value, if any,
is ignored. Unlike the C++ Standard Template Library function
`std::for_each`, this version offers no guarantee on order of
execution. For this reason, this version of `for_each` does
not return a copy of the function object.

The following code snippet demonstrates how to use `for_each`
to print the elements of a `device_vector`.

::

   #include <thrust/for_each.h>
   #include <thrust/device_vector.h>
   #include <stdio.h>

   struct printf_functor
   {
   __host__ __device__
   void operator()(int x)
   {
      // note that using printf in a __device__ function requires
      // code compiled for a GPU with compute capability 2.0 or
      // higher (nvcc --arch=sm_20)
      printf("%d\n", x);
   }
   };
   ...
   thrust::device_vector<int> d_vec(3);
   d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

   thrust::for_each(d_vec.begin(), d_vec.end(), printf_functor());

   // 0 1 2 is printed to standard output in some unspecified order

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **UnaryFunction** is a model of `Unary Function`,
   and `UnaryFunction` does not apply any non-constant
   operation through its argument.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **last** The end of the sequence.

-  **f** The function object to apply to the range
   `[first, last)`.

**Returns**: last

**See**:

-  for_each_n

-  https://en.cppreference.com/w/cpp/algorithm/for_each

**thrust::for_each_n**

::

   template <typename InputIterator,
     typename Size,
     typename UnaryFunction>
   InputIterator
   for_each_n(InputIterator first,
     Size n,
     UnaryFunction f);

`for_each_n` applies the function object `f` to each
element in the range `[first, first + n)`; `f's` return
value, if any, is ignored. Unlike the C++ Standard Template
Library function `std::for_each`, this version offers no
guarantee on order of execution.

The following code snippet demonstrates how to use
`for_each_n` to print the elements of a `device_vector`.

::

   #include <thrust/for_each.h>
   #include <thrust/device_vector.h>
   #include <stdio.h>

   struct printf_functor
   {
   __host__ __device__
   void operator()(int x)
   {
      // note that using printf in a __device__ function requires
      // code compiled for a GPU with compute capability 2.0 or
      // higher (nvcc --arch=sm_20)
      printf("%d\n", x);
   }
   };
   ...
   thrust::device_vector<int> d_vec(3);
   d_vec[0] = 0; d_vec[1] = 1; d_vec[2] = 2;

   thrust::for_each_n(d_vec.begin(), d_vec.size(), printf_functor());

   // 0 1 2 is printed to standard output in some unspecified order

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `UnaryFunction's` `argument_type`.

-  **Size** is an integral type.

-  **UnaryFunction** is a model of `Unary Function`,
   and `UnaryFunction` does not apply any non-constant
   operation through its argument.

**Function Parameters**:

-  **first** The beginning of the sequence.

-  **n** The size of the input sequence.

-  **f** The function object to apply to the range
   `[first, first + n)`.

**Returns**: `first + n`

**See**:

-  for_each

-  https://en.cppreference.com/w/cpp/algorithm/for_each

Replacing
*********

**Functions**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   thrust::replace(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & old_value,
     const T & new_value);

   template <typename ForwardIterator,
     typename T>
   void
   thrust::replace(ForwardIterator first,
     ForwardIterator last,
     const T & old_value,
     const T & new_value);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate,
     typename T>
   __host__ __device__ void
   thrust::replace_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Predicate pred,
     const T & new_value);

   template <typename ForwardIterator,
     typename Predicate,
     typename T>
   void
   thrust::replace_if(ForwardIterator first,
     ForwardIterator last,
     Predicate pred,
     const T & new_value);

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename Predicate,
     typename T>
   __host__ __device__ void
   thrust::replace_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred,
     const T & new_value);

   template <typename ForwardIterator,
     typename InputIterator,
     typename Predicate,
     typename T>
   void
   thrust::replace_if(ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred,
     const T & new_value);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename T>
   __host__ __device__ OutputIterator
   thrust::replace_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     const T & old_value,
     const T & new_value);

   template <typename InputIterator,
     typename OutputIterator,
     typename T>
   OutputIterator
   thrust::replace_copy(InputIterator first,
     InputIterator last,
     OutputIterator result,
     const T & old_value,
     const T & new_value);

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename Predicate,
     typename T>
   __host__ __device__ OutputIterator
   thrust::replace_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

   template <typename InputIterator,
     typename OutputIterator,
     typename Predicate,
     typename T>
   OutputIterator
   thrust::replace_copy_if(InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate,
     typename T>
   __host__ __device__ OutputIterator
   thrust::replace_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate,
     typename T>
   OutputIterator
   thrust::replace_copy_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

**thrust::replace**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename T>
   __host__ __device__ void
   replace(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     const T & old_value,
     const T & new_value);

`replace` replaces every element in the range [first, last)
equal to `old_value` with `new_value`. That is: for every
iterator `i`, if `*i == old_value` then it performs the
`assignment *i = new_value`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use `replace`
to replace a value of interest in a `device_vector` with
another using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>

   ...

   thrust::device_vector<int> A(4);
   A[0] = 1;
   A[1] = 2;
   A[2] = 3;
   A[3] = 1;

   thrust::replace(thrust::device, A.begin(), A.end(), 1, 99);

   // A contains [99, 2, 3, 99]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **T** is a model of
   `Assignable`,
   `T` is a model of
   `EqualityComparable`,
   objects of `T` may be compared for equality with objects
   of `ForwardIterator's` `value_type`, and `T` is
   convertible to `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence of interest.

-  **last** The end of the sequence of interest.

-  **old_value** The value to replace.

-  **new_value** The new value to replace `old_value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace

-  `replace_if`

-  `replace_copy`

-  `replace_copy_if`

**thrust::replace**

::

   template <typename ForwardIterator,
     typename T>
   void
   replace(ForwardIterator first,
     ForwardIterator last,
     const T & old_value,
     const T & new_value);

`replace` replaces every element in the range [first, last)
equal to `old_value` with `new_value`. That is: for every
iterator `i`, if `*i == old_value` then it performs the
`assignment *i = new_value`.

The following code snippet demonstrates how to use `replace`
to replace a value of interest in a `device_vector` with
another.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>

   ...

   thrust::device_vector<int> A(4);
   A[0] = 1;
   A[1] = 2;
   A[2] = 3;
   A[3] = 1;

   thrust::replace(A.begin(), A.end(), 1, 99);

   // A contains [99, 2, 3, 99]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **T** is a model of
   `Assignable`,
   `T` is a model of
   `EqualityComparable`,
   objects of `T` may be compared for equality with objects
   of `ForwardIterator's` `value_type`, and `T` is
   convertible to `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence of interest.

-  **last** The end of the sequence of interest.

-  **old_value** The value to replace.

-  **new_value** The new value to replace `old_value`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace

-  `replace_if`

-  `replace_copy`

-  `replace_copy_if`

**thrust::replace_if**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename Predicate,
     typename T>
   __host__ __device__ void
   replace_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     Predicate pred,
     const T & new_value);

`replace_if` replaces every element in the range
`[first, last)` for which `pred` returns `true` with
`new_value`. That is: for every iterator `i`, if
`pred(*i)` is `true` then it performs the assignment
`*i = new_value`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`replace_if` to replace a `device_vector's` negative
elements with `0` using the `thrust::device` execution
policy for parallelization:

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  1;
   A[1] = -3;
   A[2] =  2;
   A[3] = -1;

   is_less_than_zero pred;

   thrust::replace_if(thrust::device, A.begin(), A.end(), pred, 0);

   // A contains [1, 0, 2, 0]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence of interest.

-  **last** The end of the sequence of interest.

-  **pred** The predicate to test on every value of the
   range `[first,last)`.

-  **new_value** The new value to replace elements which
   `pred(*i)` evaluates to `true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace

-  `replace`

-  `replace_copy`

-  `replace_copy_if`

**thrust::replace_if**

::

   template <typename ForwardIterator,
     typename Predicate,
     typename T>
   void
   replace_if(ForwardIterator first,
     ForwardIterator last,
     Predicate pred,
     const T & new_value);

`replace_if` replaces every element in the range
`[first, last)` for which `pred` returns `true` with
`new_value`. That is: for every iterator `i`, if
`pred(*i)` is `true` then it performs the assignment
`*i = new_value`.

The following code snippet demonstrates how to use
`replace_if` to replace a `device_vector's` negative
elements with `0`.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   ...
   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  1;
   A[1] = -3;
   A[2] =  2;
   A[3] = -1;

   is_less_than_zero pred;

   thrust::replace_if(A.begin(), A.end(), pred, 0);

   // A contains [1, 0, 2, 0]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   `ForwardIterator` is mutable, and
   `ForwardIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence of interest.

-  **last** The end of the sequence of interest.

-  **pred** The predicate to test on every value of the
   range `[first,last)`.

-  **new_value** The new value to replace elements which
   `pred(*i)` evaluates to `true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace

-  `replace`

-  `replace_copy`

-  `replace_copy_if`

**thrust::replace_if**

::

   template <typename DerivedPolicy,
     typename ForwardIterator,
     typename InputIterator,
     typename Predicate,
     typename T>
   __host__ __device__ void
   replace_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred,
     const T & new_value);

`replace_if` replaces every element in the range
`[first, last)` for which `pred(*s)` returns `true` with
`new_value`. That is: for every iterator `i` in the range
`[first, last)`, and `s` in the range
`[stencil, stencil + (last - first))`, if `pred(*s)` is
`true` then it performs the assignment `*i = new_value`.

The algorithm’s execution is parallelized as determined by
`exec`.

The following code snippet demonstrates how to use
`replace_if` to replace a `device_vector's` element with
`0` when its corresponding stencil element is less than zero
using the `thrust::device` execution policy for
parallelization:

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>

   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  10;
   A[1] =  20;
   A[2] =  30;
   A[3] =  40;

   thrust::device_vector<int> S(4);
   S[0] = -1;
   S[1] =  0;
   S[2] = -1;
   S[3] =  0;

   is_less_than_zero pred;
   thrust::replace_if(thrust::device, A.begin(), A.end(), S.begin(), pred, 0);

   // A contains [0, 20, 0, 40]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence of interest.

-  **last** The end of the sequence of interest.

-  **stencil** The beginning of the stencil sequence.

-  **pred** The predicate to test on every value of the
   range `[first,last)`.

-  **new_value** The new value to replace elements which
   `pred(*i)` evaluates to `true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace

-  `replace`

-  `replace_copy`

-  `replace_copy_if`

**thrust::replace_if**

::

   template <typename ForwardIterator,
     typename InputIterator,
     typename Predicate,
     typename T>
   void
   replace_if(ForwardIterator first,
     ForwardIterator last,
     InputIterator stencil,
     Predicate pred,
     const T & new_value);

`replace_if` replaces every element in the range
`[first, last)` for which `pred(*s)` returns `true` with
`new_value`. That is: for every iterator `i` in the range
`[first, last)`, and `s` in the range
`[stencil, stencil + (last - first))`, if `pred(*s)` is
`true` then it performs the assignment `*i = new_value`.

The following code snippet demonstrates how to use
`replace_if` to replace a `device_vector's` element with
`0` when its corresponding stencil element is less than zero.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>

   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  10;
   A[1] =  20;
   A[2] =  30;
   A[3] =  40;

   thrust::device_vector<int> S(4);
   S[0] = -1;
   S[1] =  0;
   S[2] = -1;
   S[3] =  0;

   is_less_than_zero pred;
   thrust::replace_if(A.begin(), A.end(), S.begin(), pred, 0);

   // A contains [0, 20, 0, 40]

**Template Parameters**:

-  **ForwardIterator** is a model of `Forward Iterator`,
   and `ForwardIterator` is mutable.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `ForwardIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence of interest.

-  **last** The end of the sequence of interest.

-  **stencil** The beginning of the stencil sequence.

-  **pred** The predicate to test on every value of the
   range `[first,last)`.

-  **new_value** The new value to replace elements which
   `pred(*i)` evaluates to `true`.

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace

-  `replace`

-  `replace_copy`

-  `replace_copy_if`

**thrust::replace_copy**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename T>
   __host__ __device__ OutputIterator
   replace_copy(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     const T & old_value,
     const T & new_value);

`replace_copy` copies elements from the range
`[first, last)` to the range
`[result, result + (last-first))`, except that any element
equal to `old_value` is not copied; `new_value` is copied
instead.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `replace_copy` performs the
assignment `*(result+n) = new_value` if
`*(first+n) == old_value`, and `*(result+n) = *(first+n)`
otherwise.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   ...
   thrust::device_vector<int> A(4);
   A[0] = 1;
   A[1] = 2;
   A[2] = 3;
   A[3] = 1;

   thrust::device_vector<int> B(4);

   thrust::replace_copy(thrust::device, A.begin(), A.end(), B.begin(), 1, 99);

   // B contains [99, 2, 3, 99]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **T** is a model of
   `Assignable`,
   `T` is a model of `Equality Comparable`,
   `T` may be compared for equality with
   `InputIterator's` `value_type`, and `T` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to copy from.

-  **last** The end of the sequence to copy from.

-  **result** The beginning of the sequence to copy to.

-  **old_value** The value to replace.

-  **new_value** The replacement value for which
   `*i == old_value` evaluates to `true`.

**Preconditions**: `first` may equal `result`, but the
ranges `[first, last)` and
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: `result + (last-first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace_copy

-  `copy`

-  `replace`

-  `replace_if`

-  `replace_copy_if`

**thrust::replace_copy**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename T>
   OutputIterator
   replace_copy(InputIterator first,
     InputIterator last,
     OutputIterator result,
     const T & old_value,
     const T & new_value);

`replace_copy` copies elements from the range
`[first, last)` to the range
`[result, result + (last-first))`, except that any element
equal to `old_value` is not copied; `new_value` is copied
instead.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `replace_copy` performs the
assignment `*(result+n) = new_value` if
`*(first+n) == old_value`, and `*(result+n) = *(first+n)`
otherwise.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> A(4);
   A[0] = 1;
   A[1] = 2;
   A[2] = 3;
   A[3] = 1;

   thrust::device_vector<int> B(4);

   thrust::replace_copy(A.begin(), A.end(), B.begin(), 1, 99);

   // B contains [99, 2, 3, 99]

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **T** is a model of
   `Assignable`,
   `T` is a model of `Equality Comparable`,
   `T` may be compared for equality with
   `InputIterator's` `value_type`, and `T` is
   convertible to `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence to copy from.

-  **last** The end of the sequence to copy from.

-  **result** The beginning of the sequence to copy to.

-  **old_value** The value to replace.

-  **new_value** The replacement value for which
   `*i == old_value` evaluates to `true`.

**Preconditions**: `first` may equal `result`, but the
ranges `[first, last)` and
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: `result + (last-first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace_copy

-  `copy`

-  `replace`

-  `replace_if`

-  `replace_copy_if`

**thrust::replace_copy_if**

::

   template <typename DerivedPolicy,
     typename InputIterator,
     typename OutputIterator,
     typename Predicate,
     typename T>
   __host__ __device__ OutputIterator
   replace_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

`replace_copy_if` copies elements from the range
`[first, last)` to the range
`[result, result + (last-first))`, except that any element
for which `pred` is `true` is not copied; `new_value` is
copied instead.

More precisely, for every integer `n` such that 0 <= n <
last-first, `replace_copy_if` performs the assignment
`*(result+n) = new_value` if `pred(*(first+n))`, and
`*(result+n) = *(first+n)` otherwise.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>

   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  1;
   A[1] = -3;
   A[2] =  2;
   A[3] = -1;

   thrust::device_vector<int> B(4);
   is_less_than_zero pred;

   thrust::replace_copy_if(thrust::device, A.begin(), A.end(), B.begin(), pred, 0);

   // B contains [1, 0, 2, 0]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to copy from.

-  **last** The end of the sequence to copy from.

-  **result** The beginning of the sequence to copy to.

-  **pred** The predicate to test on every value of the
   range `[first,last)`.

-  **new_value** The replacement value to assign
   `pred(*i)` evaluates to `true`.

**Preconditions**: `first` may equal `result`, but the
ranges `[first, last)` and
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: `result + (last-first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace_copy

-  `replace`

-  `replace_if`

-  `replace_copy`

**thrust::replace_copy_if**

::

   template <typename InputIterator,
     typename OutputIterator,
     typename Predicate,
     typename T>
   OutputIterator
   replace_copy_if(InputIterator first,
     InputIterator last,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

`replace_copy_if` copies elements from the range
`[first, last)` to the range
`[result, result + (last-first))`, except that any element
for which `pred` is `true` is not copied; `new_value` is
copied instead.

More precisely, for every integer `n` such that 0 <= n <
last-first, `replace_copy_if` performs the assignment
`*(result+n) = new_value` if `pred(*(first+n))`, and
`*(result+n) = *(first+n)` otherwise.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>

   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  1;
   A[1] = -3;
   A[2] =  2;
   A[3] = -1;

   thrust::device_vector<int> B(4);
   is_less_than_zero pred;

   thrust::replace_copy_if(A.begin(), A.end(), B.begin(), pred, 0);

   // B contains [1, 0, 2, 0]

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`,
   and `InputIterator's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence to copy from.

-  **last** The end of the sequence to copy from.

-  **result** The beginning of the sequence to copy to.

-  **pred** The predicate to test on every value of the
   range `[first,last)`.

-  **new_value** The replacement value to assign
   `pred(*i)` evaluates to `true`.

**Preconditions**: `first` may equal `result`, but the
ranges `[first, last)` and
`[result, result + (last - first))` shall not overlap
otherwise.

**Returns**: `result + (last-first)`

**See**:

-  https://en.cppreference.com/w/cpp/algorithm/replace_copy

-  `replace`

-  `replace_if`

-  `replace_copy`

**thrust::replace_copy_if**

::

   template <typename DerivedPolicy,
     typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate,
     typename T>
   __host__ __device__ OutputIterator
   replace_copy_if(const thrust::detail::execution_policy_base< DerivedPolicy > & exec,
     InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

This version of `replace_copy_if` copies elements from the
range `[first, last)` to the range
`[result, result + (last-first))`, except that any element
whose corresponding stencil element causes `pred` to be
`true` is not copied; `new_value` is copied instead.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `replace_copy_if` performs the
assignment `*(result+n) = new_value` if
`pred(*(stencil+n))`, and `*(result+n) = *(first+n)`
otherwise.

The algorithm’s execution is parallelized as determined by
`exec`.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>

   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  10;
   A[1] =  20;
   A[2] =  30;
   A[3] =  40;

   thrust::device_vector<int> S(4);
   S[0] = -1;
   S[1] =  0;
   S[2] = -1;
   S[3] =  0;

   thrust::device_vector<int> B(4);
   is_less_than_zero pred;

   thrust::replace_if(thrust::device, A.begin(), A.end(), S.begin(), B.begin(), pred, 0);

   // B contains [0, 20, 0, 40]

**Template Parameters**:

-  **DerivedPolicy** The name of the derived execution
   policy.

-  **InputIterator1** is a model of `Input Iterator`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **exec** The execution policy to use for
   parallelization.

-  **first** The beginning of the sequence to copy from.

-  **last** The end of the sequence to copy from.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the sequence to copy to.

-  **pred** The predicate to test on every value of the
   range `[stencil, stencil + (last - first))`.

-  **new_value** The replacement value to assign when
   `pred(*s)` evaluates to `true`.

**Preconditions**:

-  `first` may equal `result`, but the ranges
   `[first, last)` and `[result, result + (last - first))`
   shall not overlap otherwise.

-  `stencil` may equal `result`, but the ranges
   `[stencil, stencil + (last - first))` and
   `[result, result + (last - first))` shall not overlap
   otherwise.

**Returns**: `result + (last-first)`

**See**:

-  `replace_copy`

-  `replace_if`

**thrust::replace_copy_if**

::

   template <typename InputIterator1,
     typename InputIterator2,
     typename OutputIterator,
     typename Predicate,
     typename T>
   OutputIterator
   replace_copy_if(InputIterator1 first,
     InputIterator1 last,
     InputIterator2 stencil,
     OutputIterator result,
     Predicate pred,
     const T & new_value);

This version of `replace_copy_if` copies elements from the
range `[first, last)` to the range
`[result, result + (last-first))`, except that any element
whose corresponding stencil element causes `pred` to be
`true` is not copied; `new_value` is copied instead.

More precisely, for every integer `n` such that
`0 <= n < last-first`, `replace_copy_if` performs the
assignment `*(result+n) = new_value` if
`pred(*(stencil+n))`, and `*(result+n) = *(first+n)`
otherwise.

::

   #include <thrust/replace.h>
   #include <thrust/device_vector.h>

   struct is_less_than_zero
   {
   __host__ __device__
   bool operator()(int x)
   {
      return x < 0;
   }
   };

   ...

   thrust::device_vector<int> A(4);
   A[0] =  10;
   A[1] =  20;
   A[2] =  30;
   A[3] =  40;

   thrust::device_vector<int> S(4);
   S[0] = -1;
   S[1] =  0;
   S[2] = -1;
   S[3] =  0;

   thrust::device_vector<int> B(4);
   is_less_than_zero pred;

   thrust::replace_if(A.begin(), A.end(), S.begin(), B.begin(), pred, 0);

   // B contains [0, 20, 0, 40]

**Template Parameters**:

-  **InputIterator1** is a model of `Input Iterator`.

-  **InputIterator2** is a model of `Input Iterator`
   and `InputIterator2's` `value_type` is convertible to
   `Predicate's` `argument_type`.

-  **OutputIterator** is a model of `Output Iterator`.

-  **Predicate** is a model of
   `Predicate`.

-  **T** is a model of
   `Assignable`,
   and `T` is convertible to
   `OutputIterator's` `value_type`.

**Function Parameters**:

-  **first** The beginning of the sequence to copy from.

-  **last** The end of the sequence to copy from.

-  **stencil** The beginning of the stencil sequence.

-  **result** The beginning of the sequence to copy to.

-  **pred** The predicate to test on every value of the
   range `[stencil, stencil + (last - first))`.

-  **new_value** The replacement value to assign when
   `pred(*s)` evaluates to `true`.

**Preconditions**:

-  `first` may equal `result`, but the ranges
   `[first, last)` and `[result, result + (last - first))`
   shall not overlap otherwise.

-  `stencil` may equal `result`, but the ranges
   `[stencil, stencil + (last - first))` and
   `[result, result + (last - first))` shall not overlap
   otherwise.

**Returns**: `result + (last-first)`

**See**:

-  `replace_copy`

-  `replace_if`

Container Classes
=================

Host Containers
---------------

**Host Containers**

::

   template <typename T,
     typename Alloc = std::allocator<T>>
   class
   thrust::host_vector;

   template <typename T,
     typename Alloc>
   void
   thrust::swap(host_vector< T, Alloc > & a,
     host_vector< T, Alloc > & b);

**Member Classes**

**thrust::host_vector**

**Inherits From**:

::

   detail::vector_base< T, std::allocator< T > >

**Functions**

**thrust::swap**

::

   template <typename T,
     typename Alloc>
   void
   swap(host_vector< T, Alloc > & a,
     host_vector< T, Alloc > & b);

Exchanges the values of two vectors. `x` The first
`host_vector` of interest. `y` The second `host_vector`
of interest.

Containers
==========

**Containers**

::

   template <typename T,
     typename Alloc = thrust::device_allocator<T>>
   class
   thrust::device_vector;

   template <typename T,
     typename Alloc>
   void
   thrust::swap(device_vector< T, Alloc > & a,
     device_vector< T, Alloc > & b);

**Member Classes**

**thrust::device_vector**

**Inherits From**:

::

   detail::vector_base< T, thrust::device_allocator< T > >

**Functions**

**thrust::swap**

::

   template <typename T,
     typename Alloc>
   void
   swap(device_vector< T, Alloc > & a,
     device_vector< T, Alloc > & b);

Exchanges the values of two vectors. `x` The first
`device_vector` of interest. `y` The second
`device_vector` of interest.

Function Objects Classes
========================

Function Object Adaptors
------------------------

**Function Object Adaptors**

::

   template <typename Argument,
     typename Result>
   struct
   thrust::unary_function;

   template <typename Argument1,
     typename Argument2,
     typename Result>
   struct
   hrust::binary_function;

   template <typename Predicate>
   struct
   thrust::unary_negate;

   template <typename Predicate>
   struct
   thrust::binary_negate;

   template <typename Function>
   class
   thrust::zip_function;

   template <typename Predicate>
   __host__ __device__ unary_negate< Predicate >
   thrust::not1(const Predicate & pred);

   template <typename BinaryPredicate>
   __host__ __device__ binary_negate< BinaryPredicate >
   thrust::not2(const BinaryPredicate & pred);

   template <typename Function>
   __host__ __device__ zip_function< typename std::decay< Function >::type >
   thrust::make_zip_function(Function && fun);

**Member Classes**

**thrust::unary_function**

**thrust::binary_function**

**thrust::unary_negate**

**Inherits From**:
`thrust::unary_function< Predicate::argument_type, bool >`

**thrust::binary_negate**

**Inherits From**:
`thrust::binary_function< Predicate::first_argument_type, Predicate::second_argument_type, bool >`

**thrust::zip_function**

**Functions**

**thrust::not1**

::

   template <typename Predicate> __host__ __device__ unary_negate< Predicate > not1(const Predicate & pred);

`not1` is a helper function to simplify the creation of
Adaptable Predicates: it takes an Adaptable Predicate `pred`
as an argument and returns a new Adaptable Predicate that
represents the negation of `pred`. That is: if `pred` is an
object of a type which models Adaptable Predicate, then the the
type of the result `npred` of `not1(pred)` is also a model
of Adaptable Predicate and `npred(x)` always returns the same
value as `!pred(x)`.

**Template Parameters**: **Predicate**: is a model of
`Adaptable Predicate`.

**Function Parameters**: **pred**: The Adaptable Predicate
to negate.

**Returns**: A new object, `npred` such that `npred(x)`
always returns the same value as `!pred(x)`.

**See**:

-  `unary_negate`

-  not2

**thrust::not2**

::

   template <typename BinaryPredicate> __host__ __device__ binary_negate< BinaryPredicate > not2(const BinaryPredicate & pred);

`not2` is a helper function to simplify the creation of
Adaptable Binary Predicates: it takes an Adaptable Binary
Predicate `pred` as an argument and returns a new Adaptable
Binary Predicate that represents the negation of `pred`. That
is: if `pred` is an object of a type which models Adaptable
Binary Predicate, then the the type of the result `npred` of
`not2(pred)` is also a model of Adaptable Binary Predicate
and `npred(x,y)` always returns the same value as
`!pred(x,y)`.

**Template Parameters**: **Binary**: Predicate is a model
of `Adaptable Binary Predicate`.

**Function Parameters**: **pred**: The Adaptable Binary
Predicate to negate.

**Returns**: A new object, `npred` such that `npred(x,y)`
always returns the same value as `!pred(x,y)`.

**See**:

-  `binary_negate`

-  not1

**thrust::make_zip_function**

::

   template <typename Function> __host__ __device__ zip_function< typename std::decay< Function >::type > make_zip_function(Function && fun);

`make_zip_function` creates a `zip_function` from a
function object.

**Function Parameters**: **fun**: The N-ary function
object.

**Returns**: A `zip_function` that takes a N-tuple.

**See**:
`zip_function`

Placeholder Objects
-------------------

**Placeholder Objects**

`/* Facilities for constructing simple functions inline. */namespace thrust::placeholders { … }`

Predefined Function Objects
---------------------------

Arithmetic Operations
*********************

**Arithmetic Operations**

::

   template <typename T = void>
   struct
   thrust::plus;

   struct
   thrust::plus< void >;

   template <typename T = void>
   struct
   thrust::minus;

   struct
   thrust::minus< void >;

   template <typename T = void>
   struct
   thrust::multiplies;

   struct
   thrust::multiplies< void >;

   template <typename T = void>
   struct
   thrust::divides;

   struct
   thrust::divides< void >;

   template <typename T = void>
   struct
   thrust::modulus;

   struct
   thrust::modulus< void >;

   template <typename T = void>
   struct
   thrust::negate;

   struct
   thrust::negate< void >;

   template <typename T = void>
   struct
   thrust::square;

   struct
   thrust::square< void >;

   #define THRUST_UNARY_FUNCTOR_VOID_SPECIALIZATION = see below;

   #define THRUST_BINARY_FUNCTOR_VOID_SPECIALIZATION = see below;

   #define THRUST_BINARY_FUNCTOR_VOID_SPECIALIZATION_OP = see below;

**Member Classes**

**thrust::plus**

**thrust::plus< void >**

**thrust::minus**

**thrust::minus< void >**

**thrust::multiplies**

**thrust::multiplies< void >**

**thrust::divides**

**thrust::divides< void >**

**thrust::modulus**

**thrust::modulus< void >**

**thrust::negate**

**thrust::negate< void >**

**thrust::square**

**thrust::square< void >**

**Macros**

**THRUST_UNARY_FUNCTOR_VOID_SPECIALIZATION**

**THRUST_BINARY_FUNCTOR_VOID_SPECIALIZATION**

**THRUST_BINARY_FUNCTOR_VOID_SPECIALIZATION_OP**

Bitwise Operations
******************

**Bitwise Operations**

::

   template <typename T = void>
   struct
   thrust::bit_and;

   struct
   thrust::bit_and< void >;

   template <typename T = void>
   struct
   thrust::bit_or;

   struct
   thrust::bit_or< void >;

   template <typename T = void>
   struct
   thrust::bit_xor;

   struct
   thrust::bit_xor< void >;

**Member Classes**

**thrust::bit_and**

**thrust::bit_and< void >**

**thrust::bit_or**

**thrust::bit_or< void >**

**thrust::bit_xor**

**thrust::bit_xor< void >**

Comparison Operations
*********************

**Comparison Operations**

::

   template <typename T = void>
   struct
   thrust::equal_to;

   struct
   thrust::equal_to< void >;

   template <typename T = void>
   struct
   thrust::not_equal_to;

   struct
   thrust::not_equal_to< void >;

   template <typename T = void>
   struct
   thrust::greater;

   struct
   thrust::greater< void >;

   template <typename T = void>
   struct
   thrust::less;

   struct
   thrust::less< void >;

   template <typename T = void>
   struct
   thrust::greater_equal;

   struct
   thrust::greater_equal< void >;

   template <typename T = void>
   struct
   thrust::less_equal;

   struct
   thrust::less_equal< void >;

**Member Classes**

**thrust::equal_to**

**thrust::equal_to< void >**

**thrust::not_equal_to**

**thrust::not_equal_to< void >**

**thrust::greater**

**thrust::greater< void >**

**thrust::less**

**thrust::less< void >**

**thrust::greater_equal**

**thrust::greater_equal< void >**

**thrust::less_equal**

**thrust::less_equal< void >**

Generalized Identity Operations
*******************************

**Generalized Identity Operations**

::

   template <typename T = void>
   struct
   thrust::identity;

   struct
   thrust::identity< void >;

   template <typename T = void>
   struct
   thrust::maximum;

   struct
   thrust::maximum< void >;

   template <typename T = void>
   struct
   thrust::minimum;

   struct
   thrust::minimum< void >;

   template <typename T1 = void,
     typename T2 = void>
   struct
   thrust::project1st;

   struct
   thrust::project1st< void, void >;

   template <typename T1 = void,
     typename T2 = void>
   struct
   thrust::project2nd;

   struct
   thrust::project2nd< void, void >;

**Member Classes**

**thrust::identity**

**thrust::identity< void >**

**thrust::maximum**

**thrust::maximum< void >**

**thrust::minimum**

**thrust::minimum< void >**

**thrust::project1st**

**thrust::project1st< void, void >**

**thrust::project2nd**

**thrust::project2nd< void, void >**

Logical Operations
******************

**Logical Operations**

::

   template <typename T = void>
   struct
   thrust::logical_and;

   struct
   thrust::logical_and< void >;

   template <typename T = void>
   struct
   thrust::logical_or;

   struct
   thrust::logical_or< void >;

   template <typename T = void>
   struct
   thrust::logical_not;

   struct
   thrust::logical_not< void >;

**Member Classes**

**thrust::logical_and**

**thrust::logical_and< void >**

**thrust::logical_or**

**thrust::logical_or< void >**>

**thrust::logical_not**

**thrust::logical_not< void >**

Iterators
=========

**Functions**

::

   template <typename InputIterator,
     typename Distance>
   __host__ __device__ void
   thrust::advance(InputIterator & i,
     Distance n);

   template <typename InputIterator>
   __host__ __device__ thrust::iterator_traits< InputIterator >::difference_type
   thrust::distance(InputIterator first,
     InputIterator last);

**thrust::advance**

::

   template <typename InputIterator,
     typename Distance>
   __host__ __device__ void
   advance(InputIterator & i,
     Distance n);

`advance(i, n)` increments the iterator `i` by the distance
`n`. If `n > 0` it is equivalent to executing
`++i` `n` times, and if `n < 0` it is equivalent to
executing `–i` `n` times. If `n == 0`, the call has no
effect.

The following code snippet demonstrates how to use `advance`
to increment an iterator a given number of times.

::

   #include <thrust/advance.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> vec(13);
   thrust::device_vector<int>::iterator iter = vec.begin();

   thrust::advance(iter, 7);

   // iter - vec.begin() == 7

**Template Parameters**:

-  **InputIterator** is a model of `Input Iterator`.

-  **Distance** is an integral type that is convertible to
   `InputIterator's` distance type.

**Function Parameters**:

-  **i** The iterator to be advanced.

-  **n** The distance by which to advance the iterator.

**Preconditions**: `n` shall be negative only for
bidirectional and random access iterators.

**See**: https://en.cppreference.com/w/cpp/iterator/advance

**thrust::distance**

::

   template <typename InputIterator>
   __host__ __device__ thrust::iterator_traits< InputIterator >::difference_type
   distance(InputIterator first,
     InputIterator last);

`distance` finds the distance between `first` and `last`,
i.e. the number of times that `first` must be incremented
until it is equal to `last`.

The following code snippet demonstrates how to use `distance`
to compute the distance to one iterator from another.

::

   #include <thrust/distance.h>
   #include <thrust/device_vector.h>
   ...
   thrust::device_vector<int> vec(13);
   thrust::device_vector<int>::iterator iter1 = vec.begin();
   thrust::device_vector<int>::iterator iter2 = iter1 + 7;

   int d = thrust::distance(iter1, iter2);

   // d is 7

**Template Parameters**: **InputIterator**: is a model of
`Input Iterator`.

**Function Parameters**:

-  **first** The beginning of an input range of interest.

-  **last** The end of an input range of interest.

**Preconditions**: If `InputIterator` meets the requirements
of random access iterator, `last` shall be reachable from
`first` or `first` shall be reachable from `last`;
otherwise, `last` shall be reachable from `first`.

**Returns**: The distance between the beginning and end of the
input range.

**See**: https://en.cppreference.com/w/cpp/iterator/distance

Fancy Iterators
---------------

**Fancy Iterators**

::

   template <typename Value,
     typename Incrementable = use_default,
     typename System = use_default>
   class
   thrust::constant_iterator;

   template <typename Incrementable,
     typename System = use_default,
     typename Traversal = use_default,
     typename Difference = use_default>
   class
   thrust::counting_iterator;

   template <typename System = use_default>
   class
   thrust::discard_iterator;

   template <typename Derived,
     typename Base,
     typename Value = use_default,
     typename System = use_default,
     typename Traversal = use_default,
     typename Reference = use_default,
     typename Difference = use_default>
   class
   thrust::iterator_adaptor;

   template <typename Derived,
     typename Value,
     typename System,  
     typename Traversal,
     typename Reference,
     typename Difference = std::ptrdiff_t>
   class
   thrust::iterator_facade;

   class
   thrust::iterator_core_access;

   template <typename ElementIterator,
     typename IndexIterator>
   class
   thrust::permutation_iterator;

   template <typename BidirectionalIterator>
   class
   thrust::reverse_iterator;

   template <typename InputFunction,
     typename OutputFunction,
     typename Iterator>
   class
   thrust::transform_input_output_iterator;

   template <class AdaptableUnaryFunction,
     class Iterator,
     class Reference = use_default,
     class Value = use_default>
   class
   thrust::transform_iterator;

   template <typename UnaryFunction,
     typename OutputIterator>
   class
   thrust::transform_output_iterator;

   template <typename IteratorTuple>
   class
   thrust::zip_iterator;

   template <typename ValueT,
     typename IndexT>
   __host__ __device__ constant_iterator< ValueT, IndexT >
   thrust::make_constant_iterator(ValueT x,
     IndexT i = int());

   template <typename V>
   __host__ __device__ constant_iterator< V >
   thrust::make_constant_iterator(V x);

   template <typename Incrementable>
   __host__ __device__ counting_iterator< Incrementable >
   thrust::make_counting_iterator(Incrementable x);

   __host__ __device__ discard_iterator
   thrust::make_discard_iterator(discard_iterator<>::difference_type i = discard_iterator<>::difference_type(0));

   template <typename ElementIterator,
     typename IndexIterator>
   __host__ __device__ permutation_iterator< ElementIterator, IndexIterator >
   thrust::make_permutation_iterator(ElementIterator e,
     IndexIterator i);

   template <typename BidirectionalIterator>
   __host__ __device__ reverse_iterator< BidirectionalIterator >
   thrust::make_reverse_iterator(BidirectionalIterator x);

   template <typename InputFunction,
     typename OutputFunction,
     typename Iterator>
   transform_input_output_iterator< InputFunction, OutputFunction, Iterator >
   __host__ __device__ thrust::make_transform_input_output_iterator(Iterator io,
     InputFunction input_function,
     OutputFunction output_function);

   template <class AdaptableUnaryFunction,
     class Iterator>
   __host__ __device__ transform_iterator< AdaptableUnaryFunction, Iterator >
   thrust::make_transform_iterator(Iterator it,
     AdaptableUnaryFunction fun);

   template <typename UnaryFunction,
     typename OutputIterator>
   transform_output_iterator< UnaryFunction, OutputIterator >
   __host__ __device__ thrust::make_transform_output_iterator(OutputIterator out,
     UnaryFunction fun);

   template <typename... Iterators>
   __host__ __device__ zip_iterator< thrust::tuple< Iterators... > >
   thrust::make_zip_iterator(thrust::tuple< Iterators... > t);

   template <typename... Iterators>
   __host__ __device__ zip_iterator< thrust::tuple< Iterators... > >
   thrust::make_zip_iterator(Iterators... its);

**Member Classes**

**thrust::constant_iterator**

**Inherits From**: `detail::constant_iterator_base::type`

**thrust::counting_iterator**

**Inherits From**: `detail::counting_iterator_base::type`

**thrust::discard_iterator**

**Inherits From**: `detail::discard_iterator_base::type`

**thrust::iterator_adaptor**

**Inherits From**: `detail::iterator_adaptor_base::type`

**thrust::iterator_facade**

**thrust::iterator_core_access**

**thrust::permutation_iterator**

**Inherits From**:
`thrust::detail::permutation_iterator_base::type`

**thrust::reverse_iterator**

**Inherits From**: `detail::reverse_iterator_base::type`

**thrust::transform_input_output_iterator**

**Inherits From**:
`detail::transform_input_output_iterator_base::type`

**thrust::transform_iterator**

**Inherits From**: `detail::transform_iterator_base::type`

**thrust::transform_output_iterator**

**Inherits From**:
`detail::transform_output_iterator_base::type`

**thrust::zip_iterator**

**Inherits From**: `detail::zip_iterator_base::type`

**Functions**

**thrust::make_constant_iterator**

::

   template <typename ValueT,
     typename IndexT>
   __host__ __device__ constant_iterator< ValueT, IndexT >
   make_constant_iterator(ValueT x,
     IndexT i = int());

This version of `make_constant_iterator` creates a
`constant_iterator` from values given for both value and
index. The type of `constant_iterator` may be inferred by the
compiler from the types of its parameters.

**Function Parameters**:

-  **x** The value of the returned `constant_iterator's`
   constant value.

-  **i** The index of the returned `constant_iterator`
   within a sequence. The type of this parameter defaults to
   `int`. In the default case, the value of this parameter is
   `0`.

**Returns**: A new `constant_iterator` with constant value &
index as given by `x` & `i`.

**See**:
`constant_iterator`

**thrust::make_constant_iterator**

::

   template <typename V> __host__ __device__ constant_iterator< V > make_constant_iterator(V x);

This version of `make_constant_iterator` creates a
`constant_iterator` using only a parameter for the desired
constant value. The value of the returned
`constant_iterator's` index is set to `0`.

**Function Parameters**: **x**: The value of the returned
`constant_iterator's` constant value.

**Returns**: A new `constant_iterator` with constant value
equal to `x` and index equal to `0`.

**See**:
`constant_iterator`

**thrust::make_counting_iterator**

::

   template <typename Incrementable>
   __host__ __device__ counting_iterator< Incrementable >
   make_counting_iterator(Incrementable x);

`make_counting_iterator` creates a `counting_iterator`
using an initial value for its `Incrementable` counter.

**Function Parameters**: **x**: The initial value of the
new `counting_iterator's` counter.

**Returns**: A new `counting_iterator` whose counter has been
initialized to `x`.

**thrust::make_discard_iterator**

::

   __host__ __device__ discard_iterator
   make_discard_iterator(discard_iterator<>::difference_type i = discard_iterator<>::difference_type(0));

`make_discard_iterator` creates a `discard_iterator` from
an optional index parameter.

**Function Parameters**: **i**: The index of the returned
`discard_iterator` within a range. In the default case, the
value of this parameter is `0`.

**Returns**: A new `discard_iterator` with index as given by
`i`.

**See**:
`constant_iterator`

**thrust::make_permutation_iterator**

::

   template <typename ElementIterator,
     typename IndexIterator>
   __host__ __device__ permutation_iterator< ElementIterator, IndexIterator >
   make_permutation_iterator(ElementIterator e,
     IndexIterator i);

`make_permutation_iterator` creates a
`permutation_iterator` from an `ElementIterator` pointing
to a range of elements to “permute” and an `IndexIterator`
pointing to a range of indices defining an indexing scheme on
the values.

**Function Parameters**:

-  **e** An `ElementIterator` pointing to a range of
   values.

-  **i** An `IndexIterator` pointing to an indexing
   scheme to use on `e`.

**Returns**: A new `permutation_iterator` which permutes the
range `e` by `i`.

**See**:
`permutation_iterator`

**thrust::make_reverse_iterator**

::

   template <typename BidirectionalIterator>
   __host__ __device__ reverse_iterator< BidirectionalIterator >
   make_reverse_iterator(BidirectionalIterator x);

`make_reverse_iterator` creates a `reverse_iterator` from a
`BidirectionalIterator` pointing to a range of elements to
reverse.

**Function Parameters**: **x**: A `BidirectionalIterator`
pointing to a range to reverse.

**Returns**: A new `reverse_iterator` which reverses the
range `x`.

**thrust::make_transform_input_output_iterator**

::

   template <typename InputFunction,
     typename OutputFunction,
     typename Iterator>
   transform_input_output_iterator< InputFunction, OutputFunction, Iterator >
   __host__ __device__ make_transform_input_output_iterator(Iterator io,
     InputFunction input_function,
     OutputFunction output_function);

`make_transform_input_output_iterator` creates a
`transform_input_output_iterator` from an `Iterator` a
`InputFunction` and a `OutputFunction`

**Function Parameters**:

-  **io** An `Iterator` pointing to where the input to
   `InputFunction` will be read from and the result of
   `OutputFunction` will be written to

-  **input_function** An `InputFunction` to be executed
   on values read from the iterator

-  **output_function** An `OutputFunction` to be executed
   on values written to the iterator

**See**:
`transform_input_output_iterator`

**thrust::make_transform_iterator**

::

   template <class AdaptableUnaryFunction,
     class Iterator>
   __host__ __device__ transform_iterator< AdaptableUnaryFunction, Iterator >
   make_transform_iterator(Iterator it,
     AdaptableUnaryFunction fun);

`make_transform_iterator` creates a `transform_iterator`
from an `Iterator` and `AdaptableUnaryFunction`.

**Function Parameters**:

-  **it** The `Iterator` pointing to the input range of
   the newly created `transform_iterator`.

-  **fun** The `AdaptableUnaryFunction` used to transform
   the range pointed to by `it` in the newly created
   `transform_iterator`.

**Returns**: A new `transform_iterator` which transforms the
range at `it` by `fun`.

**See**:
`transform_iterator`

**thrust::make_transform_output_iterator**

::

   template <typename UnaryFunction,
     typename OutputIterator>
   transform_output_iterator< UnaryFunction, OutputIterator >
   __host__ __device__ make_transform_output_iterator(OutputIterator out,
     UnaryFunction fun);

`make_transform_output_iterator` creates a
`transform_output_iterator` from an `OutputIterator` and
`UnaryFunction`.

**Function Parameters**:

-  **out** The `OutputIterator` pointing to the output
   range of the newly created `transform_output_iterator`

-  **fun** The `UnaryFunction` transform the object
   before assigning it to `out` by the newly created
   `transform_output_iterator`

**See**:
`transform_output_iterator`

**thrust::make_zip_iterator**

::

   template <typename... Iterators>
   __host__ __device__ zip_iterator< thrust::tuple< Iterators... > >
   make_zip_iterator(thrust::tuple< Iterators... > t);

`make_zip_iterator` creates a `zip_iterator` from a
`tuple` of iterators.

**Function Parameters**: **t**: The `tuple` of iterators
to copy.

**Returns**: A newly created `zip_iterator` which zips the
iterators encapsulated in `t`.

**See**:
`zip_iterator`

**thrust::make_zip_iterator**

::

   template <typename... Iterators>
   __host__ __device__ zip_iterator< thrust::tuple< Iterators... > >
   make_zip_iterator(Iterators... its);

`make_zip_iterator` creates a `zip_iterator` from
iterators.

**Function Parameters**: **its**: The iterators to copy.

**Returns**: A newly created `zip_iterator` which zips the
iterators.

**See**:
`zip_iterator`

Iterator Tags
-------------

Iterator Tag Classes
********************

**Iterator Tag Classes**

::

   struct
   thrust::input_device_iterator_tag;

   struct
   thrust::output_device_iterator_tag;

   struct
   thrust::forward_device_iterator_tag;

   struct
   thrust::bidirectional_device_iterator_tag;

   struct
   thrust::random_access_device_iterator_tag;

typedef see below thrust::input_host_iterator_tag;

typedef see below thrust::output_host_iterator_tag;

typedef see below thrust::forward_host_iterator_tag;

typedef see below thrust::bidirectional_host_iterator_tag;

typedef see below thrust::random_access_host_iterator_tag;

**Member Classes**

**thrust::input_device_iterator_tag**

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::input_iterator_tag, thrust::device_system_tag, thrust::single_pass_traversal_tag >`

**thrust::output_device_iterator_tag**

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::output_iterator_tag, thrust::device_system_tag, thrust::single_pass_traversal_tag >`

**thrust::forward_device_iterator_tag**

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::forward_iterator_tag, thrust::device_system_tag, thrust::forward_traversal_tag >`

**thrust::bidirectional_device_iterator_tag**

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::bidirectional_iterator_tag, thrust::device_system_tag, thrust::bidirectional_traversal_tag >`

**thrust::random_access_device_iterator_tag**

**Inherits From**:
`thrust::detail::iterator_category_with_system_and_traversal< std::random_access_iterator_tag, thrust::device_system_tag, thrust::random_access_traversal_tag >`

**Types**

**thrust::input_host_iterator_tag**

`typedef std::input_iterator_taginput_host_iterator_tag;`
`input_host_iterator_tag` is an empty class: it has no member
functions, member variables, or nested types. It is used solely
as a “tag”: a representation of the Input Host Iterator concept
within the C++ type system.

**See**:
- https://en.cppreference.com/w/cpp/iterator/iterator_tags

- `iterator_traits`,

- `input_device_iterator_tag`,

- `output_device_iterator_tag`,

- `forward_device_iterator_tag`,

- `bidirectional_device_iterator_tag`,

- `random_access_device_iterator_tag`,

- output_host_iterator_tag, forward_host_iterator_tag,

- bidirectional_host_iterator_tag,

- random_access_host_iterator_tag


**thrust::output_host_iterator_tag**

`typedef std::output_iterator_tagoutput_host_iterator_tag;`
`output_host_iterator_tag` is an empty class: it has no
member functions, member variables, or nested types. It is used
solely as a “tag”: a representation of the Output Host Iterator
concept within the C++ type system.

**See**:
- https://en.cppreference.com/w/cpp/iterator/iterator_tags

- `iterator_traits`,

- `input_device_iterator_tag`,

- `output_device_iterator_tag`,

- `forward_device_iterator_tag`,

- `bidirectional_device_iterator_tag`,

- `random_access_device_iterator_tag`,

- input_host_iterator_tag, forward_host_iterator_tag,

- bidirectional_host_iterator_tag,

- random_access_host_iterator_tag


**thrust::forward_host_iterator_tag**

`typedef std::forward_iterator_tagforward_host_iterator_tag;`
`forward_host_iterator_tag` is an empty class: it has no
member functions, member variables, or nested types. It is used
solely as a “tag”: a representation of the Forward Host
Iterator concept within the C++ type system.

**See**:

- iterator_traits

- input_device_iterator_tag

- output_device_iterator_tag

- forward_device_iterator_tag

- bidirectional_device_iterator_tag

- random_access_device_iterator_tag

- input_host_iterator_tag

- output_host_iterator_tag

- bidirectional_host_iterator_tag

- random_access_host_iterator_tag

**thrust::bidirectional_host_iterator_tag**

`typedef std::bidirectional_iterator_tagbidirectional_host_iterator_tag;`
`bidirectional_host_iterator_tag` is an empty class: it has
no member functions, member variables, or nested types. It is
used solely as a “tag”: a representation of the Forward Host
Iterator concept within the C++ type system.

**See**:

- iterator_traits

- input_device_iterator_tag

- output_device_iterator_tag

- forward_device_iterator_tag

- bidirectional_device_iterator_tag

- random_access_device_iterator_tag

- input_host_iterator_tag, output_host_iterator_tag

- forward_host_iterator_tag

- random_access_host_iterator_tag

**thrust::random_access_host_iterator_ta**

`typedef std::random_access_iterator_tagrandom_access_host_iterator_tag;`
`random_access_host_iterator_tag` is an empty class: it has
no member functions, member variables, or nested types. It is
used solely as a “tag”: a representation of the Forward Host
Iterator concept within the C++ type system.

**See**:

- iterator_traits

- input_device_iterator_tag

- output_device_iterator_tag

- forward_device_iterator_tag

- bidirectional_device_iterator_tag

- random_access_device_iterator_tag

- input_host_iterator_tag, output_host_iterator_tag

- forward_host_iterator_tag

- bidirectional_host_iterator_tag

Memory Management
=================

**Memory Management**

All Thrust functionalities related to memory allocation and
deallocation.

**Groups**

-  `Allocators`

-  `Memory Resources`

::

   template <typename T>
   class thrust::device_reference;

   /* device_ptr is a pointer-like object which points to an object that resides in memory associated with the device system. */
   template <typename T>
   class thrust::device_ptr;

   template <typename T>
   void
   thrust::device_delete(thrust::device_ptr< T > ptr,
   const size_t n = 1);

   void
   thrust::device_free(thrust::device_ptr< void > ptr);

   thrust::device_ptr< void >
   thrust::device_malloc(const std::size_t n);

   template <typename T>
   thrust::device_ptr< T >
   thrust::device_malloc(const std::size_t n);

   template <typename T>
   device_ptr< T >
   thrust::device_new(device_ptr< void > p,
   const size_t n = 1);

   template <typename T>
   device_ptr< T >
   thrust::device_new(device_ptr< void > p,
   const T & exemplar,
   const size_t n = 1);

   template <typename T>
   device_ptr< T >
   thrust::device_new(const size_t n = 1);

   template <typename T,
   typename CharT,
   typename Traits>
   __host__ std::basic_ostream< CharT, Traits > &
   thrust::operator<<(std::basic_ostream< CharT, Traits > & os,
   device_ptr< T > const & dp);

   /* Create a device_ptr from a raw pointer. */
   template <typename T>
   __host__ __device__ device_ptr< T >
   thrust::device_pointer_cast(T * ptr);

   /* Create a device_ptr from another device_ptr. */
   template <typename T>
   __host__ __device__ device_ptr< T >
   thrust::device_pointer_cast(device_ptr< T > const & dptr);

   template <typename T>
   __host__ __device__ void
   thrust::swap(device_reference< T > & x,
   device_reference< T > & y);

   template <typename T,
   typename charT,
   typename traits>
   std::basic_ostream< charT, traits > &
   thrust::operator<<(std::basic_ostream< charT, traits > & os,
   const device_reference< T > & y);

   template <typename DerivedPolicy>
   __host__ __device__ pointer< void, DerivedPolicy >
   thrust::malloc(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
   std::size_t n);

   template <typename T,
   typename DerivedPolicy>
   __host__ __device__ pointer< T, DerivedPolicy >
   thrust::malloc(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
   std::size_t n);

   template <typename T,
   typename DerivedPolicy>
   __host__ __device__ thrust::pair< thrust::pointer< T, DerivedPolicy >, typename thrust::pointer< T, DerivedPolicy >::difference_type >
   thrust::get_temporary_buffer(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
   typename thrust::pointer< T, DerivedPolicy >::difference_type n);

   template <typename DerivedPolicy,
   typename Pointer>
   __host__ __device__ void
   thrust::free(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
   Pointer ptr);

   template <typename DerivedPolicy,
   typename Pointer>
   __host__ __device__ void
   thrust::return_temporary_buffer(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
   Pointer p,
   std::ptrdiff_t n);

   template <typename Pointer>
   __host__ __device__ thrust::detail::pointer_traits< Pointer >::raw_pointer
   thrust::raw_pointer_cast(Pointer ptr);

   template <typename T>
   __host__ __device__ detail::raw_reference< T >::type
   thrust::raw_reference_cast(T & ref);

   template <typename T>
   __host__ __device__ detail::raw_reference< constT >::type
   thrust::raw_reference_cast(const T & ref);

**Member Classes**

**thrust::device_reference**

**Inherits From**:
`thrust::reference< T, thrust::device_ptr< T >, thrust::device_reference< T > >`

**thrust::device_ptr**

`device_ptr` is a pointer-like object which points to an
object that resides in memory associated with the device
system.

**Inherits From**:
`thrust::pointer< T, thrust::device_system_tag, thrust::device_reference< T >, thrust::device_ptr< T > >`

**Functions**

**thrust::device_delete**

::

   template <typename T>
   void
   device_delete(thrust::device_ptr< T > ptr,
     const size_t n = 1);

`device_delete` deletes a `device_ptr` allocated with
`device_new`.

**Function Parameters**:

-  **ptr** The `device_ptr` to delete, assumed to have
   been allocated with `device_new`.

-  **n** The number of objects to destroy at `ptr`.
   Defaults to `1` similar to `device_new`.

**See**:

-  `device_ptr`

-  device_new

**thrust::device_free**

`void device_free(thrust::device_ptr< void > ptr);`
`device_free` deallocates memory allocated by the function
`device_malloc`.

The following code snippet demonstrates how to use
`device_free` to deallocate memory allocated by
`device_malloc`.

::

   #include <thrust/device_malloc.h>
   #include <thrust/device_free.h>
   ...
   // allocate some integers with device_malloc
   const int N = 100;
   thrust::device_ptr<int> int_array = thrust::device_malloc<int>(N);

   // manipulate integers
   ...

   // deallocate with device_free
   thrust::device_free(int_array);

**Function Parameters**: **ptr**: A `device_ptr` pointing
to memory to be deallocated.

**See**:

-  `device_ptr`

-  device_malloc

**thrust::device_malloc**

`thrust::device_ptr< void > device_malloc(const std::size_t n);`
This version of `device_malloc` allocates sequential device
storage for bytes.

The following code snippet demonstrates how to use
`device_malloc` to allocate a range of device memory.

::

   #include <thrust/device_malloc.h>
   #include <thrust/device_free.h>
   ...
   // allocate some memory with device_malloc
   const int N = 100;
   thrust::device_ptr<void> void_ptr = thrust::device_malloc(N);

   // manipulate memory
   ...

   // deallocate with device_free
   thrust::device_free(void_ptr);

**Function Parameters**: **n**: The number of bytes to
allocate sequentially in device memory.

**Returns**: A `device_ptr` to the newly allocated memory.

**See**:

-  `device_ptr`

-  device_free

**thrust::device_malloc**

::

   template <typename T>
   thrust::device_ptr< T >
   device_malloc(const std::size_t n);

This version of `device_malloc` allocates sequential device
storage for new objects of the given type.

The following code snippet demonstrates how to use
`device_malloc` to allocate a range of device memory.

::

   #include <thrust/device_malloc.h>
   #include <thrust/device_free.h>
   ...
   // allocate some integers with device_malloc
   const int N = 100;
   thrust::device_ptr<int> int_array = thrust::device_malloc<int>(N);

   // manipulate integers
   ...

   // deallocate with device_free
   thrust::device_free(int_array);

**Function Parameters**: **n**: The number of objects of
type T to allocate sequentially in device memory.

**Returns**: A `device_ptr` to the newly allocated memory.

**See**:

-  `device_ptr`

-  device_free

**thrust::device_new**

::

   template <typename T>
   device_ptr< T >
   device_new(device_ptr< void > p,
     const size_t n = 1);

`device_new` implements the placement `new` operator for
types resident in device memory. `device_new` calls `T` ’s
null constructor on a array of objects in device memory. No
memory is allocated by this function.

**Function Parameters**:

-  **p** A `device_ptr` to a region of device memory into
   which to construct one or many `T` s.

-  **n** The number of objects to construct at `p`.

**Returns**: p, casted to `T` ’s type.

**See**:
`device_ptr`

**thrust::device_new**

::

   template <typename T>
   device_ptr< T >
   device_new(device_ptr< void > p,
     const T & exemplar,
     const size_t n = 1);

`device_new` implements the placement new operator for types
resident in device memory. `device_new` calls `T` ’s copy
constructor on a array of objects in device memory. No memory
is allocated by this function.

**Function Parameters**:

-  **p** A `device_ptr` to a region of device memory into
   which to construct one or many `T` s.

-  **exemplar** The value from which to copy.

-  **n** The number of objects to construct at `p`.

**Returns**: p, casted to `T` ’s type.

**See**:

-  `device_ptr`

-  fill

**thrust::device_new**

::

   template <typename T>
   device_ptr< T >
   device_new(const size_t n = 1);

`device_new` implements the new operator for types resident
in device memory. It allocates device memory large enough to
hold `n` new objects of type `T`.

**Function Parameters**: **n**: The number of objects to
allocate. Defaults to `1`.

**Returns**: A `device_ptr` to the newly allocated region of
device memory.

**thrust::operator<<**

::

   template <typename T,
     typename CharT,
     typename Traits>
   __host__ std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     device_ptr< T > const & dp);

Write the address that a `device_ptr` points to to an output
stream.

**Function Parameters**:

-  **os** The output stream.

-  **dp** The `device_ptr` to output.

**Returns**: `os`.

**thrust::device_pointer_cast**

::

   template <typename T>
   __host__ __device__ device_ptr< T >
   device_pointer_cast(T * ptr);

Create a `device_ptr` from a raw pointer.

**Template Parameters**: **T**: Any type.

**Function Parameters**: **ptr**: A raw pointer to a `T`
in device memory.

**Preconditions**: `ptr` points to a location in device
memory.

**Returns**: A `device_ptr<T>` pointing to `ptr`.

**thrust::device_pointer_cast**

::

   template <typename T>
   __host__ __device__ device_ptr< T >
   device_pointer_cast(device_ptr< T > const & dptr);

Create a `device_ptr` from another `device_ptr`.

**Template Parameters**: **T**: Any type.

**Function Parameters**: **dptr**: A `device_ptr` to a
`T`.

**thrust::swap**

::

   template <typename T>
   __host__ __device__ void
   swap(device_reference< T > & x,
     device_reference< T > & y);

swaps the value of one `device_reference` with another. `x`
The first `device_reference` of interest. `y` The second
`device_reference` of interest.

**thrust::operator<<**

::

   template <typename T,
     typename charT,
     typename traits>
   std::basic_ostream< charT, traits > &
   operator<<(std::basic_ostream< charT, traits > & os,
     const device_reference< T > & y);

Writes to an output stream the value of a `device_reference`.

**Function Parameters**:

-  **os** The output stream.

-  **y** The `device_reference` to output.

**Returns**: os.

**thrust::malloc**

::

   template <typename DerivedPolicy>
   __host__ __device__ pointer< void, DerivedPolicy >
   malloc(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
     std::size_t n);

This version of `malloc` allocates untyped uninitialized
storage associated with a given system.

The following code snippet demonstrates how to use `malloc`
to allocate a range of memory associated with Thrust’s device
system.

::

   #include <thrust/memory.h>
   ...
   // allocate some memory with thrust::malloc
   const int N = 100;
   thrust::device_system_tag device_sys;
   thrust::pointer<void,thrust::device_space_tag> void_ptr = thrust::malloc(device_sys, N);

   // manipulate memory
   ...

   // deallocate void_ptr with thrust::free
   thrust::free(device_sys, void_ptr);

**Template Parameters**: **DerivedPolicy**: The name of the
derived execution policy.

**Function Parameters**:

-  **system** The Thrust system with which to associate the
   storage.

-  **n** The number of bytes of storage to allocate.

**Preconditions**: `DerivedPolicy` must be publically derived
from `thrust::execution_policy<DerivedPolicy>`.

**Returns**: If allocation succeeds, a pointer to the allocated
storage; a null pointer otherwise. The pointer must be
deallocated with `thrust::free`.

**See**:

-  free

-  device_malloc

**thrust::malloc**

::

   template <typename T,
     typename DerivedPolicy>
   __host__ __device__ pointer< T, DerivedPolicy >
   malloc(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
     std::size_t n);

This version of `malloc` allocates typed uninitialized
storage associated with a given system.

The following code snippet demonstrates how to use `malloc`
to allocate a range of memory to accomodate integers associated
with Thrust’s device system.

::

   #include <thrust/memory.h>
   ...
   // allocate storage for 100 ints with thrust::malloc
   const int N = 100;
   thrust::device_system_tag device_sys;
   thrust::pointer<int,thrust::device_system_tag> ptr = thrust::malloc<int>(device_sys, N);

   // manipulate memory
   ...

   // deallocate ptr with thrust::free
   thrust::free(device_sys, ptr);

**Template Parameters**: **DerivedPolicy**: The name of the
derived execution policy.

**Function Parameters**:

-  **system** The Thrust system with which to associate the
   storage.

-  **n** The number of elements of type `T` which the
   storage should accomodate.

**Preconditions**: `DerivedPolicy` must be publically derived
from `thrust::execution_policy<DerivedPolicy>`.

**Returns**: If allocation succeeds, a pointer to an allocation
large enough to accomodate `n` elements of type `T`; a null
pointer otherwise. The pointer must be deallocated with
`thrust::free`.

**See**:

-  free

-  device_malloc

**thrust::get_temporary_buffer**

::

   template <typename T,
     typename DerivedPolicy>
   __host__ __device__ thrust::pair< thrust::pointer< T, DerivedPolicy >, typename thrust::pointer< T, DerivedPolicy >::difference_type >
   get_temporary_buffer(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
     typename thrust::pointer< T, DerivedPolicy >::difference_type n);

`get_temporary_buffer` returns a pointer to storage
associated with a given Thrust system sufficient to store up to
`n` objects of type `T`. If not enough storage is available
to accomodate `n` objects, an implementation may return a
smaller buffer. The number of objects the returned buffer can
accomodate is also returned.

Thrust uses `get_temporary_buffer` internally when allocating
temporary storage required by algorithm implementations.

The storage allocated with `get_temporary_buffer` must be
returned to the system with `return_temporary_buffer`.

The following code snippet demonstrates how to use
`get_temporary_buffer` to allocate a range of memory to
accomodate integers associated with Thrust’s device system.

::

   #include <thrust/memory.h>
   ...
   // allocate storage for 100 ints with thrust::get_temporary_buffer
   const int N = 100;

   typedef thrust::pair<
     thrust::pointer<int,thrust::device_system_tag>,
     std::ptrdiff_t
   > ptr_and_size_t;

   thrust::device_system_tag device_sys;
   ptr_and_size_t ptr_and_size = thrust::get_temporary_buffer<int>(device_sys, N);

   // manipulate up to 100 ints
   for(int i = 0; i < ptr_and_size.second; ++i)
   {
     *ptr_and_size.first = i;
   }

   // deallocate storage with thrust::return_temporary_buffer
   thrust::return_temporary_buffer(device_sys, ptr_and_size.first);

**Template Parameters**: **DerivedPolicy**: The name of the
derived execution policy.

**Function Parameters**:

-  **system** The Thrust system with which to associate the
   storage.

-  **n** The requested number of objects of type `T` the
   storage should accomodate.

**Preconditions**: `DerivedPolicy` must be publically derived
from `thrust::execution_policy<DerivedPolicy>`.

**Returns**: A pair `p` such that `p.first` is a pointer to
the allocated storage and `p.second` is the number of
contiguous objects of type `T` that the storage can
accomodate. If no storage can be allocated, `p.first` if no
storage can be obtained. The storage must be returned to the
system using `return_temporary_buffer`.

**See**:

-  malloc

-  return_temporary_buffer

**thrust::free**

::

   template <typename DerivedPolicy,
     typename Pointer>
   __host__ __device__ void
   free(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
     Pointer ptr);

`free` deallocates the storage previously allocated by
`thrust::malloc`.

The following code snippet demonstrates how to use `free` to
deallocate a range of memory previously allocated with
`thrust::malloc`.

::

   #include <thrust/memory.h>
   ...
   // allocate storage for 100 ints with thrust::malloc
   const int N = 100;
   thrust::device_system_tag device_sys;
   thrust::pointer<int,thrust::device_system_tag> ptr = thrust::malloc<int>(device_sys, N);

   // mainpulate memory
   ...

   // deallocate ptr with thrust::free
   thrust::free(device_sys, ptr);

**Template Parameters**: **DerivedPolicy**: The name of the
derived execution policy.

**Function Parameters**:

-  **system** The Thrust system with which the storage is
   associated.

-  **ptr** A pointer previously returned by
   `thrust::malloc`. If `ptr` is null, `free` does
   nothing.

**Preconditions**: `ptr` shall have been returned by a
previous call to `thrust::malloc(system, n)` or
`thrust::malloc<T>(system, n)` for some type `T`.

**thrust::return_temporary_buffer**

::

   template <typename DerivedPolicy,
     typename Pointer>
   __host__ __device__ void
   return_temporary_buffer(const thrust::detail::execution_policy_base< DerivedPolicy > & system,
     Pointer p,
     std::ptrdiff_t n);

`return_temporary_buffer` deallocates storage associated with
a given Thrust system previously allocated by
`get_temporary_buffer`.

Thrust uses `return_temporary_buffer` internally when
deallocating temporary storage required by algorithm
implementations.

The following code snippet demonstrates how to use
`return_temporary_buffer` to deallocate a range of memory
previously allocated by `get_temporary_buffer`.

::

   #include <thrust/memory.h>
   ...
   // allocate storage for 100 ints with thrust::get_temporary_buffer
   const int N = 100;

   typedef thrust::pair<
     thrust::pointer<int,thrust::device_system_tag>,
     std::ptrdiff_t
   > ptr_and_size_t;

   thrust::device_system_tag device_sys;
   ptr_and_size_t ptr_and_size = thrust::get_temporary_buffer<int>(device_sys, N);

   // manipulate up to 100 ints
   for(int i = 0; i < ptr_and_size.second; ++i)
   {
     *ptr_and_size.first = i;
   }

   // deallocate storage with thrust::return_temporary_buffer
   thrust::return_temporary_buffer(device_sys, ptr_and_size.first);

**Template Parameters**: **DerivedPolicy**: The name of the
derived execution policy.

**Function Parameters**:

-  **system** The Thrust system with which the storage is
   associated.

-  **p** A pointer previously returned by
   `thrust::get_temporary_buffer`. If `ptr` is null,
   `return_temporary_buffer` does nothing.

**Preconditions**: `p` shall have been previously allocated
by `thrust::get_temporary_buffer`.

**See**:

-  free

-  get_temporary_buffer

**thrust::raw_pointer_cast**

::

   template <typename Pointer> __host__ __device__ thrust::detail::pointer_traits< Pointer >::raw_pointer raw_pointer_cast(Pointer ptr);

`raw_pointer_cast` creates a “raw” pointer from a
pointer-like type, simply returning the wrapped pointer, should
it exist.

**Function Parameters**: **ptr**: The pointer of interest.

**Returns**: `ptr.get()`, if the expression is well formed;
`ptr`, otherwise.

**See**: raw_reference_cast

**thrust::raw_reference_cast**

::

   template <typename T> __host__ __device__ detail::raw_reference< T >::type raw_reference_cast(T & ref);

`raw_reference_cast` creates a “raw” reference from a wrapped
reference type, simply returning the underlying reference,
should it exist.

If the argument is not a reference wrapper, the result is a
reference to the argument.

**Note**: There are two versions of `raw_reference_cast`. One
for `const` references, and one for non-\ `const`.

**Function Parameters**: **ref**: The reference of
interest.

**Returns**: `*thrust::raw_pointer_cast(&ref)`.

**See**: raw_pointer_cast

**thrust::raw_reference_cast**

::

   template <typename T> __host__ __device__ detail::raw_reference< constT >::type raw_reference_cast(const T & ref);

`raw_reference_cast` creates a “raw” reference from a wrapped
reference type, simply returning the underlying reference,
should it exist.

If the argument is not a reference wrapper, the result is a
reference to the argument.

**Note**: There are two versions of `raw_reference_cast`. One
for `const` references, and one for non-\ `const`.

**Function Parameters**: **ref**: The reference of
interest.

**Returns**: `*thrust::raw_pointer_cast(&ref)`.

**See**: raw_pointer_cast

Allocators
----------

**Allocators**

::

   template <typename Upstream>
   class
   thrust::device_ptr_memory_resource;

   template <typename T>
   class
   thrust::device_allocator;

   template <typename T>
   class
   thrust::device_malloc_allocator;

   template <typename T>
   class
   thrust::device_new_allocator;

   template <typename T,
     class MR>
   class
   thrust::mr::allocator;

   template <typename T,
     typename Upstream>
   class
   thrust::mr::stateless_resource_allocator;

   template <typename T,
     typename Pointer>
   using
   thrust::mr::polymorphic_allocator = see below;

   template <typename T,
     typename MR>
   __host__ __device__ bool
   thrust::mr::operator==(const allocator< T, MR > & lhs,
     const allocator< T, MR > & rhs);

   template <typename T,
     typename MR>
   __host__ __device__ bool
   thrust::mr::operator!=(const allocator< T, MR > & lhs,
     const allocator< T, MR > & rhs);

**Member Classes**

**thrust::device_ptr_memory_resource**

**Inherits From**:
`thrust::mr::memory_resource< device_ptr< void > >`

**thrust::device_allocator**

An allocator which creates new elements in memory accessible by
devices.

**Inherits From**:

-  `thrust::mr::stateless_resource_allocator< T, device_ptr_memory_resource< device_memory_resource > >`

-  `thrust::mr::allocator< T, Upstream >`

-  `thrust::mr::validator< MR >`

**thrust::device_malloc_allocator**

**thrust::device_new_allocator**

**thrust::mr::allocator**

**Inherits From**: `thrust::mr::validator< MR >`

**thrust::mr::stateless_resource_allocator**

**Inherits From**:

-  `thrust::mr::allocator< T, Upstream >`

-  `thrust::mr::validator< MR >`

**Types**

**thrust::mr::polymorphic_allocator**

::

   template <typename T,
     typename Pointer>
   using
   polymorphic_allocator = allocator< T, polymorphic_adaptor_resource< Pointer > >;

**Functions**

**thrust::mr::operator==**

::

   template <typename T,
     typename MR>
   __host__ __device__ bool
   operator==(const allocator< T, MR > & lhs,
     const allocator< T, MR > & rhs);

Compares the allocators for equality by comparing the
underlying memory resources.

**thrust::mr::operator!=**

::

   template <typename T,
     typename MR>
   __host__ __device__ bool
   operator!=(const allocator< T, MR > & lhs,
     const allocator< T, MR > & rhs);

Compares the allocators for inequality by comparing the
underlying memory resources.

Memory Resources
----------------

**Memory Resources**

::

   template <typename Upstream,
     typename Bookkeeper>
   class
   thrust::mr::disjoint_unsynchronized_pool_resource;

   template <typename Upstream,
     typename Bookkeeper>
   struct
   thrust::mr::disjoint_synchronized_pool_resource;

   template <typename Pointer = void *>
   class
   thrust::mr::memory_resource;

   class
   thrust::mr::memory_resource< void * >;

   class
   thrust::mr::new_delete_resource;

   template <typename Upstream>
   class
   thrust::mr::unsynchronized_pool_resource;

   struct
   thrust::mr::pool_options;

   template <typename Upstream>
   struct
   thrust::mr::synchronized_pool_resource;

typedef see below thrust::system::cpp::memory_resource;

typedef see below thrust::system::cpp::universal_memory_resource;

typedef see below thrust::system::cpp::universal_host_pinned_memory_resource;

typedef see below thrust::system::omp::memory_resource;

typedef see below thrust::system::omp::universal_memory_resource;

typedef see below thrust::system::omp::universal_host_pinned_memory_resource;

typedef see below thrust::system::tbb::memory_resource;

typedef see below thrust::system::tbb::universal_memory_resource;

typedef see below thrust::system::tbb::universal_host_pinned_memory_resource;

::

   template <typename T>
   using thrust::universal_ptr = see below;

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::disjoint_unsynchronized_pool_resource< Upstream, Bookkeeper > &
   thrust::mr::tls_disjoint_pool(Upstream * upstream = NULL,
     Bookkeeper * bookkeeper = NULL);

   template <typename Pointer>
   __host__ __device__ bool
   thrust::mr::operator==(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

   template <typename Pointer>
   __host__ __device__ bool
   thrust::mr::operator!=(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

   template <typename MR>
   __host__ MR * thrust::mr::get_global_resource();

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::unsynchronized_pool_resource< Upstream > &
   thrust::mr::tls_pool(Upstream * upstream = NULL);

**Member Classes**

**thrust::mr::disjoint_unsynchronized_pool_resource**

**Inherits From**:

-  `thrust::mr::memory_resource< Upstream::pointer >`

-  `thrust::mr::validator2< Upstream, Bookkeeper >`

**thrust::mr::disjoint_synchronized_pool_resource**

**Inherits From**:
`thrust::mr::memory_resource< Upstream::pointer >`

**thrust::mr::memory_resource**

**Inherited By**:

-  `thrust::mr::new_delete_resource`

-  `thrust::mr::polymorphic_adaptor_resource< Pointer >`

**thrust::mr::memory_resource< void * >**

**thrust::mr::new_delete_resource**

**Inherits From**:
`thrust::mr::memory_resource<>`

**thrust::mr::unsynchronized_pool_resource**

**Inherits From**:

-  `thrust::mr::memory_resource< Upstream::pointer >`

-  `thrust::mr::validator< Upstream >`

**thrust::mr::pool_options**

**thrust::mr::synchronized_pool_resource**

**Inherits From**:
`thrust::mr::memory_resource< Upstream::pointer >`

**Types**

**thrust::system::cpp::memory_resource**

`typedef detail::native_resourcememory_resource;` The memory
resource for the Standard C++ system. Uses
`mr::new_delete_resource` and tags it with `cpp::pointer`.

**thrust::system::cpp::universal_memory_resource**

`typedef detail::universal_native_resourceuniversal_memory_resource;`
The unified memory resource for the Standard C++ system. Uses
`mr::new_delete_resource` and tags it with
`cpp::universal_pointer`.

**thrust::system::cpp::universal_host_pinned_memory_resource**

`typedef detail::native_resourceuniversal_host_pinned_memory_resource;`
An alias for `cpp::universal_memory_resource`.

**thrust::system::omp::memory_resource**

`typedef detail::native_resourcememory_resource;` The memory
resource for the OpenMP system. Uses
`mr::new_delete_resource` and tags it with `omp::pointer`.

**thrust::system::omp::universal_memory_resource**

`typedef detail::universal_native_resourceuniversal_memory_resource;`
The unified memory resource for the OpenMP system. Uses
`mr::new_delete_resource` and tags it with
`omp::universal_pointer`.

**thrust::system::omp::universal_host_pinned_memory_resource**

`typedef detail::native_resourceuniversal_host_pinned_memory_resource;`
An alias for `omp::universal_memory_resource`.

**thrust::system::tbb::memory_resource**

`typedef detail::native_resourcememory_resource;` The memory
resource for the TBB system. Uses `mr::new_delete_resource`
and tags it with `tbb::pointer`.

**thrust::system::tbb::universal_memory_resource**

`typedef detail::universal_native_resourceuniversal_memory_resource;`
The unified memory resource for the TBB system. Uses
`mr::new_delete_resource` and tags it with
`tbb::universal_pointer`.

**thrust::system::tbb::universal_host_pinned_memory_resource**

`typedef detail::native_resourceuniversal_host_pinned_memory_resource;`
An alias for `tbb::universal_memory_resource`.

**thrust::universal_ptr**

::

   template <typename T>
   using universal_ptr = thrust::system::__THRUST_DEVICE_SYSTEM_NAMESPACE::universal_pointer< T >;

`universal_ptr` stores a pointer to an object allocated in
memory accessible to both hosts and devices.

Algorithms dispatched with this type of pointer will be
dispatched to either host or device, depending on which backend
you are using. Explicit policies (`thrust::device`, etc) can
be used to specify where an algorithm should be run.

`universal_ptr` has pointer semantics: it may be dereferenced
safely from both hosts and devices and may be manipulated with
pointer arithmetic.

`universal_ptr` can be created with `universal_allocator`
or by explicitly calling its constructor with a raw pointer.

The raw pointer encapsulated by a `universal_ptr` may be
obtained by either its `get` method or the
`raw_pointer_cast` free function.

**Note**: `universal_ptr` is not a smart pointer; it is the
programmer’s responsibility to deallocate memory pointed to by
`universal_ptr`.

**See**:

-  host_ptr For the documentation of the complete interface
   which is shared by `universal_ptr`.

-  raw_pointer_cast

**Functions**

**thrust::mr::tls_disjoint_pool**

::

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::disjoint_unsynchronized_pool_resource< Upstream, Bookkeeper > &
   tls_disjoint_pool(Upstream * upstream = NULL,
     Bookkeeper * bookkeeper = NULL);

Potentially constructs, if not yet created, and then returns
the address of a thread-local
`disjoint_unsynchronized_pool_resource`,

**Template Parameters**:

-  **Upstream** the first template argument to the pool
   template

-  **Bookkeeper** the second template argument to the pool
   template

**Function Parameters**:

-  **upstream** the first argument to the constructor, if
   invoked

-  **bookkeeper** the second argument to the constructor,
   if invoked

**thrust::mr::operator==**

::

   template <typename Pointer>
   __host__ __device__ bool
   operator==(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

Compares the memory resources for equality, first by identity,
then by `is_equal`.

**thrust::mr::operator!=**

::

   template <typename Pointer>
   __host__ __device__ bool
   operator!=(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

Compares the memory resources for inequality, first by
identity, then by `is_equal`.

**thrust::mr::get_global_resource**

::

   template <typename MR>
   __host__ MR *
   get_global_resource();

Returns a global instance of `MR`, created as a function
local static variable.

**Template Parameters**: **MR**: type of a memory resource
to get an instance from. Must be `DefaultConstructible`.

**Returns**: a pointer to a global instance of `MR`.

**thrust::mr::tls_pool**

::

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::unsynchronized_pool_resource< Upstream > &
   tls_pool(Upstream * upstream = NULL);

Potentially constructs, if not yet created, and then returns
the address of a thread-local `unsynchronized_pool_resource`,

**Template Parameters**: **Upstream**: the template
argument to the pool template

**Function Parameters**: **upstream**: the argument to the
constructor, if invoked

Numerics
========
Complex Numbers
---------------

**Memory Resources**

::

   template <typename Upstream,
     typename Bookkeeper>
   class
   thrust::mr::disjoint_unsynchronized_pool_resource;

   template <typename Upstream,
     typename Bookkeeper>
   struct
   thrust::mr::disjoint_synchronized_pool_resource;

   template <typename Pointer = void *>
   class
   thrust::mr::memory_resource;

   class
   thrust::mr::memory_resource< void * >;

   class
   thrust::mr::new_delete_resource;

   template <typename Upstream>
   class
   thrust::mr::unsynchronized_pool_resource;

   struct
   thrust::mr::pool_options;

   template <typename Upstream>
   struct
   thrust::mr::synchronized_pool_resource;

typedef see below thrust::system::cpp::memory_resource;

typedef see below thrust::system::cpp::universal_memory_resource;

typedef see below thrust::system::cpp::universal_host_pinned_memory_resource;

typedef see below thrust::system::omp::memory_resource;

typedef see below thrust::system::omp::universal_memory_resource;

typedef see below thrust::system::omp::universal_host_pinned_memory_resource;

typedef see below thrust::system::tbb::memory_resource;

typedef see below thrust::system::tbb::universal_memory_resource;

typedef see below thrust::system::tbb::universal_host_pinned_memory_resource;

::

   template <typename T> using thrust::universal_ptr = see below;

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::disjoint_unsynchronized_pool_resource< Upstream, Bookkeeper > &
   thrust::mr::tls_disjoint_pool(Upstream * upstream = NULL,
     Bookkeeper * bookkeeper = NULL);

   template <typename Pointer>
   __host__ __device__ bool
   thrust::mr::operator==(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

   template <typename Pointer>
   __host__ __device__ bool
   thrust::mr::operator!=(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

   template <typename MR>
   __host__ MR *
   thrust::mr::get_global_resource();

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::unsynchronized_pool_resource< Upstream > &
   thrust::mr::tls_pool(Upstream * upstream = NULL);

**Member Classes**

**thrust::mr::disjoint_unsynchronized_pool_resource**

**Inherits From**:

-  `thrust::mr::memory_resource< Upstream::pointer >`

-  `thrust::mr::validator2< Upstream, Bookkeeper >`

**thrust::mr::disjoint_synchronized_pool_resource**

**Inherits From**:
`thrust::mr::memory_resource< Upstream::pointer >`

**thrust::mr::memory_resource**

**Inherited By**:

-  `thrust::mr::new_delete_resource`

-  `thrust::mr::polymorphic_adaptor_resource< Pointer >`

**thrust::mr::memory_resource< void * >**

**thrust::mr::new_delete_resource**

**Inherits From**:
`thrust::mr::memory_resource<>`

**thrust::mr::unsynchronized_pool_resource**

**Inherits From**:

-  `thrust::mr::memory_resource< Upstream::pointer >`

-  `thrust::mr::validator< Upstream >`

**thrust::mr::pool_options**

**thrust::mr::synchronized_pool_resource**

**Inherits From**:
`thrust::mr::memory_resource< Upstream::pointer >`

**Types**

**thrust::system::cpp::memory_resource**

`typedef detail::native_resourcememory_resource;` The memory
resource for the Standard C++ system. Uses
`mr::new_delete_resource` and tags it with `cpp::pointer`.

**thrust::system::cpp::universal_memory_resource**

`typedef detail::universal_native_resourceuniversal_memory_resource;`
The unified memory resource for the Standard C++ system. Uses
`mr::new_delete_resource` and tags it with
`cpp::universal_pointer`.

**thrust::system::cpp::universal_host_pinned_memory_resource**

`typedef detail::native_resourceuniversal_host_pinned_memory_resource;`
An alias for `cpp::universal_memory_resource`.

**thrust::system::omp::memory_resource**

`typedef detail::native_resourcememory_resource;` The memory
resource for the OpenMP system. Uses
`mr::new_delete_resource` and tags it with `omp::pointer`.

**thrust::system::omp::universal_memory_resource**

`typedef detail::universal_native_resourceuniversal_memory_resource;`
The unified memory resource for the OpenMP system. Uses
`mr::new_delete_resource` and tags it with
`omp::universal_pointer`.

**thrust::system::omp::universal_host_pinned_memory_resource**

`typedef detail::native_resourceuniversal_host_pinned_memory_resource;`
An alias for `omp::universal_memory_resource`.

**thrust::system::tbb::memory_resource**

`typedef detail::native_resourcememory_resource;` The memory
resource for the TBB system. Uses `mr::new_delete_resource`
and tags it with `tbb::pointer`.

**thrust::system::tbb::universal_memory_resource**

`typedef detail::universal_native_resourceuniversal_memory_resource;`
The unified memory resource for the TBB system. Uses
`mr::new_delete_resource` and tags it with
`tbb::universal_pointer`.

**thrust::system::tbb::universal_host_pinned_memory_resource**

`typedef detail::native_resourceuniversal_host_pinned_memory_resource;`
An alias for `tbb::universal_memory_resource`.

**thrust::universal_ptr**

::

   template <typename T>
   using universal_ptr = thrust::system::__THRUST_DEVICE_SYSTEM_NAMESPACE::universal_pointer< T >;

`universal_ptr` stores a pointer to an object allocated in
memory accessible to both hosts and devices.

Algorithms dispatched with this type of pointer will be
dispatched to either host or device, depending on which backend
you are using. Explicit policies (`thrust::device`, etc) can
be used to specify where an algorithm should be run.

`universal_ptr` has pointer semantics: it may be dereferenced
safely from both hosts and devices and may be manipulated with
pointer arithmetic.

`universal_ptr` can be created with `universal_allocator`
or by explicitly calling its constructor with a raw pointer.

The raw pointer encapsulated by a `universal_ptr` may be
obtained by either its `get` method or the
`raw_pointer_cast` free function.

**Note**: `universal_ptr` is not a smart pointer; it is the
programmer’s responsibility to deallocate memory pointed to by
`universal_ptr`.

**See**:

-  host_ptr For the documentation of the complete interface
   which is shared by `universal_ptr`.

-  raw_pointer_cast

**Functions**

**thrust::mr::tls_disjoint_pool**

::

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::disjoint_unsynchronized_pool_resource< Upstream, Bookkeeper > &
   tls_disjoint_pool(Upstream * upstream = NULL,
     Bookkeeper * bookkeeper = NULL);

Potentially constructs, if not yet created, and then returns
the address of a thread-local
`disjoint_unsynchronized_pool_resource`,

**Template Parameters**:

-  **Upstream** the first template argument to the pool
   template

-  **Bookkeeper** the second template argument to the pool
   template

**Function Parameters**:

-  **upstream** the first argument to the constructor, if
   invoked

-  **bookkeeper** the second argument to the constructor,
   if invoked

**thrust::mr::operator==**

::

   template <typename Pointer>
   __host__ __device__ bool
   operator==(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

Compares the memory resources for equality, first by identity,
then by `is_equal`.

**thrust::mr::operator!=**

::

   template <typename Pointer>
   __host__ __device__ bool
   operator!=(const memory_resource< Pointer > & lhs,
     const memory_resource< Pointer > & rhs);

Compares the memory resources for inequality, first by
identity, then by `is_equal`.

**thrust::mr::get_global_resource**

::

   template <typename MR> __host__ MR * get_global_resource();

Returns a global instance of `MR`, created as a function
local static variable.

**Template Parameters**: **MR**: type of a memory resource
to get an instance from. Must be `DefaultConstructible`.

**Returns**: a pointer to a global instance of `MR`.

**thrust::mr::tls_pool**

::

   template <typename Upstream,
     typename Bookkeeper>
   __host__ thrust::mr::unsynchronized_pool_resource< Upstream > &
   tls_pool(Upstream * upstream = NULL);

Potentially constructs, if not yet created, and then returns
the address of a thread-local `unsynchronized_pool_resource`,

**Template Parameters**: **Upstream**: the template
argument to the pool template

**Function Parameters**: **upstream**: the argument to the
constructor, if invoked

Parallel Execution Policies
===========================

**Parallel Execution Policies**

::

   template <typename DerivedPolicy>
   struct
   thrust::host_execution_policy;

   template <typename DerivedPolicy>
   struct
   thrust::device_execution_policy;

   static const detail::host_t thrust::host;

   THRUST_INLINE_CONSTANT detail::device_t thrust::device;

**Member Classes**

**thrust::host_execution_policy**

**Inherits From**:
`thrust::system::__THRUST_HOST_SYSTEM_NAMESPACE::execution_policy< DerivedPolicy >`

**thrust::device_execution_policy**

**Inherits From**:
`thrust::system::__THRUST_DEVICE_SYSTEM_NAMESPACE::execution_policy< DerivedPolicy >`

**Variables**

**thrust::host**

`static const detail::host_t host;` `thrust::host` is the
default parallel execution policy associated with Thrust’s host
backend system configured by the `THRUST_HOST_SYSTEM` macro.

Instead of relying on implicit algorithm dispatch through
iterator system tags, users may directly target algorithm
dispatch at Thrust’s host system by providing `thrust::host`
as an algorithm parameter.

Explicit dispatch can be useful in avoiding the introduction of
data copies into containers such as `thrust::host_vector`.

Note that even though `thrust::host` targets the host CPU, it
is a parallel execution policy. That is, the order that an
algorithm invokes functors or dereferences iterators is not
defined.

The type of `thrust::host` is implementation-defined.

The following code snippet demonstrates how to use
`thrust::host` to explicitly dispatch an invocation of
`thrust::for_each` to the host backend system:

::

   #include <thrust/for_each.h>
   #include <thrust/execution_policy.h>
   #include <cstdio>

   struct printf_functor
   {
     __host__ __device__
     void operator()(int x)
     {
    printf("%d\n", x);
     }
   };
   ...
   int vec(3);
   vec[0] = 0; vec[1] = 1; vec[2] = 2;

   thrust::for_each(thrust::host, vec.begin(), vec.end(), printf_functor());

   // 0 1 2 is printed to standard output in some unspecified order

**See**:

-  `host_execution_policy`

-  thrust::device

**thrust::device**

`THRUST_INLINE_CONSTANT detail::device_t device;`
`thrust::device` is the default parallel execution policy
associated with Thrust’s device backend system configured by
the `THRUST_DEVICE_SYSTEM` macro.

Instead of relying on implicit algorithm dispatch through
iterator system tags, users may directly target algorithm
dispatch at Thrust’s device system by providing
`thrust::device` as an algorithm parameter.

Explicit dispatch can be useful in avoiding the introduction of
data copies into containers such as `thrust::device_vector`
or to avoid wrapping e.g. raw pointers allocated by the CUDA
API with types such as `thrust::device_ptr`.

The user must take care to guarantee that the iterators
provided to an algorithm are compatible with the device backend
system. For example, raw pointers allocated by `std::malloc`
typically cannot be dereferenced by a GPU. For this reason, raw
pointers allocated by host APIs should not be mixed with a
`thrust::device` algorithm invocation when the device backend
is CUDA.

The type of `thrust::device` is implementation-defined.

The following code snippet demonstrates how to use
`thrust::device` to explicitly dispatch an invocation of
`thrust::for_each` to the device backend system:

::

   #include <thrust/for_each.h>
   #include <thrust/device_vector.h>
   #include <thrust/execution_policy.h>
   #include <cstdio>

   struct printf_functor
   {
     __host__ __device__
     void operator()(int x)
     {
    printf("%d\n", x);
     }
   };
   ...
   thrust::device_vector<int> vec(3);
   vec[0] = 0; vec[1] = 1; vec[2] = 2;

   thrust::for_each(thrust::device, vec.begin(), vec.end(), printf_functor());

   // 0 1 2 is printed to standard output in some unspecified order

**See**:

-  `host_execution_policy`

-  thrust::device

Random Number Generation
========================

-  `Random Number Engines with Predefined Parameters`

-  `Random Number Distributions Class Templates`

-  `Random Number Engine Adaptor Class Templates`

-  `Random Number Engine Class Templates`

::

   /* thrust::random is the namespace which contains random
            number engine class templates, random number engine adaptor
            class templates, engines with predefined parameters, and random
            number distribution class templates. They are provided in a
            separate namespace for import convenience but are also aliased
            in the top-level thrust namespace for easy access.*/
   namespace thrust::random {… }

Random Number Engines with Predefined Parameters
------------------------------------------------

**Random Number Engines with Predefined Parameters**

::

   /* A random number engine with predefined parameters which
   implements the RANLUX level-3 random number generation algorithm. */
   typedef see below thrust::random::ranlux24;

   /* A random number engine with predefined parameters which
   implements the RANLUX level-4 random number generation algorithm. */
   typedef see below thrust::random::ranlux48;

   /* A random number engine with predefined parameters which
   implements L'Ecuyer's 1996 three-component Tausworthe random
   number generator. */
   typedef see below thrust::random::taus88;

   /* An implementation-defined "default" random number engine. */
   typedef see below thrust::random::default_random_engine;

   /* A random number engine with predefined parameters which implements
    a version of the Minimal Standard random number generation algorithm. */
   typedef see below thrust::random::minstd_rand0;

   /* A random number engine with predefined parameters which implements
    a version of the Minimal Standard random number generation algorithm. */
   typedef see below thrust::random::minstd_rand;

   /* A random number engine with predefined parameters which implements
    the base engine of the ranlux24 random number engine. */
   typedef see below thrust::random::ranlux24_base;

   /* A random number engine with predefined parameters which implements
    the base engine of the ranlux48 random number engine. */
   typedef see below thrust::random::ranlux48_base;

**Types**

**thrust::random::ranlux24**

`typedef discard_block_engine< ranlux24_base, 223, 23 >ranlux24;`

A random number engine with predefined parameters which
implements the RANLUX level-3 random number generation
algorithm.

**Note**: The 10000th consecutive invocation of a
default-constructed object of type `ranlux24` shall produce
the value `9901578` .

**thrust::random::ranlux48**

`typedef discard_block_engine< ranlux48_base, 389, 11 >ranlux48;`

A random number engine with predefined parameters which
implements the RANLUX level-4 random number generation
algorithm.

**Note**: The 10000th consecutive invocation of a
default-constructed object of type `ranlux48` shall produce
the value `88229545517833` .

**thrust::random::taus88**

`typedef xor_combine_engine< linear_feedback_shift_engine< thrust::detail::uint32_t, 32u, 31u, 13u, 12u >`,
         `0, xor_combine_engine< linear_feedback_shift_engine< thrust::detail::uint32_t, 32u, 29u, 2u, 4u >,`
         ` 0, linear_feedback_shift_engine< thrust::detail::uint32_t, 32u, 28u, 3u, 17u >, 0 >, 0 >taus88;`

A random number engine with predefined parameters which
implements L’Ecuyer’s 1996 three-component Tausworthe random
number generator.

**Note**: The 10000th consecutive invocation of a
default-constructed object of type `taus88` shall produce the
value `3535848941` .

**thrust::random::default_random_engine**

`typedef minstd_randdefault_random_engine;`

An implementation-defined “default” random number engine.

**Note**: `default_random_engine` is currently an alias for
`minstd_rand`, and may change in a future version.

**thrust::random::minstd_rand0**

`typedef linear_congruential_engine< thrust::detail::uint32_t, 16807, 0, 2147483647 >minstd_rand0;`

A random number engine with predefined parameters which
implements a version of the Minimal Standard random number
generation algorithm.

**Note**: The 10000th consecutive invocation of a
default-constructed object of type `minstd_rand0` shall
produce the value `1043618065` .

**thrust::random::minstd_rand**

`typedef linear_congruential_engine< thrust::detail::uint32_t, 48271, 0, 2147483647 >minstd_rand;`

A random number engine with predefined parameters which
implements a version of the Minimal Standard random number
generation algorithm.

**Note**: The 10000th consecutive invocation of a
default-constructed object of type `minstd_rand` shall
produce the value `399268537` .

**thrust::random::ranlux24_base**

`typedef subtract_with_carry_engine< thrust::detail::uint32_t, 24, 10, 24 >ranlux24_base;`

A random number engine with predefined parameters which
implements the base engine of the `ranlux24` random number
engine.

**Note**: The 10000th consecutive invocation of a
default-constructed object of type `ranlux24_base` shall
produce the value `7937952` .

**thrust::random::ranlux48_base**

`typedef subtract_with_carry_engine< thrust::detail::uint64_t, 48, 5, 12 >ranlux48_base;`

A random number engine with predefined parameters which
implements the base engine of the `ranlux48` random number
engine.

**Note**: The 10000th consecutive invocation of a
default-constructed object of type `ranlux48_base` shall
produce the value `192113843633948` .

Random Number Distributions Class Templates
-------------------------------------------

**Random Number Distributions Class Templates**

::

   /* A normal_distribution random number distribution produces floating point Normally
    distributed random numbers. */
   template <typename RealType = double>
   class thrust::random::normal_distribution;

   /* A uniform_int_distribution random number distribution produces signed or unsigned
    integer uniform random numbers from a given range. */
   template <typename IntType = int>
   class thrust::random::uniform_int_distribution;

   /* A uniform_real_distribution random number distribution produces floating point
    uniform random numbers from a half-open interval. */
   template <typename RealType = double>
   class thrust::random::uniform_real_distribution;

   template <typename RealType>
   __host__ __device__ bool
   thrust::random::operator==(const normal_distribution< RealType > & lhs,
     const normal_distribution< RealType > & rhs);

   template <typename RealType>
   __host__ __device__ bool
   thrust::random::operator!=(const normal_distribution< RealType > & lhs,
     const normal_distribution< RealType > & rhs);

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
     const normal_distribution< RealType > & d);

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
     normal_distribution< RealType > & d);

   template <typename IntType>
   __host__ __device__ bool
   thrust::random::operator==(const uniform_int_distribution< IntType > & lhs,
     const uniform_int_distribution< IntType > & rhs);

   template <typename IntType>
   __host__ __device__ bool
   thrust::random::operator!=(const uniform_int_distribution< IntType > & lhs,
     const uniform_int_distribution< IntType > & rhs);

   template <typename IntType,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
     const uniform_int_distribution< IntType > & d);

   template <typename IntType,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
     uniform_int_distribution< IntType > & d);

   template <typename RealType>
   __host__ __device__ bool
   thrust::random::operator==(const uniform_real_distribution< RealType > & lhs,
     const uniform_real_distribution< RealType > & rhs);

   template <typename RealType>
   __host__ __device__ bool
   thrust::random::operator!=(const uniform_real_distribution< RealType > & lhs,
     const uniform_real_distribution< RealType > & rhs);

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
     const uniform_real_distribution< RealType > & d);

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
     uniform_real_distribution< RealType > & d);

**Member Classes**

**thrust::random::normal_distribution**

A `normal_distribution` random number distribution produces
floating point Normally distributed random numbers.

**thrust::random::uniform_int_distribution**

A `uniform_int_distribution` random number distribution
produces signed or unsigned integer uniform random numbers from
a given range.

**thrust::random::uniform_real_distribution**

A `uniform_real_distribution` random number distribution
produces floating point uniform random numbers from a half-open
interval.

**Functions**

**thrust::random::operator==**

::

   template <typename RealType>
   __host__ __device__ bool
   operator==(const normal_distribution< RealType > & lhs,
     const normal_distribution< RealType > & rhs);

This function checks two `normal_distributions` for equality.

**Function Parameters**:

-  **lhs** The first `normal_distribution` to test.

-  **rhs** The second `normal_distribution` to test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename RealType>
   __host__ __device__ bool
   operator!=(const normal_distribution< RealType > & lhs,
     const normal_distribution< RealType > & rhs);

This function checks two `normal_distributions` for
inequality.

**Function Parameters**:

-  **lhs** The first `normal_distribution` to test.

-  **rhs** The second `normal_distribution` to test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const normal_distribution< RealType > & d);

This function streams a
`normal_distribution`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **d** The `normal_distribution` to stream out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     normal_distribution< RealType > & d);

This function streams a
`normal_distribution`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **d** The `normal_distribution` to stream in.

**Returns**: `is`

**thrust::random::operator==**

::

   template <typename IntType>
   __host__ __device__ bool
   operator==(const uniform_int_distribution< IntType > & lhs,
     const uniform_int_distribution< IntType > & rhs);

This function checks two `uniform_int_distributions` for
equality.

**Function Parameters**:

-  **lhs** The first `uniform_int_distribution` to test.

-  **rhs** The second `uniform_int_distribution` to test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename IntType>
   __host__ __device__ bool
   operator!=(const uniform_int_distribution< IntType > & lhs,
     const uniform_int_distribution< IntType > & rhs);

This function checks two `uniform_int_distributions` for
inequality.

**Function Parameters**:

-  **lhs** The first `uniform_int_distribution` to test.

-  **rhs** The second `uniform_int_distribution` to test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename IntType,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const uniform_int_distribution< IntType > & d);

This function streams a
`uniform_int_distribution`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **d** The `uniform_int_distribution` to stream out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename IntType,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     uniform_int_distribution< IntType > & d);

This function streams a
`uniform_int_distribution`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **d** The `uniform_int_distribution` to stream in.

**Returns**: `is`

**thrust::random::operator==**

::

   template <typename RealType>
   __host__ __device__ bool
   operator==(const uniform_real_distribution< RealType > & lhs,
     const uniform_real_distribution< RealType > & rhs);

This function checks two `uniform_real_distributions` for
equality.

**Function Parameters**:

-  **lhs** The first `uniform_real_distribution` to test.

-  **rhs** The second `uniform_real_distribution` to
   test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename RealType>
   __host__ __device__ bool
   operator!=(const uniform_real_distribution< RealType > & lhs,
     const uniform_real_distribution< RealType > & rhs);

This function checks two `uniform_real_distributions` for
inequality.

**Function Parameters**:

-  **lhs** The first `uniform_real_distribution` to test.

-  **rhs** The second `uniform_real_distribution` to
   test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const uniform_real_distribution< RealType > & d);

This function streams a
`uniform_real_distribution`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **d** The `uniform_real_distribution` to stream out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename RealType,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     uniform_real_distribution< RealType > & d);

This function streams a
`uniform_real_distribution`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **d** The `uniform_real_distribution` to stream in.

**Returns**: `is`

Random Number Engine Adaptor Class Templates
--------------------------------------------

**Random Number Engine Adaptor Class Templates**

::

   /* A discard_block_engine adapts an existing base random number engine
    and produces random values by discarding some of the values returned by
    its base engine. Each cycle of the compound engine begins by returning
    r values successively produced by the base engine and ends by discarding
    p-r such values. The engine's state is the state of its base  engine
    followed by the number of calls to operator() that have occurred since
    the beginning of the current cycle. */
   template <typename Engine,
     size_t p,
     size_t r>
   class thrust::random::discard_block_engine;

   /* An xor_combine_engine adapts two existing base random number engines
   and produces random values by combining the values produced by each. */
   template <typename Engine1,
     size_t s1,
     typename Engine2,
     size_t s2 = 0u>
   class thrust::random::xor_combine_engine;

   template <typename Engine,
     size_t p,
     size_t r>
   __host__ __device__ bool
   thrust::random::operator==(const discard_block_engine< Engine, p, r > & lhs,
     const discard_block_engine< Engine, p, r > & rhs);

   template <typename Engine,
     size_t p,
     size_t r>
   __host__ __device__ bool
   thrust::random::operator!=(const discard_block_engine< Engine, p, r > & lhs,
     const discard_block_engine< Engine, p, r > & rhs);

   template <typename Engine,
     size_t p,
     size_t r,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
     const discard_block_engine< Engine, p, r > & e);

   template <typename Engine,
     size_t p,
     size_t r,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
     discard_block_engine< Engine, p, r > & e);

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_>
   __host__ __device__ bool
   thrust::random::operator==(const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & lhs,
     const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & rhs);

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_>
   __host__ __device__ bool
   thrust::random::operator!=(const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & lhs,
     const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & rhs);

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
     const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & e);

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
     xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & e);

**Member Classes**

**thrust::random::discard_block_engine**

A `discard_block_engine` adapts an existing base random
number engine and produces random values by discarding some of
the values returned by its base engine. Each cycle of the
compound engine begins by returning `r` values successively
produced by the base engine and ends by discarding `p-r` such
values. The engine’s state is the state of its base engine
followed by the number of calls to `operator()` that have
occurred since the beginning of the current cycle.

**thrust::random::xor_combine_engine**

An `xor_combine_engine` adapts two existing base random
number engines and produces random values by combining the
values produced by each.

**Functions**

**thrust::random::operator==**

::

   template <typename Engine,
     size_t p,
     size_t r>
   __host__ __device__ bool
   operator==(const discard_block_engine< Engine, p, r > & lhs,
     const discard_block_engine< Engine, p, r > & rhs);

This function checks two `discard_block_engines` for
equality.

**Function Parameters**:

-  **lhs** The first `discard_block_engine` to test.

-  **rhs** The second `discard_block_engine` to test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename Engine,
     size_t p,
     size_t r>
   __host__ __device__ bool
   operator!=(const discard_block_engine< Engine, p, r > & lhs,
     const discard_block_engine< Engine, p, r > & rhs);

This function checks two `discard_block_engines` for
inequality.

**Function Parameters**:

-  **lhs** The first `discard_block_engine` to test.

-  **rhs** The second `discard_block_engine` to test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename Engine,
     size_t p,
     size_t r,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const discard_block_engine< Engine, p, r > & e);

This function streams a
`discard_block_engine`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **e** The `discard_block_engine` to stream out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename Engine,
     size_t p,
     size_t r,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     discard_block_engine< Engine, p, r > & e);

This function streams a
`discard_block_engine`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **e** The `discard_block_engine` to stream in.

**Returns**: `is`

**thrust::random::operator==**

::

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_>
   __host__ __device__ bool
   operator==(const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & lhs,
     const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & rhs);

This function checks two `xor_combine_engines` for equality.

**Function Parameters**:

-  **lhs** The first `xor_combine_engine` to test.

-  **rhs** The second `xor_combine_engine` to test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_>
   __host__ __device__ bool
   operator!=(const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & lhs,
     const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & rhs);

This function checks two `xor_combine_engines` for
inequality.

**Function Parameters**:

-  **lhs** The first `xor_combine_engine` to test.

-  **rhs** The second `xor_combine_engine` to test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & e);

This function streams a
`xor_combine_engine`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **e** The `xor_combine_engine` to stream out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename Engine1_,
     size_t s1_,
     typename Engine2_,
     size_t s2_,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     xor_combine_engine< Engine1_, s1_, Engine2_, s2_ > & e);

This function streams a
`xor_combine_engine`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **e** The `xor_combine_engine` to stream in.

**Returns**: `is`

Random Number Engine Class Templates
------------------------------------

**Random Number Engine Class Templates**

::

   /* A linear_congruential_engine random number engine produces unsigned integer
   random numbers using a linear congruential random number generation algorithm. */
   template <typename UIntType,
   UIntType a,
   UIntType c,
   UIntType m>
   class thrust::random::linear_congruential_engine;

   /* A linear_feedback_shift_engine random number engine produces unsigned integer
   random values using a linear feedback shift random number generation algorithm. */
   template <typename UIntType,
   size_t w,
   size_t k,
   size_t q,
   size_t s>
   class thrust::random::linear_feedback_shift_engine;

   /* A subtract_with_carry_engine random number engine produces unsigned integer
   random numbers using the subtract with carry algorithm of Marsaglia & Zaman. */
   template <typename UIntType,
   size_t w,
   size_t s,
   size_t r>
   class thrust::random::subtract_with_carry_engine;

   template <typename UIntType_,
   UIntType_ a_,
   UIntType_ c_,
   UIntType_ m_>
   __host__ __device__ bool
   thrust::random::operator==(const linear_congruential_engine< UIntType_, a_, c_, m_ > & lhs,
   const linear_congruential_engine< UIntType_, a_, c_, m_ > & rhs);

   template <typename UIntType_,
   UIntType_ a_,
   UIntType_ c_,
   UIntType_ m_>
   __host__ __device__ bool
   thrust::random::operator!=(const linear_congruential_engine< UIntType_, a_, c_, m_ > & lhs,
   const linear_congruential_engine< UIntType_, a_, c_, m_ > & rhs);

   template <typename UIntType_,
   UIntType_ a_,
   UIntType_ c_,
   UIntType_ m_,
   typename CharT,
   typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
   const linear_congruential_engine< UIntType_, a_, c_, m_ > & e);

   template <typename UIntType_,
   UIntType_ a_,
   UIntType_ c_,
   UIntType_ m_,
   typename CharT,
   typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
   linear_congruential_engine< UIntType_, a_, c_, m_ > & e);

   template <typename UIntType_,
   size_t w_,
   size_t k_,
   size_t q_,
   size_t s_>
   __host__ __device__ bool
   thrust::random::operator==(const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & lhs,
   const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & rhs);

   template <typename UIntType_,
   size_t w_,
   size_t k_,
   size_t q_,
   size_t s_>
   __host__ __device__ bool
   thrust::random::operator!=(const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & lhs,
   const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & rhs);

   template <typename UIntType_,
   size_t w_,
   size_t k_,
   size_t q_,
   size_t s_,
   typename CharT,
   typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
   const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & e);

   template <typename UIntType_,
   size_t w_,
   size_t k_,
   size_t q_,
   size_t s_,
   typename CharT,
   typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
   linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & e);

   template <typename UIntType_,
   size_t w_,
   size_t s_,
   size_t r_>
   __host__ __device__ bool
   thrust::random::operator==(const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & lhs,
   const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & rhs);

   template <typename UIntType_,
   size_t w_,
   size_t s_,
   size_t r_>
   __host__ __device__ bool
   thrust::random::operator!=(const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & lhs,
   const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & rhs);

   template <typename UIntType_,
   size_t w_,
   size_t s_,
   size_t r_,
   typename CharT,
   typename Traits>
   std::basic_ostream< CharT, Traits > &
   thrust::random::operator<<(std::basic_ostream< CharT, Traits > & os,
   const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & e);

   template <typename UIntType_,
   size_t w_,
   size_t s_,
   size_t r_,
   typename CharT,
   typename Traits>
   std::basic_istream< CharT, Traits > &
   thrust::random::operator>>(std::basic_istream< CharT, Traits > & is,
   subtract_with_carry_engine< UIntType_, w_, s_, r_ > & e);

**Member Classes**

**thrust::random::linear_congruential_engine**

A `linear_congruential_engine` random number engine produces
unsigned integer random numbers using a linear congruential
random number generation algorithm.

**thrust::random::linear_feedback_shift_engine**

A `linear_feedback_shift_engine` random number engine
produces unsigned integer random values using a linear feedback
shift random number generation algorithm.

**thrust::random::subtract_with_carry_engine**

A `subtract_with_carry_engine` random number engine produces
unsigned integer random numbers using the subtract with carry
algorithm of Marsaglia & Zaman.

**Functions**

**thrust::random::operator==**

::

   template <typename UIntType_,
     UIntType_ a_,
     UIntType_ c_,
     UIntType_ m_>
   __host__ __device__ bool
   operator==(const linear_congruential_engine< UIntType_, a_, c_, m_ > & lhs,
     const linear_congruential_engine< UIntType_, a_, c_, m_ > & rhs);

This function checks two `linear_congruential_engines` for
equality.

**Function Parameters**:

-  **lhs** The first `linear_congruential_engine` to
   test.

-  **rhs** The second `linear_congruential_engine` to
   test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename UIntType_,
     UIntType_ a_,
     UIntType_ c_,
     UIntType_ m_>
   __host__ __device__ bool
   operator!=(const linear_congruential_engine< UIntType_, a_, c_, m_ > & lhs,
     const linear_congruential_engine< UIntType_, a_, c_, m_ > & rhs);

This function checks two `linear_congruential_engines` for
inequality.

**Function Parameters**:

-  **lhs** The first `linear_congruential_engine` to
   test.

-  **rhs** The second `linear_congruential_engine` to
   test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename UIntType_,
     UIntType_ a_,
     UIntType_ c_,
     UIntType_ m_,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const linear_congruential_engine< UIntType_, a_, c_, m_ > & e);

This function streams a
`linear_congruential_engine`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **e** The `linear_congruential_engine` to stream out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename UIntType_,
     UIntType_ a_,
     UIntType_ c_,
     UIntType_ m_,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     linear_congruential_engine< UIntType_, a_, c_, m_ > & e);

This function streams a
`linear_congruential_engine`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **e** The `linear_congruential_engine` to stream in.

**Returns**: `is`

**thrust::random::operator==**

::

   template <typename UIntType_,
     size_t w_,
     size_t k_,
     size_t q_,
     size_t s_>
   __host__ __device__ bool
   operator==(const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & lhs,
     const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & rhs);

This function checks two `linear_feedback_shift_engines` for
equality.

**Function Parameters**:

-  **lhs** The first `linear_feedback_shift_engine` to
   test.

-  **rhs** The second `linear_feedback_shift_engine` to
   test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename UIntType_,
     size_t w_,
     size_t k_,
     size_t q_,
     size_t s_>
   __host__ __device__ bool
   operator!=(const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & lhs,
     const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & rhs);

This function checks two `linear_feedback_shift_engines` for
inequality.

**Function Parameters**:

-  **lhs** The first `linear_feedback_shift_engine` to
   test.

-  **rhs** The second `linear_feedback_shift_engine` to
   test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename UIntType_,
     size_t w_,
     size_t k_,
     size_t q_,
     size_t s_,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & e);

This function streams a
`linear_feedback_shift_engine`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **e** The `linear_feedback_shift_engine` to stream
   out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename UIntType_,
     size_t w_,
     size_t k_,
     size_t q_,
     size_t s_,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     linear_feedback_shift_engine< UIntType_, w_, k_, q_, s_ > & e);

This function streams a
`linear_feedback_shift_engine`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **e** The `linear_feedback_shift_engine` to stream in.

**Returns**: `is`

**thrust::random::operator==**

::

   template <typename UIntType_,
     size_t w_,
     size_t s_,
     size_t r_>
   __host__ __device__ bool
   operator==(const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & lhs,
     const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & rhs);

This function checks two `subtract_with_carry_engines` for
equality.

**Function Parameters**:

-  **lhs** The first `subtract_with_carry_engine` to
   test.

-  **rhs** The second `subtract_with_carry_engine` to
   test.

**Returns**: `true` if `lhs` is equal to `rhs`;
`false`, otherwise.

**thrust::random::operator!=**

::

   template <typename UIntType_,
     size_t w_,
     size_t s_,
     size_t r_>
   __host__ __device__ bool
   operator!=(const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & lhs,
     const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & rhs);

This function checks two `subtract_with_carry_engines` for
inequality.

**Function Parameters**:

-  **lhs** The first `subtract_with_carry_engine` to
   test.

-  **rhs** The second `subtract_with_carry_engine` to
   test.

**Returns**: `true` if `lhs` is not equal to `rhs`;
`false`, otherwise.

**thrust::random::operator<<**

::

   template <typename UIntType_,
     size_t w_,
     size_t s_,
     size_t r_,
     typename CharT,
     typename Traits>
   std::basic_ostream< CharT, Traits > &
   operator<<(std::basic_ostream< CharT, Traits > & os,
     const subtract_with_carry_engine< UIntType_, w_, s_, r_ > & e);

This function streams a
`subtract_with_carry_engine`
to a `std::basic_ostream`.

**Function Parameters**:

-  **os** The `basic_ostream` to stream out to.

-  **e** The `subtract_with_carry_engine` to stream out.

**Returns**: `os`

**thrust::random::operator>>**

::

   template <typename UIntType_,
     size_t w_,
     size_t s_,
     size_t r_,
     typename CharT,
     typename Traits>
   std::basic_istream< CharT, Traits > &
   operator>>(std::basic_istream< CharT, Traits > & is,
     subtract_with_carry_engine< UIntType_, w_, s_, r_ > & e);

This function streams a
`subtract_with_carry_engine`
in from a std::basic_istream.

**Function Parameters**:

-  **is** The `basic_istream` to stream from.

-  **e** The `subtract_with_carry_engine` to stream in.

**Returns**: `is`

System
======

-  `Systems`

-  `System Diagnostics`

`/* thrust::system` is the namespace which contains specific
Thrust backend systems. It also contains functionality for
reporting error conditions originating from the operating
system or other low-level application program interfaces such
as the CUDA runtime. They are provided in a separate namespace
for import convenience but are also aliased in the top-level
`thrust` namespace for easy access.
\*/namespace\ `thrust::system`\ {
… }

Systems
-------

**Systems**

`thrust::cpp` is a top-level alias for thrust::system::cpp.

`thrust::system` is the namespace which contains
specific Thrust backend systems. It also contains
functionality for reporting error conditions originating from
the operating system or other low-level application program
interfaces such as the CUDA runtime. They are provided in a
separate namespace for import convenience but are also
aliased in the top-level `thrust` namespace for easy
access.

`thrust::system::cuda` is the namespace containing
functionality for allocating, manipulating, and deallocating
memory available to Thrust's CUDA backend system. The
identifiers are provided in a separate namespace underneath
`thrust::system` for import convenience but are also
aliased in the top-level `thrust::cuda` namespace for easy
access.

`thrust::omp` is a top-level alias for thrust::system::omp.

`thrust::tbb` is a top-level alias for thrust::system::tbb.

**Types**

**thrust::system::cpp::pointer**

::

   template <typename T>
   using pointer = thrust::pointer< T, thrust::system::cpp::tag, thrust::tagged_reference< T, thrust::system::cpp::tag > >;

`cpp::pointer` stores a pointer to an object allocated in
memory accessible by the `cpp` system. This type provides
type safety when dispatching algorithms on ranges resident in
`cpp` memory.

`cpp::pointer` has pointer semantics: it may be dereferenced
and manipulated with pointer arithmetic.

`cpp::pointer` can be created with the function
`cpp::malloc`, or by explicitly calling its constructor with
a raw pointer.

The raw pointer encapsulated by a `cpp::pointer` may be
obtained by eiter its `get` member function or the
`raw_pointer_cast` function.

**Note**: `cpp::pointer` is not a “smart” pointer; it is the
programmer’s responsibility to deallocate memory pointed to by
`cpp::pointer`.

**Template Parameters**: **T**: specifies the type of the
pointee.

**See**:

-  cpp::malloc

-  cpp::free

-  raw_pointer_cast

**thrust::system::cpp::universal_pointer**

::

   template <typename T>
   using universal_pointer = thrust::pointer< T, thrust::system::cpp::tag, typename std::add_lvalue_reference< T >::type >;

`cpp::universal_pointer` stores a pointer to an object
allocated in memory accessible by the `cpp` system and host
systems.

`cpp::universal_pointer` has pointer semantics: it may be
dereferenced and manipulated with pointer arithmetic.

`cpp::universal_pointer` can be created with
`cpp::universal_allocator` or by explicitly calling its
constructor with a raw pointer.

The raw pointer encapsulated by a `cpp::universal_pointer`
may be obtained by eiter its `get` member function or the
`raw_pointer_cast` function.

**Note**: `cpp::universal_pointer` is not a “smart” pointer;
it is the programmer’s responsibility to deallocate memory
pointed to by `cpp::universal_pointer`.

**Template Parameters**: **T**: specifies the type of the
pointee.

**See**:

-  cpp::universal_allocator

-  raw_pointer_cast

**thrust::system::cpp::reference**

::

   template <typename T>
   using reference = thrust::reference< T, thrust::system::cpp::tag >;

`reference` is a wrapped reference to an object stored in
memory available to the `cpp` system. `reference` is the
type of the result of dereferencing a `cpp::pointer`.

**Template Parameters**: **T**: Specifies the type of the
referenced object.

**thrust::system::omp::pointer**

::

   template <typename T>
   using pointer = thrust::pointer< T, thrust::system::omp::tag, thrust::tagged_reference< T, thrust::system::omp::tag > >;

`omp::pointer` stores a pointer to an object allocated in
memory accessible by the `omp` system. This type provides
type safety when dispatching algorithms on ranges resident in
`omp` memory.

`omp::pointer` has pointer semantics: it may be dereferenced
and manipulated with pointer arithmetic.

`omp::pointer` can be created with the function
`omp::malloc`, or by explicitly calling its constructor with
a raw pointer.

The raw pointer encapsulated by a `omp::pointer` may be
obtained by eiter its `get` member function or the
`raw_pointer_cast` function.

**Note**: `omp::pointer` is not a “smart” pointer; it is the
programmer’s responsibility to deallocate memory pointed to by
`omp::pointer`.

**Template Parameters**: **T**: specifies the type of the
pointee.

**See**:

-  omp::malloc

-  omp::free

-  raw_pointer_cast

**thrust::system::omp::universal_pointer**

::

   template <typename T>
   using universal_pointer = thrust::pointer< T, thrust::system::omp::tag, typename std::add_lvalue_reference< T >::type >;

`omp::universal_pointer` stores a pointer to an object
allocated in memory accessible by the `omp` system and host
systems.

`omp::universal_pointer` has pointer semantics: it may be
dereferenced and manipulated with pointer arithmetic.

`omp::universal_pointer` can be created with
`omp::universal_allocator` or by explicitly calling its
constructor with a raw pointer.

The raw pointer encapsulated by a `omp::universal_pointer`
may be obtained by eiter its `get` member function or the
`raw_pointer_cast` function.

**Note**: `omp::universal_pointer` is not a “smart” pointer;
it is the programmer’s responsibility to deallocate memory
pointed to by `omp::universal_pointer`.

**Template Parameters**: **T**: specifies the type of the
pointee.

**See**:

-  omp::universal_allocator

-  raw_pointer_cast

**thrust::system::omp::reference**

::

   template <typename T>
   using reference = thrust::tagged_reference< T, thrust::system::omp::tag >;

`reference` is a wrapped reference to an object stored in
memory available to the `omp` system. `reference` is the
type of the result of dereferencing a `omp::pointer`.

**Template Parameters**: **T**: Specifies the type of the
referenced object.

**thrust::system::tbb::pointer**

::

   template <typename T>
   using pointer = thrust::pointer< T, thrust::system::tbb::tag, thrust::tagged_reference< T, thrust::system::tbb::tag > >;

`tbb::pointer` stores a pointer to an object allocated in
memory accessible by the `tbb` system. This type provides
type safety when dispatching algorithms on ranges resident in
`tbb` memory.

`tbb::pointer` has pointer semantics: it may be dereferenced
and manipulated with pointer arithmetic.

`tbb::pointer` can be created with the function
`tbb::malloc`, or by explicitly calling its constructor with
a raw pointer.

The raw pointer encapsulated by a `tbb::pointer` may be
obtained by eiter its `get` member function or the
`raw_pointer_cast` function.

**Note**: `tbb::pointer` is not a “smart” pointer; it is the
programmer’s responsibility to deallocate memory pointed to by
`tbb::pointer`.

**Template Parameters**: **T**: specifies the type of the
pointee.

**See**:

-  tbb::malloc

-  tbb::free

-  raw_pointer_cast

**thrust::system::tbb::universal_pointer**

::

   template <typename T>
   using universal_pointer = thrust::pointer< T, thrust::system::tbb::tag, typename std::add_lvalue_reference< T >::type >;

`tbb::universal_pointer` stores a pointer to an object
allocated in memory accessible by the `tbb` system and host
systems.

`tbb::universal_pointer` has pointer semantics: it may be
dereferenced and manipulated with pointer arithmetic.

`tbb::universal_pointer` can be created with
`tbb::universal_allocator` or by explicitly calling its
constructor with a raw pointer.

The raw pointer encapsulated by a `tbb::universal_pointer`
may be obtained by eiter its `get` member function or the
`raw_pointer_cast` function.

**Note**: `tbb::universal_pointer` is not a “smart” pointer;
it is the programmer’s responsibility to deallocate memory
pointed to by `tbb::universal_pointer`.

**Template Parameters**: **T**: specifies the type of the
pointee.

**See**:

-  tbb::universal_allocator

-  raw_pointer_cast

**thrust::system::tbb::reference**

::

   template <typename T>
   using reference = thrust::tagged_reference< T, thrust::system::tbb::tag >;

`reference` is a wrapped reference to an object stored in
memory available to the `tbb` system. `reference` is the
type of the result of dereferencing a `tbb::pointer`.

**Template Parameters**: **T**: Specifies the type of the
referenced object.

System Diagnostics
------------------

**System Diagnostics**

::

   namespace thrust::system::errc { … }

   template <typename T>
   struct
   thrust::system::is_error_code_enum;

   template <typename T>
   struct
   thrust::system::is_error_condition_enum;

   struct
   thrust::system::is_error_condition_enum< errc::errc_t >;

The class error_category serves as a base class for types used to identify the source
and encoding of a particular category of error code. Classes
may be derived from `error_category` to support categories
of errors in addition to those defined in the C++
International Standard.

The class `error_code` describes an object used to hold
error code values, such as those originating from the
operating system or other low-level application program
interfaces.

The class `error_condition` describes an object used to
hold values identifying error conditions.

The class `system_error` describes an exception object
used to report error conditions that have an associated
`error_code`. Such error conditions typically originate
from the operating system or other low-level application
program interfaces.

**Member Classes**

**thrust::system::is_error_code_enum**

**Inherits From**: `thrust::detail::false_type`

**thrust::system::is_error_condition_enum**

**Inherits From**: `thrust::detail::false_type`

**thrust::system::is_error_condition_enum< errc::errc_t >**

**Inherits From**: `thrust::detail::true_type`

**thrust::system::error_category**

The class `error_category` serves as a base class for types
used to identify the source and encoding of a particular
category of error code. Classes may be derived from
`error_category` to support categories of errors in addition
to those defined in the C++ International Standard.

**thrust::system::error_code**

The class `error_code` describes an object used to hold error
code values, such as those originating from the operating
system or other low-level application program interfaces.

**thrust::system::error_condition**

The class `error_condition` describes an object used to hold
values identifying error conditions.

**thrust::system::system_error**

The class `system_error` describes an exception object used
to report error conditions that have an associated
`error_code`. Such error conditions typically originate from
the operating system or other low-level application program
interfaces.

**Inherits From**: `std::runtime_error`

**Functions**

**thrust::system::generic_category**

`const error_category & generic_category(void);` **Note**:
The object’s `default_error_condition` and `equivalent`
virtual functions shall behave as specified for the class
`error_category`. The object’s `name` virtual function
shall return a pointer to the string `"generic"`.

**Returns**: A reference to an object of a type derived from
class `error_category`.

**thrust::system::system_category**

`const error_category & system_category(void);`

If the argument `ev` corresponds to a POSIX `errno` value
`posv`, the function shall return
`error_condition(ev,generic_category())`. Otherwise, the
function shall return
`error_condition(ev,system_category())`. What constitutes
correspondence for any given operating system is unspecified.

**Note**: The object’s `equivalent` virtual functions shall
behave as specified for class `error_category`. The object’s
`name` virtual function shall return a pointer to the string
`"system"`. The object’s `default_error_condition` virtual
function shall behave as follows:

**Returns**: A reference to an object of a type derived from
class `error_category`.

**thrust::system::make_error_code**

`error_code make_error_code(cuda::errc::errc_t e);`
**Returns**:

-  `error_code(static_cast<int>(e), cuda::error_category())`

-  `error_code(static_cast<int>(e), generic_category())`

**thrust::system::operator<**

::

   bool
   operator<(const error_code & lhs,
     const error_code & rhs);

**Returns**:
`lhs.category() < rhs.category() || lhs.category() == rhs.category() && lhs.value() < rhs.value()`.

**thrust::system::operator<<**

::

   template <typename charT,
     typename traits>
   std::basic_ostream< charT, traits > &
   operator<<(std::basic_ostream< charT, traits > & os,
     const error_code & ec);

Effects: `os << ec.category().name() << ':' << ec.value()`.

**thrust::system::make_error_condition**

`error_condition make_error_condition(cuda::errc::errc_t e);`
**Returns**:

-  `error_condition(static_cast<int>(e), cuda::error_category())`.

-  `error_condition(static_cast<int>(e), generic_category())`.

**thrust::system::operator<**

::

   bool
   operator<(const error_condition & lhs,
     const error_condition & rhs);

**Returns**:
`lhs.category() < rhs.category() || lhs.category() == rhs.category() && lhs.value() < rhs.value()`.

**thrust::system::operator==**

::

   bool
   operator==(const error_code & lhs,
     const error_code & rhs);

**Returns**:
`lhs.category() == rhs.category() && lhs.value() == rhs.value()`.

**thrust::system::operator==**

::

   bool
   operator==(const error_code & lhs,
     const error_condition & rhs);

**Returns**:
`lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs,rhs.value())`.

**thrust::system::operator==**

::

   bool
   operator==(const error_condition & lhs,
     const error_code & rhs);

**Returns**:
`rhs.category().equivalent(lhs.value(), lhs) || lhs.category().equivalent(rhs, lhs.value())`.

**thrust::system::operator==**

::

   bool
   operator==(const error_condition & lhs,
     const error_condition & rhs);

**Returns**:
`lhs.category() == rhs.category() && lhs.value() == rhs.value()`

**thrust::system::operator!=**

::

   bool
   operator!=(const error_code & lhs,
     const error_code & rhs);

**Returns**: `!(lhs == rhs)`

**thrust::system::operator!=**

::

   bool
   operator!=(const error_code & lhs,
     const error_condition & rhs);

**Returns**: `!(lhs == rhs)`

**thrust::system::operator!=**

::

   bool
   operator!=(const error_condition & lhs,
     const error_code & rhs);

**Returns**: `!(lhs == rhs)`

**thrust::system::operator!=**

::

   bool
   operator!=(const error_condition & lhs,
     const error_condition & rhs);

**Returns**: `!(lhs == rhs)`

**thrust::system::system_error::system_error**

`system_error(error_code ec,   const std::string & what_arg);`
Constructs an object of class `system_error`.

**Function Parameters**:

-  **ec** The value returned by `code()`.

-  **what_arg** A string to include in the result returned
   by `what()`.

**Postconditions**:

-  `code() == ec`.

-  `std::string(what()).find(what_arg) != string::npos`.

**thrust::system::system_error::system_error**

`system_error(error_code ec,   const char * what_arg);`
Constructs an object of class `system_error`.

**Function Parameters**:

-  **ec** The value returned by `code()`.

-  **what_arg** A string to include in the result returned
   by `what()`.

**Postconditions**:

-  `code() == ec`.

-  `std::string(what()).find(what_arg) != string::npos`.

**thrust::system::system_error::system_error**

`system_error(error_code ec);` Constructs an object of class
`system_error`.

**Function Parameters**: **ec**: The value returned by
`code()`.

**Postconditions**: `code() == ec`.

**thrust::system::system_error::system_error**

`system_error(int ev,   const error_category & ecat,   const std::string & what_arg);`
Constructs an object of class `system_error`.

**Function Parameters**:

-  **ev** The error value used to create an `error_code`.

-  **ecat** The `error_category` used to create an
   `error_code`.

-  **what_arg** A string to include in the result returned
   by `what()`.

**Postconditions**:

-  `code() == error_code(ev, ecat)`.

-  `std::string(what()).find(what_arg) != string::npos`.

**thrust::system::system_error::system_error**

`system_error(int ev,   const error_category & ecat,   const char * what_arg);`
Constructs an object of class `system_error`.

**Function Parameters**:

-  **ev** The error value used to create an `error_code`.

-  **ecat** The `error_category` used to create an
   `error_code`.

-  **what_arg** A string to include in the result returned
   by `what()`.

**Postconditions**:

-  `code() == error_code(ev, ecat)`.

-  `std::string(what()).find(what_arg) != string::npos`.

**thrust::system::system_error::system_error**

`system_error(int ev,   const error_category & ecat);`
Constructs an object of class `system_error`.

**Function Parameters**:

-  **ev** The error value used to create an `error_code`.

-  **ecat** The `error_category` used to create an
   `error_code`.

**Postconditions**: `code() == error_code(ev, ecat)`.

**thrust::system::system_error::~system_error**

`virtual ~system_error(void);` Destructor does not throw.

**thrust::system::system_error::code**

`const error_code & code(void) const;` Returns an object
encoding the error.

**Returns**: `ec` or `error_code(ev, ecat)`, from the
constructor, as appropriate.

**thrust::system::system_error::what**

`const char * what(void) const;` Returns a human-readable
string indicating the nature of the error.

**Returns**: a string incorporating `code().message()` and
the arguments supplied in the constructor.

Utility
=======

Pair
-----------

**Pair**

::

   template <typename T1,
   typename T2>
   struct
   thrust::pair;

   template <size_t N,
     class T>
   struct
   thrust::tuple_element;

   template <typename Pair>
   struct
   thrust::tuple_size;

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   thrust::operator==(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   thrust::operator<(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   thrust::operator!=(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   thrust::operator>(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   thrust::operator<=(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   thrust::operator>=(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

   template <typename T1,
     typename T2>
   __host__ __device__ void
   thrust::swap(pair< T1, T2 > & x,
     pair< T1, T2 > & y);

   template <typename T1,
     typename T2>
   __host__ __device__ pair< T1, T2 >
   thrust::make_pair(T1 x,
     T2 y);

**Member Classes**

**thrust::pair**

**thrust::tuple_element**

**thrust::tuple_size**

**Functions**

**thrust::operator==**

::

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   operator==(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

This operator tests two `pairs` for equality.

**Template Parameters**:

-  **T1** is a model of `Equality Comparable`.

-  **T2** is a model of `Equality Comparable`.

**Function Parameters**:

-  **x** The first `pair` to compare.

-  **y** The second `pair` to compare.

**Returns**: `true` if and only if
`x.first == y.first && x.second == y.second`.

**thrust::operator<**

::

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   operator<(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

This operator tests two pairs for ascending ordering.

**Template Parameters**:

-  **T1** is a model of `LessThan Comparable`.

-  **T2** is a model of `LessThan Comparable`.

**Function Parameters**:

-  **x** The first `pair` to compare.

-  **y** The second `pair` to compare.

**Returns**: `true` if and only if
`x.first < y.first || (!(y.first < x.first) && x.second < y.second)`.

**thrust::operator!=**

::

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   operator!=(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

This operator tests two pairs for inequality.

**Template Parameters**:

-  **T1** is a model of `Equality Comparable`.

-  **T2** is a model of `Equality Comparable`.

**Function Parameters**:

-  **x** The first `pair` to compare.

-  **y** The second `pair` to compare.

**Returns**: `true` if and only if `!(x == y)`.

**thrust::operator>**

::

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   operator>(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

This operator tests two pairs for descending ordering.

**Template Parameters**:

-  **T1** is a model of `LessThan Comparable`.

-  **T2** is a model of `LessThan Comparable`.

**Function Parameters**:

-  **x** The first `pair` to compare.

-  **y** The second `pair` to compare.

**Returns**: `true` if and only if `y < x`.

**thrust::operator<=**

::

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   operator<=(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

This operator tests two pairs for ascending ordering or
equivalence.

**Template Parameters**:

-  **T1** is a model of `LessThan Comparable`.

-  **T2** is a model of `LessThan Comparable`.

**Function Parameters**:

-  **x** The first `pair` to compare.

-  **y** The second `pair` to compare.

**Returns**: `true` if and only if `!(y < x)`.

**thrust::operator>=**

::

   template <typename T1,
     typename T2>
   __host__ __device__ bool
   operator>=(const pair< T1, T2 > & x,
     const pair< T1, T2 > & y);

This operator tests two pairs for descending ordering or
equivalence.

**Template Parameters**:

-  **T1** is a model of `LessThan Comparable`.

-  **T2** is a model of `LessThan Comparable`.

**Function Parameters**:

-  **x** The first `pair` to compare.

-  **y** The second `pair` to compare.

**Returns**: `true` if and only if `!(x < y)`.

**thrust::swap**

::

   template <typename T1,
     typename T2>
   __host__ __device__ void
   swap(pair< T1, T2 > & x,
     pair< T1, T2 > & y);

`swap` swaps the contents of two `pair` s.

**Function Parameters**:

-  **x** The first `pair` to swap.

-  **y** The second `pair` to swap.

**thrust::make_pair**

::

   template <typename T1,
     typename T2>
   __host__ __device__ pair< T1, T2 >
   make_pair(T1 x,
     T2 y);

This convenience function creates a `pair` from two objects.

**Template Parameters**:

-  **T1** There are no requirements on the type of `T1`.

-  **T2** There are no requirements on the type of `T2`.

**Function Parameters**:

-  **x** The first object to copy from.

-  **y** The second object to copy from.

**Returns**: A newly-constructed `pair` copied from `a` and
`b`.

Swap
----
**Swap**

::

   template <typename Assignable1,
     typename Assignable2>
   __host__ __device__ void
   thrust::swap(Assignable1 & a,
     Assignable2 & b);

**Functions**

**thrust::swap**

::

   template <typename Assignable1,
     typename Assignable2>
   __host__ __device__ void
   swap(Assignable1 & a,
     Assignable2 & b);

`swap` assigns the contents of `a` to `b` and the
contents of `b` to `a`. This is used as a primitive
operation by many other algorithms.

The following code snippet demonstrates how to use `swap` to
swap the contents of two variables.

::

   #include <thrust/swap.h>
   ...
   int x = 1;
   int y = 2;
   thrust::swap(x,h);

   // x == 2, y == 1

**Template Parameters**: **Assignable**: is a model of
`Assignable`.

**Function Parameters**:

-  **a** The first value of interest. After completion, the
   value of b will be returned here.

-  **b** The second value of interest. After completion,
   the value of a will be returned here.

Tuple
-----

**Tuple**

::

   template <size_t N,
     class T> struct thrust::tuple_element;

   template <typename Pair>
   struct
   thrust::tuple_size;

is a class template that can be instantiated with up to ten
arguments. Each template argument specifies the type of
element in the `tuple`. Consequently, tuples are
heterogeneous, fixed-size collections of values. An
instantiation of `tuple` with two arguments is similar to
an instantiation of `pair` with the same two arguments.
Individual elements of a `tuple` may be accessed with the
`get` function.

**Member Classes**

**thrust::tuple_element**

**thrust::tuple_size**

**thrust::tuple**

`tuple` is a class template that can be instantiated with up
to ten arguments. Each template argument specifies the type of
element in the `tuple`. Consequently, tuples are
heterogeneous, fixed-size collections of values. An
instantiation of `tuple` with two arguments is similar to an
instantiation of `pair` with the same two arguments.
Individual elements of a `tuple` may be accessed with the
`get` function.

**Functions**

**thrust::get**

::

   template <int N,
     class HT,
     class TT>
   __host__ __device__ access_traits< typenametuple_element< N, detail::cons< HT, TT > >::type >::non_const_type
   get(detail::cons< HT, TT > & t);

The `get` function returns a reference to a `tuple` element
of interest.

The following code snippet demonstrates how to use `get` to
print the value of a `tuple` element.

::

   #include <thrust/tuple.h>
   #include <iostream>
   ...
   thrust::tuple<int, const char *> t(13, "thrust");

   std::cout << "The 1st value of t is " << thrust::get<0>(t) << std::endl;

**Template Parameters**: **N**: The index of the element of
interest.

**Function Parameters**: **t**: A reference to a `tuple`
of interest.

**Returns**: A reference to `t's` `N` th element.

**See**:

-  `pair`

-  `tuple`

**thrust::get**

::

   template <int N,
     class HT,
     class TT>
   __host__ __device__ access_traits< typenametuple_element< N, detail::cons< HT, TT > >::type >::const_type
   get(const detail::cons< HT, TT > & t);

The `get` function returns a `const` reference to a
`tuple` element of interest.

The following code snippet demonstrates how to use `get` to
print the value of a `tuple` element.

::

   #include <thrust/tuple.h>
   #include <iostream>
   ...
   thrust::tuple<int, const char *> t(13, "thrust");

   std::cout << "The 1st value of t is " << thrust::get<0>(t) << std::endl;

**Template Parameters**: **N**: The index of the element of
interest.

**Function Parameters**: **t**: A reference to a `tuple`
of interest.

**Returns**: A `const` reference to `t's` `N` th
element.

**See**:

-  `pair`

-  `tuple`

**thrust::make_tuple**

::

   template <class T0> __host__ __device__ detail::make_tuple_mapper< T0 >::type make_tuple(const T0 & t0);

This version of `make_tuple` creates a new `tuple` object
from a single object.

**Function Parameters**: **t0**: The object to copy from.

**Returns**: A `tuple` object with a single member which is a
copy of `t0`.

**thrust::make_tuple**

::

   template <class T0,
     class T1>
   __host__ __device__ detail::make_tuple_mapper< T0, T1 >::type
   make_tuple(const T0 & t0,   const T1 & t1);

This version of `make_tuple` creates a new `tuple` object
from two objects.

**Note**: `make_tuple` has ten variants, the rest of which
are omitted here for brevity.

**Function Parameters**:

-  **t0** The first object to copy from.

-  **t1** The second object to copy from.

**Returns**: A `tuple` object with two members which are
copies of `t0` and `t1`.

**thrust::tie**

::

   template <typename T0> __host__ __device__ tuple< T0 & > tie(T0 & t0);

This version of `tie` creates a new `tuple` whose single
element is a reference which refers to this function’s
argument.

**Function Parameters**: **t0**: The object to reference.

**Returns**: A `tuple` object with one member which is a
reference to `t0`.

**thrust::tie**

::

   template <typename T0,
     typename T1>
   __host__ __device__ tuple< T0 &, T1 & >
   tie(T0 & t0,
     T1 & t1);

This version of `tie` creates a new `tuple` of references
object which refers to this function’s arguments.

**Note**: `tie` has ten variants, the rest of which are
omitted here for brevity.

**Function Parameters**:

-  **t0** The first object to reference.

-  **t1** The second object to reference.

**Returns**: A `tuple` object with two members which are
references to `t0` and `t1`.

**thrust::swap**

::

   template <typename T0,
     typename T1,
     typename T2,
     typename T3,
     typename T4,
     typename T5,
     typename T6,
     typename T7,
     typename T8,
     typename T9,
     typename U0,
     typename U1,
     typename U2,
     typename U3,
     typename U4,
     typename U5,
     typename U6,
     typename U7,
     typename U8,
     typename U9>
   __host__ __device__ void
   swap(tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9 > & x,
     tuple< U0, U1, U2, U3, U4, U5, U6, U7, U8, U9 > & y);

`swap` swaps the contents of two `tuple` s.

**Function Parameters**:

-  **x** The first `tuple` to swap.

-  **y** The second `tuple` to swap.

Type Traits
-----------

**Type Traits**

`Customization point` that can be customized to indicate that an iterator type Iterator satisfies
`ContiguousIterator`,
aka it points to elements that are contiguous in memory.

**Member Classes**

**thrust::proclaim_contiguous_iterator**

Customization point that can be customized to indicate that an
iterator type `Iterator` satisfies
`ContiguousIterator`,
aka it points to elements that are contiguous in memory.

**Inherits From**: `false_type`

**thrust::conjunction_value**

`std::integral_constant`
whose value is `(... && Bs)`.

**thrust::disjunction_value**

`std::integral_constant`
whose value is `(... || Bs)`.

**thrust::negation_value**

`std::integral_constant`
whose value is `!Bs`.

**thrust::remove_cvref**

`UnaryTypeTrait`
that removes `const-volatile qualifiers`
and
`references`
from `T`. Equivalent to
`remove_cv_t<remove_reference_t<T>>`.

**thrust::voider**

**Types**

**thrust::integer_sequence**

::

   template <typename T,
     T... Is>
   using
   integer_sequence = std::integer_sequence< T, Is... >;

A compile-time sequence of `integral constants`
of type `T` with values `Is...`.

**See**:

-  `integral constants`

-  index_sequence

-  make_integer_sequence

-  make_reversed_integer_sequence

-  make_index_sequence

-  make_reversed_index_sequence

-  integer_sequence_push_front

-  integer_sequence_push_back

-  `std::integer_sequence`

**thrust::index_sequence**

::

   template <std::size_t... Is> using index_sequence = std::index_sequence< Is... >;

A compile-time sequence of type
`std::size_t`
with values `Is...`.

**See**:

-  integer_sequence

-  make_integer_sequence

-  make_reversed_integer_sequence

-  make_index_sequence

-  make_reversed_index_sequence

-  integer_sequence_push_front

-  integer_sequence_push_back

-  `std::index_sequence`

**thrust::make_integer_sequence**

::

   template <typename T,
     std::size_t N>
   using
   make_integer_sequence = std::make_integer_sequence< T, N >;

Create a new `integer_sequence` with elements
`0, 1, 2, ..., N - 1` of type `T`.

**See**:

-  integer_sequence

-  index_sequence

-  make_reversed_integer_sequence

-  make_index_sequence

-  make_reversed_index_sequence

-  `std::make_integer_sequence`

**thrust::make_index_sequence**

::

   template <std::size_t N> using make_index_sequence = std::make_index_sequence< N >;

Create a new `integer_sequence` with elements
`0, 1, 2, ..., N - 1` of type
`std::size_t`.

**See**:

-  integer_sequence

-  index_sequence

-  make_integer_sequence

-  make_reversed_integer_sequence

-  make_reversed_index_sequence

-  `std::make_index_sequence`

**thrust::make_reversed_integer_sequence**

::

   template <typename T,
     std::size_t N>
   using
   make_reversed_integer_sequence = typename detail::make_reversed_integer_sequence_impl< T, N >::type;

Create a new `integer_sequence` with elements
`N - 1, N - 2, N - 3, ..., 0`.

**See**:

-  integer_sequence

-  index_sequence

-  make_integer_sequence

-  make_index_sequence

-  make_reversed_index_sequence

**thrust::make_reversed_index_sequence**

::

   template <std::size_t N> using make_reversed_index_sequence = make_reversed_integer_sequence< std::size_t, N >;

Create a new `index_sequence` with elements
`N - 1, N - 2, N - 3, ..., 0`.

**See**:

-  integer_sequence

-  index_sequence

-  make_integer_sequence

-  make_reversed_integer_sequence

-  make_reversed_index_sequence

**thrust::integer_sequence_push_front**

::

   template <typename T,
     T Value,
     typename Sequence>
   using
   integer_sequence_push_front = typename detail::integer_sequence_push_front_impl< T, Value, Sequence >::type;

Add a new element to the front of an `integer_sequence`.

**See**:

-  integer_sequence

-  index_sequence

-  make_integer_sequence

-  make_index_sequence

**thrust::integer_sequence_push_back**

::

   template <typename T,
     T Value,
     typename Sequence>
   using
   integer_sequence_push_back = typename detail::integer_sequence_push_back_impl< T, Value, Sequence >::type;

Add a new element to the back of an `integer_sequence`.

**See**:

-  integer_sequence

-  index_sequence

-  make_integer_sequence

-  make_index_sequence

**thrust::is_contiguous_iterator**

::

   template <typename Iterator> using is_contiguous_iterator = detail::is_contiguous_iterator_impl< Iterator >;

`UnaryTypeTrait`
that returns `true_type` if `Iterator` satisfies
`ContiguousIterator`,
aka it points to elements that are contiguous in memory, and
`false_type` otherwise.

**See**:

-  is_contiguous_iterator_v

-  `proclaim_contiguous_iterator`

-  `THRUST_PROCLAIM_CONTIGUOUS_ITERATOR`

**thrust::is_execution_policy**

::

   template <typename T> using is_execution_policy = detail::is_base_of< detail::execution_policy_marker, T >;

`UnaryTypeTrait`
that returns `true_type` if `T` is an *ExecutionPolicy* and
`false_type` otherwise.

**thrust::is_operator_less_function_object**

::

   template <typename T> using is_operator_less_function_object = detail::is_operator_less_function_object_impl< T >;

`UnaryTypeTrait`
that returns `true_type` if `T` is a
`BinaryPredicate`
equivalent to `operator<`, and `false_type` otherwise.

**See**:

-  is_operator_less_function_object_v

-  is_operator_greater_function_object

-  is_operator_less_or_greater_function_object

-  is_operator_plus_function_object

**thrust::is_operator_greater_function_object**

::

   template <typename T> using is_operator_greater_function_object = detail::is_operator_greater_function_object_impl< T >;

`UnaryTypeTrait`
that returns `true_type` if `T` is a
`BinaryPredicate`
equivalent to `operator>`, and `false_type` otherwise.

**See**:

-  is_operator_greater_function_object_v

-  is_operator_less_function_object

-  is_operator_less_or_greater_function_object

-  is_operator_plus_function_object

**thrust::is_operator_less_or_greater_function_object**

::

   template <typename T> using is_operator_less_or_greater_function_object = integral_constant< bool, detail::is_operator_less_function_object_impl< T >::value||detail::is_operator_greater_function_object_impl< T >::value >;

`UnaryTypeTrait`
that returns `true_type` if `T` is a
`BinaryPredicate`
equivalent to `operator<` or `operator>`, and
`false_type` otherwise.

**See**:

-  is_operator_less_or_greater_function_object_v

-  is_operator_less_function_object

-  is_operator_greater_function_object

-  is_operator_plus_function_object

**thrust::is_operator_plus_function_object**

::

   template <typename T> using is_operator_plus_function_object = detail::is_operator_plus_function_object_impl< T >;

`UnaryTypeTrait`
that returns `true_type` if `T` is a
`FunctionObject`
equivalent to `operator+`, and `false_type` otherwise.

**See**:

-  is_operator_plus_function_object_v

-  is_operator_less_function_object

-  is_operator_greater_function_object

-  is_operator_less_or_greater_function_object

**thrust::conjunction**

::

   template <typename... Ts> using conjunction = std::conjunction< Ts... >;

`std::integral_constant`
whose value is `(... && Ts::value)`.

**See**:

-  conjunction_v

-  `conjunction_value`

-  `std::conjunction`

**thrust::disjunction**

::

   template <typename... Ts> using disjunction = std::disjunction< Ts... >;

`std::integral_constant`
whose value is `(... || Ts::value)`.

**See**:

-  disjunction_v

-  `disjunction_value`

-  `std::disjunction`

**thrust::negation**

::

   template <typename T> using negation = std::negation< T >;

`std::integral_constant`
whose value is `!Ts::value`.

**See**:

-  negation_v

-  `negation_value`

-  `std::negation`

**thrust::remove_cvref_t**

::

   template <typename T> using remove_cvref_t = typename remove_cvref< T >::type;

Type alias that removes `const-volatile qualifiers`
and
`references`
from `T`. Equivalent to
`remove_cv_t<remove_reference_t<T>>`.

**See**:

-  `std::remove_cvref`

-  `std::remove_cv`

-  `std::remove_const`

-  `std::remove_volatile`

-  `std::remove_reference`

**Variables**

**thrust::is_contiguous_iterator_v**

::

   template <typename Iterator> constexpr bool is_contiguous_iterator_v = is_contiguous_iterator<Iterator>::value;

`constexpr bool` that is `true` if `Iterator` satisfies
`ContiguousIterator`,
aka it points to elements that are contiguous in memory, and
`false` otherwise.

**See**:

-  is_contiguous_iterator

-  `proclaim_contiguous_iterator`

-  `THRUST_PROCLAIM_CONTIGUOUS_ITERATOR`

**thrust::is_execution_policy_v**

::

   template <typename T> constexpr bool is_execution_policy_v = is_execution_policy<T>::value;

`constexpr bool` that is `true` if `T` is an
*ExecutionPolicy* and `false` otherwise.

**thrust::is_operator_less_function_object_v**

::

   template <typename T> constexpr bool is_operator_less_function_object_v = is_operator_less_function_object<T>::value;

`constexpr bool` that is `true` if `T` is a
`BinaryPredicate`
equivalent to `operator<`, and `false` otherwise.

**See**:

-  is_operator_less_function_object

-  is_operator_greater_function_object

-  is_operator_less_or_greater_function_object

-  is_operator_plus_function_object

**thrust::is_operator_greater_function_object_v**

::

   template <typename T> constexpr bool is_operator_greater_function_object_v = is_operator_greater_function_object<T>::value;

`constexpr bool` that is `true` if `T` is a
`BinaryPredicate`
equivalent to `operator>`, and `false` otherwise.

**See**:

-  is_operator_greater_function_object

-  is_operator_less_function_object

-  is_operator_less_or_greater_function_object

-  is_operator_plus_function_object

**thrust::is_operator_less_or_greater_function_object_v**

::

   template <typename T> constexpr bool is_operator_less_or_greater_function_object_v = is_operator_less_or_greater_function_object<T>::value;

`constexpr bool` that is `true` if `T` is a
`BinaryPredicate`
equivalent to `operator<` or `operator>`, and `false`
otherwise.

**See**:

-  is_operator_less_or_greater_function_object

-  is_operator_less_function_object

-  is_operator_greater_function_object

-  is_operator_plus_function_object

**thrust::is_operator_plus_function_object_v**

::

   template <typename T> constexpr bool is_operator_plus_function_object_v = is_operator_plus_function_object<T>::value;

`constexpr bool` that is `true` if `T` is a
`FunctionObject`
equivalent to `operator<`, and `false` otherwise.

**See**:

-  is_operator_plus_function_object

-  is_operator_less_function_object

-  is_operator_greater_function_object

-  is_operator_less_or_greater_function_object

**thrust::conjunction_v**

::

   template <typename... Ts> constexpr bool conjunction_v = conjunction<Ts...>::value;

`constexpr bool` whose value is `(... && Ts::value)`.

**See**:

-  conjunction

-  `conjunction_value`

-  `std::conjunction`

**thrust::disjunction_v**

::

   template <typename... Ts> constexpr bool disjunction_v = disjunction<Ts...>::value;

`constexpr bool` whose value is `(... || Ts::value)`.

**See**:

-  disjunction

-  `disjunction_value`

-  `std::disjunction`

**thrust::negation_v**

::

   template <typename T> constexpr bool negation_v = negation<T>::value;

`constexpr bool` whose value is `!Ts::value`.

**See**:

-  negation

-  `negation_value`

-  `std::negation`

**thrust::conjunction_value_v**

::

   template <bool... Bs> constexpr bool conjunction_value_v = conjunction_value<Bs...>::value;

`constexpr bool` whose value is `(... && Bs)`.

**See**:

-  `conjunction_value`

-  conjunction

-  `std::conjunction`

**thrust::disjunction_value_v**

::

   template <bool... Bs> constexpr bool disjunction_value_v = disjunction_value<Bs...>::value;

`constexpr bool` whose value is `(... || Bs)`.

**See**:

-  `disjunction_value`

-  disjunction

-  `std::disjunction`

**thrust::negation_value_v**

::

   template <bool B> constexpr bool negation_value_v = negation_value<B>::value;

`constexpr bool` whose value is `!Ts::value`.

**See**:

-  `negation_value`

-  negation

-  `std::negation`

**Macros**

**THRUST_PROCLAIM_CONTIGUOUS_ITERATOR**

Declares that the iterator `Iterator` is
`ContiguousIterator`
by specializing `proclaim_contiguous_iterator`.

**See**:

-  is_contiguous_iterator

-  proclaim_contiguous_iterator
